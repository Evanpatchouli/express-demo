<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>软件构建 - 跟着例子学Express.js</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">模块化学习</li><li class="chapter-item expanded "><a href="../chapter_1/intro.html"><strong aria-hidden="true">1.</strong> 本章简介</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_1.html"><strong aria-hidden="true">2.</strong> HelloWorld</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_2.html"><strong aria-hidden="true">3.</strong> 请求类型</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_3.html"><strong aria-hidden="true">4.</strong> 处理请求数据</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_4.html"><strong aria-hidden="true">5.</strong> 响应</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_5.html"><strong aria-hidden="true">6.</strong> Sql-knex增删改查</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_6.html"><strong aria-hidden="true">7.</strong> Sql-ORM增删改查</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_7.html"><strong aria-hidden="true">8.</strong> 路由控制</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_8.html"><strong aria-hidden="true">9.</strong> JWT基础鉴权</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_9.html"><strong aria-hidden="true">10.</strong> 全局错误处理</a></li><li class="chapter-item expanded "><a href="../chapter_1/section_10.html"><strong aria-hidden="true">11.</strong> 中间件</a></li><li class="chapter-item expanded affix "><li class="part-title">架构整合</li><li class="chapter-item expanded "><a href="../chapter_2/intro.html"><strong aria-hidden="true">12.</strong> 本章简介</a></li><li class="chapter-item expanded "><a href="../chapter_2/section_1.html"><strong aria-hidden="true">13.</strong> express-cli</a></li><li class="chapter-item expanded "><a href="../chapter_2/section_2.html"><strong aria-hidden="true">14.</strong> MVC层级架构</a></li><li class="chapter-item expanded "><a href="../chapter_2/section_3.html"><strong aria-hidden="true">15.</strong> 分布式架构</a></li><li class="chapter-item expanded "><a href="../chapter_2/section_4.html"><strong aria-hidden="true">16.</strong> 微服务架构</a></li><li class="chapter-item expanded affix "><li class="part-title">高级进阶</li><li class="chapter-item expanded "><a href="../chapter_3/intro.html"><strong aria-hidden="true">17.</strong> 本章简介</a></li><li class="chapter-item expanded "><a href="../chapter_3/section_1.html"><strong aria-hidden="true">18.</strong> 全局变量与配置文件</a></li><li class="chapter-item expanded "><a href="../chapter_3/section_2.html"><strong aria-hidden="true">19.</strong> 数据库初始化</a></li><li class="chapter-item expanded "><a href="../chapter_3/section_3.html"><strong aria-hidden="true">20.</strong> 软件测试</a></li><li class="chapter-item expanded "><a href="../chapter_3/section_4.html" class="active"><strong aria-hidden="true">21.</strong> 软件构建</a></li><li class="chapter-item expanded "><a href="../chapter_3/section_5.html"><strong aria-hidden="true">22.</strong> Docker部署</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">跟着例子学Express.js</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="软件构建"><a class="header" href="#软件构建">软件构建</a></h1>
<p>运行node项目，一般都是直接运行源码，不过这样子部署的时候不太方便，需要拷贝整个文件夹，如果是需要交付给客户的，并且客户不需要源码，客户不懂编程知识的话，你丢给他一堆源码让该怎么让他运行呢？Java可以打包成 jar/war, C/C++可以打包为 exe，Node也迫切需要一种可靠的构建技术。前端的朋友们可能都熟悉webpack,rolliup或者是Vite，不过它们都只是将项目合并为单个js文件，运行仍旧依赖外部的js-runtime，在本节，我们将介绍一个构建Node项目为可执行程序的工具 —— <strong>pkg</strong></p>
<h2 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h2>
<p>创建如下项目目录：</p>
<pre><code class="language-TEXT">│  package.json
│  readme.md
│
├─assets
│      config.yaml
│
├─db
│      data.db
├─src
│      index.js
│
├─dist
│
└─node_modules
</code></pre>
<p>assets目录放的是静态资源，比如配置，图片，脚本什么的，我这里放一个yaml配置文件:</p>
<pre><code class="language-yaml">app:
  name: pkg-demo
  version: 0.0.1
server:
  host: 127.0.0.1
  port: 8080
</code></pre>
<p>db目录则放置我们的sqlite数据库文件<br />
以下是index.js的内容：<br />
做了3件事情，连接到sqlite数据库，提供返回config.yaml内容的接口和下载数据库文件的接口</p>
<pre><code class="language-js">const express = require('express');
const evchart = require('js-text-chart').evchart;
const app = express();
const path = require('path');
const yaml = require('js-yaml');
const fs = require('fs');
const config = yaml.load(fs.readFileSync('../assets/config.yaml'));

const dbpath = '../db/data.db';
const knex = require('knex');
const sqlite = knex({
    client: 'sqlite3',
    connection: {
      filename: dbpath,
      acquireConnectionTimeout: 1000
    },
});

app.all(&quot;*&quot;, function (req, res, next) {
    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;);
    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);
    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);
    next();
});

app.get('/', function (req, res) {
    res.send('Hello World!');
});

app.get('/config', function (req, res) {
    res.json(config);
});

app.get('/db', function (req, res) {
    res.download(dbpath);
});

const server = app.listen(config.server.port, config.server.host, () =&gt; {
    let host = server.address().address;
    let port = server.address().port;

    let str = config.app.name;
    let mode = [ &quot;close&quot;, &quot;far&quot;, undefined ];
    let chart = evchart.convert(str, mode[0]);
    console.log(chart);

    console.log(&quot;Server is ready on http://%s:%s&quot;, host, port);
})
</code></pre>
<p>此时我们访问这些接口都是可以正常用的：</p>
<pre><code class="language-console">C:\Users\GrapeX&gt;curl -X GET http://127.0.0.1:8080
Hello World!
C:\Users\GrapeX&gt;curl -X GET http://127.0.0.1:8080/config
{&quot;app&quot;:{&quot;name&quot;:&quot;pkg-demo&quot;,&quot;version&quot;:&quot;0.0.1&quot;},&quot;server&quot;:{&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:8080}}
</code></pre>
<p>接下来，我们就来实现把这个小项目构建为一个可以直接运行的exe程序，并且assets内置其中，db则还是在外边，方便我们管理数据库</p>
<h2 id="安装并配置pkg"><a class="header" href="#安装并配置pkg">安装并配置pkg</a></h2>
<p>安装pkg: <code>npm i pkg -dev</code></p>
<p>大致说一下pkg是怎么进行构建的：首先指定项目的入口js文件，然后pkg会根据代码中的依赖关系，顺藤摸瓜的把所有相关的js文件都找到，然后根据指定的node版本和编译平台环境(win,linux,macos)开始编译你写的js文件和项目安装的依赖模块，最终构建exe程序</p>
<p>pkg构建命令的结构：<code>pkg 入口文件 [options]</code></p>
<p>可以通过 <code>pkg --help</code> 查看命令选项：</p>
<pre><code class="language-console"> Options:

    -h, --help           output usage information
                            输出使用帮助信息
    -v, --version        output pkg version
                            输出 pkg 版本信息
    -t, --targets        comma-separated list of targets (see examples)
                            以逗号分隔的目标列表（参考示例）
    -c, --config         package.json or any json file with top-level config  
                            package.json 或者任何 json 文件顶层配置
    --options            bake v8 options into executable to run with them on
                            将 v8 选项打包到可执行文件中，以便它们一起运行
    -o, --output         output file name or template for several files
                            输出文件名或者多个文件的输出模板，默认为npm-package-name
    --out-path           path to save output one or more executables
                            保存输出可执行文件的路径
    -d, --debug          show more information during packaging process [off]
                            在打包过程中展示更多信息，默认关闭
    -b, --build          don't download prebuilt base binaries, build them
                            不下载预构建的基础二进制文件，而是构建它们
    --public             speed up and disclose the sources of top-level project
                            加速和公开顶级项目的源代码
    --public-packages    force specified packages to be considered public
                            强制指定包被认定为公开的
    --no-bytecode        skip bytecode generation and include source files as plain js
                            跳过字节码生成阶段，直接打包源文件为普通 js
    --no-native-build    skip native addons build
                            跳过原生插件构建
    --no-dict            comma-separated list of packages names to ignore dictionaries. Use --no-dict * to disable all dictionaries
                            以逗号分隔的包名列表忽略字典，使用 --no-dict * 禁用所有字典
    -C, --compress       [default=None] compression algorithm = Brotli or GZip
                            压缩算法 Brotli 或者 GZip. 默认关闭
</code></pre>
<p>最核心的几个选项是：</p>
<ul>
<li><code>-t</code>：必须要指明编译的依据，否则将会是默认的，比如<code>v16.16.0-linux-x64</code></li>
<li><code>--out-path</code>：通常我们都会将构建产物生成在指定的目录下</li>
<li><code>-o</code>：不填将默认为package.json中的name或入口文件名，往往我们可能希望是其它的名字</li>
</ul>
<p>要注意的是 -o 和 --out-path 不能同时设置，只能设置其中一个</p>
<h2 id="打包"><a class="header" href="#打包">打包</a></h2>
<p>对我们的项目进行基础的打包，指定入口为index.js，node版本为16，平台为64位Windows，输出路径在dist目录：</p>
<pre><code class="language-console">pkg index.js node16-win-x64 --out-path=dist/
</code></pre>
<p>或者在 package.json中添加 bin 选项：</p>
<pre><code class="language-json">{
	&quot;bin&quot;: &quot;index.js&quot;
}
</code></pre>
<p>然后使用<code>.</code>替代，pkg此时会去读取package.json中的bin：</p>
<pre><code class="language-console">pkg index.js node16-win-x64 --out-path=dist/
</code></pre>
<p>运行这条命令，你会看到pkg在拉取(fetch) node16-win-x64，不出意外的话，你半天都拉不下下来，因为它们的服务器在境外<br />
我们可以到 <a href="https://github.com">Github</a>: <a href="https://github.com/vercel/pkg-fetch/releases">https://github.com/vercel/pkg-fetch/releases</a> 上去手动下载对应的fetch包，注意版本要和你使用的 pkg 版本契合，我当前的 pkg 版本是3.4，所以我选取了 v3.4 中的 <code>node-v16.16.0-win-x64</code>，下载到本地后，进入 <code>C:\Users\{你用户}\.pkg-cache\你版本\</code>目录，拷贝下载好的文件到这里，并把<code>node</code>改成<code>fetched</code>，这样pkg下构建时就会使用事先下载好的node源了</p>
<p>构建好了，我们双击运行<code>index.exe</code>一下，很好，直接闪退，我们打命令<code>index.exe &gt; log.txt</code> 看看：</p>
<pre><code class="language-console">node:internal/fs/utils:345
    throw err;
    ^

Error: ENOENT: no such file or directory, open './assets/config.yaml'
    at Object.openSync (node:fs:585:3)
    at Object.openSync (pkg/prelude/bootstrap.js:793:32)
    at Object.readFileSync (node:fs:453:35)
    at Object.readFileSync (pkg/prelude/bootstrap.js:1079:36)
    at Object.&lt;anonymous&gt; (C:\snapshot\pkg\index.js)
    at Module._compile (pkg/prelude/bootstrap.js:1926:22)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.runMain (pkg/prelude/bootstrap.js:1979:12) {
  errno: -4058,
  syscall: 'open',
  code: 'ENOENT',
  path: './assets/config.yaml'
}
</code></pre>
<p>报错是找不到对应的文件或目录，它找不到我们的config,yaml，此时我们把assets目录复制到dist下，可以正常运行，相同的，db也要复制过来，才能正常下载data.db文件。但这并不是我们想要的，因为我们想要的是配置文件内置在exe程序中，因为往往会包含一些敏感信息。</p>
<h3 id="配置内置资源目录"><a class="header" href="#配置内置资源目录">配置内置资源目录</a></h3>
<p>当我们需要将静态资源，比如配置文件(.yaml,.json等)或者其它的非.js文件，需要事先设置资源，pkg才会把指定的资源打包进exe中<br />
配置方法是在 package.json 中配置 pkg:assets 选项：</p>
<pre><code class="language-json">  &quot;pkg&quot;: {
    &quot;assets&quot;: [
      &quot;assets**/*&quot;
    ]
  },
</code></pre>
<p>assets接收一个数组，每个元素是你指定的资源路径，可以使用通配，上面这个就是把assets下所有文件都指定为资源文件<br />
官方文档给了这么个示例：</p>
<pre><code class="language-json">  &quot;pkg&quot;: {
    &quot;scripts&quot;: &quot;build/**/*.js&quot;,
    &quot;assets&quot;: &quot;views/**/*&quot;,
    &quot;targets&quot;: [ &quot;node14-linux-arm64&quot; ],
    &quot;outputPath&quot;: &quot;dist&quot;
  }
</code></pre>
<p>scripts是指那些额外编译后的js，比如你用了大量高级esm语法的代码，被你用babel编译成的普通js，比如你用了v8的然后被编译好的js等等</p>
<p>配置好后再运行，此时还是不行，哪一步出问题了？原因在于我们的路径是这么写的，这种形式会以读取外部文件的方式去寻找：</p>
<pre><code class="language-js">fs.readFileSync('../assets/config.yaml');
</code></pre>
<p>而pkg构建的exe是一个快照程序，运行时将处于系统快照内，你可以看到index.js实际运行于C:\snapshot\pkg\index.js，所以对于项目内的资源路径，必须基于快照，快照路径可以用<code>__dirname</code>获取</p>
<pre><code class="language-js">const config = yaml.load(fs.readFileSync(`${__dirname}/assets/config.yaml`));
</code></pre>
<p>如果采取使用path模块规范化路径，甚至可以不配置package.json，因为pkg检测到<code>path</code>+<code>__dirname</code>时会自动把对应路径当成资源对待：<br />
path.join</p>
<pre><code class="language-js">    fs.readFileSync(
        path.join(
            __dirname,
            '../assets/config.yaml')
        )
</code></pre>
<p>path.resolve也行</p>
<pre><code class="language-js">    fs.readFileSync(
        path.resolve(
            __dirname,
            '../assets/config.yaml')
        )
</code></pre>
<p>到这里，exe完美的如期运行！</p>
<h3 id="正确的读取外部路径"><a class="header" href="#正确的读取外部路径">正确的读取外部路径</a></h3>
<p>但是呢，我们的代码依旧存在小小的瑕疵，就是我们的数据库路径：</p>
<pre><code class="language-js">const dbpath = '../db/data.db';
</code></pre>
<p>开发的时候是在根目录下，但部署的时候？打包完后，外部的文件路径可都是相对于exe来说的，也就是说db要放到部署目录的上级目录了，这不符合常理。所以在配置外部文件路径时，我们应当基于根目录去写。怎么获取根目录？index.js中读取<code>__dirname</code>？在pkg中行不通的，因为<code>__dirname</code>已经成为项目内的虚拟路径了</p>
<p>正确的做法是 <code>process.cwd()</code>，这个命令可以直接获取到项目根目录路径(入口文件路径)：</p>
<pre><code class="language-js">const dbpath = `${process.cwd()}/db/data.db`;
</code></pre>
<p>或者用path规范化路径：</p>
<pre><code class="language-js">const dbpath = path.join(process.cwd(), './db/data.db');
</code></pre>
<h2 id="压缩"><a class="header" href="#压缩">压缩</a></h2>
<p>在构建的时候还可以指定<code>--compress</code>参数，来减小构建产物的体积，如：</p>
<pre><code class="language-js">pkg . -t node16-win-x64 --compress GZip --out-path=dist/
</code></pre>
<p>本节的示例项目exe由原先的46MB缩小到了40MB，压缩效果还行，不过毕竟压缩了，多多总会对程序的性能造成一点影响，如果你的项目有较高的性能需求，请慎重考虑是否压缩</p>
<h2 id="其它"><a class="header" href="#其它">其它</a></h2>
<p>关于<code>--no-bytecode</code>参数，开启的话，构建的时候pkg不会将js转为二进制，而是直接以js打包进exe内，体积会小一点，不过js源码的运行效率自然会比二进制程序要逊色一点。</p>
<h3 id="es6"><a class="header" href="#es6">es6+</a></h3>
<p>此外，如果你使用了一些es6+的模块，如axios，pkg构建时会报错，<code>--no-bytecode</code>参数可以逃避构建时的报错，但这是治标不治本，运行照样跑不通。</p>
<p>我的建议是，使用这些依赖预编译好的普通js版本(axios的package.json似乎写的有点问题，可以手动把代码拷出来用)，如果没有你就手动用babel编译，或者直接使用它们的老的普通js的版本，如 axios 0.27.2 及以前的。</p>
<h3 id="以axios为例"><a class="header" href="#以axios为例">以Axios为例</a></h3>
<p>现在新增一个<code>/toConfig</code>接口，该接口用axios请求之前的<code>/config</code>接口并返回响应结果：</p>
<pre><code class="language-js">const axios = require('axios').default; //pkg打包失败

app.get('/toConfig', function (req, res) {
    axios.get(`http://${config.server.host}:${config.server.port}/config`)
    .then(function (resp) {
        res.json(resp.data);
    })
});
</code></pre>
<p>直接用 pkg 构建会出错，因为 pkg 基于 CommonJs 模块，而新版的 axios 默认导出的是 ESModule</p>
<ul>
<li><strong>方案1</strong>：拷贝axios.cjs</li>
</ul>
<p>拷贝<code>node_modules\axios\dist\node\axios.cjs</code>放到自己的源码下并引用：</p>
<pre><code class="language-js">const axios = require(&quot;./axios.cjs&quot;).default; // 方案1
</code></pre>
<p>此时，把原先的axios依赖删了都行，pkg构建的时候还不会WARN</p>
<ul>
<li><strong>方案2</strong>：把axios.cjs作为资源脚本</li>
</ul>
<pre><code class="language-js">const axioscjs = path.join(__dirname,&quot;../node_modules/axios/dist/node/axios.cjs&quot;);
const axios = require(axioscjs).default;  // 方案2
</code></pre>
<p>pkg构建的虽然会WARN，但能正常运行即可</p>
<ul>
<li><strong>方案3</strong>：使用低版本的 axios</li>
</ul>
<pre><code class="language-console">npm uninstall axios &amp;&amp; npm i axios@0.27.2
</code></pre>
<p>版本低了，比较旧，可能存在不少潜在的问题，不太推荐使用</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_3/section_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../chapter_3/section_5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_3/section_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../chapter_3/section_5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
