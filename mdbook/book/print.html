<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>跟着例子学Express.js</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">模块化学习</li><li class="chapter-item expanded "><a href="chapter_1/intro.html"><strong aria-hidden="true">1.</strong> 本章简介</a></li><li class="chapter-item expanded "><a href="chapter_1/section_1.html"><strong aria-hidden="true">2.</strong> HelloWorld</a></li><li class="chapter-item expanded "><a href="chapter_1/section_2.html"><strong aria-hidden="true">3.</strong> 请求类型</a></li><li class="chapter-item expanded "><a href="chapter_1/section_3.html"><strong aria-hidden="true">4.</strong> 处理请求数据</a></li><li class="chapter-item expanded "><a href="chapter_1/section_4.html"><strong aria-hidden="true">5.</strong> 响应</a></li><li class="chapter-item expanded "><a href="chapter_1/section_5.html"><strong aria-hidden="true">6.</strong> Sql-knex增删改查</a></li><li class="chapter-item expanded "><a href="chapter_1/section_6.html"><strong aria-hidden="true">7.</strong> Sql-ORM增删改查</a></li><li class="chapter-item expanded "><a href="chapter_1/section_7.html"><strong aria-hidden="true">8.</strong> 路由控制</a></li><li class="chapter-item expanded "><a href="chapter_1/section_8.html"><strong aria-hidden="true">9.</strong> JWT基础鉴权</a></li><li class="chapter-item expanded "><a href="chapter_1/section_9.html"><strong aria-hidden="true">10.</strong> 全局错误处理</a></li><li class="chapter-item expanded "><a href="chapter_1/section_10.html"><strong aria-hidden="true">11.</strong> 中间件</a></li><li class="chapter-item expanded affix "><li class="part-title">架构整合</li><li class="chapter-item expanded "><a href="chapter_2/intro.html"><strong aria-hidden="true">12.</strong> 本章简介</a></li><li class="chapter-item expanded "><a href="chapter_2/section_1.html"><strong aria-hidden="true">13.</strong> express-cli</a></li><li class="chapter-item expanded "><a href="chapter_2/section_2.html"><strong aria-hidden="true">14.</strong> MVC层级架构</a></li><li class="chapter-item expanded "><a href="chapter_2/section_3.html"><strong aria-hidden="true">15.</strong> 分布式架构</a></li><li class="chapter-item expanded "><a href="chapter_2/section_4.html"><strong aria-hidden="true">16.</strong> 微服务架构</a></li><li class="chapter-item expanded affix "><li class="part-title">高级进阶</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">跟着例子学Express.js</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="跟着例子学expressjs"><a class="header" href="#跟着例子学expressjs">跟着例子学express.js</a></h1>
<p>撰写本书的起因，是我的一个朋友有学习node后端的意愿，加之node在我手里落灰已久，于是决定趁着这个机会好好梳理一下，在空闲之余谱一份还算简明的渐进式教程，希望能对各位朋友以及未来又淡忘了express的自己有所帮助.</p>
<p>express-demo，跟着例子学express，先按不同的功能分块学习express.js，从路由，接口，数据库，鉴权等等一块一块地进行分布式的基础学习，等有了较为完备的基础，根据一定的架构思想形成一个完整的express.js后端，最后再介绍一些可能用得到的进阶技巧.</p>
<h4 id="源码"><a class="header" href="#源码">源码</a></h4>
<p>仓库有着每一节教程中的完整源码，在阅读本书时，请务必配合源码食用，动手是最好的老师！</p>
<h4 id="进度"><a class="header" href="#进度">进度</a></h4>
<p>当前本书进度60%，敬请期待</p>
<h4 id="合作"><a class="header" href="#合作">合作</a></h4>
<p>如本书或者源码有任何的纰漏或者错误，欢迎指正，谢谢！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块化学习"><a class="header" href="#模块化学习">模块化学习</a></h1>
<p>本章将express分为不同的模块进行独立学习，主要分为以下几方面:</p>
<ul>
<li>处理请求</li>
<li>处理响应</li>
<li>路由/接口</li>
<li>数据库</li>
<li>中间件</li>
</ul>
<p>通常来说，建议按从前到后的顺序依次学习，有层层递进的关系。 当有了全面的了解之后，应当就初步具备了写基于 express.js 的完整项目(后端)的能力于水准。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>本节我们将创建并运行我们的第一个express.js项目，并使用最简单的请求响应</p>
<h2 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h2>
<ul>
<li>本书系统环境为 <strong>windows10 64Bit</strong></li>
<li>请事先在你的开发环境中安装 <strong>Node.js</strong>，本书使用的是 <strong>node v16.17.1</strong></li>
<li>推荐使用 <strong>VsCode</strong> 作为开发工具，有良好的代码提示功能</li>
<li>事先安装一个api调试工具，如 <strong>postman</strong>, <strong>apipost</strong>等</li>
</ul>
<h2 id="创建项目"><a class="header" href="#创建项目">创建项目</a></h2>
<ol>
<li>创建一个文件夹作为项目根目录</li>
<li>下载express依赖<br />
在根目录下执行<code>npm install express</code></li>
<li>下载js-text-chart依赖<br />
在根目录下执行<code>npm install js-text-chart</code>，这是一个用于输出字符画的js库，本书在每一个示例中都使用了该库充当starter</li>
<li>在根目录下新建一个入口文件，如<strong>index.js</strong></li>
<li>在入口文件中引入依赖</li>
</ol>
<pre><code class="language-js">const express = require('express');
const evchart = require('js-text-chart').evchart;
</code></pre>
<h2 id="创建服务器"><a class="header" href="#创建服务器">创建服务器</a></h2>
<ol>
<li>先创建一个express实例</li>
</ol>
<pre><code class="language-js">const app = express();
</code></pre>
<ol start="2">
<li>创建服务器</li>
</ol>
<p>让我们刚刚创建的app实例挂载到指定的端口，如8080</p>
<pre><code class="language-js">const server = app.listen(8080);
</code></pre>
<ol start="3">
<li>添加服务器运行后的回调函数</li>
</ol>
<p>是指在服务器成功运行后的一系列操作，常用于输出信息和初始化等，我在这里打印该项目的基本信息<br />
我使用的是内联箭头函数 &quot;()=&gt;{//...}&quot;，也可以替换为普通的&quot;function {//...}&quot;</p>
<pre><code class="language-js">const server = app.listen(8080, () =&gt; {
    let host = server.address().address;
    let port = server.address().port;

    let str = &quot;EXPRESS-DEMO&quot;;
    let mode = [ &quot;close&quot;, &quot;far&quot;, undefined ];
    let chart = evchart.convert(str, mode[0]);
    console.log(chart);

    console.log(&quot;Server is ready on http://%s:%s&quot;, host, port);
})
</code></pre>
<ol start="4">
<li>跨域策略</li>
</ol>
<p>默认情况下可能不允许不同域名下进行交互，我们对请求进行一些基本的设置，允许跨域和所有的请求方式请求头格式化，并设置请求头内容为json格式</p>
<pre><code class="language-js">app.all(&quot;*&quot;, function (req, res, next) {
    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;);
    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);
    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);
    next();
});
</code></pre>
<h2 id="第一个接口"><a class="header" href="#第一个接口">第一个接口</a></h2>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<p>前后端交互是在后端暴露的接口进行的，而不同的接口对于后端端口上不同的url路径。前端使用不同的方式（GET,POST...）请求指定的路径，当后端有定义监听某种方式下的某种路径接口时，获取请求携带的数据，对请求进行处理，并返回结果给前端 </p>
<h3 id="实践"><a class="header" href="#实践">实践</a></h3>
<p>接下来，我们将添加一个以服务器的根路径（GET）作为返回欢迎信息的接口</p>
<pre><code class="language-js">app.get('/', function (req, res) {
    res.send('Hello World!');
});
</code></pre>
<p>以上代码，app实例<strong>监听</strong> <strong>localhost:8080/</strong> 路径的<strong>GET</strong>请求，传入2个参数，第一个是请求，第二个是响应<br />
当接收到以GET方式访问该接口的请求时，通过在回调函数中执行<code>res.send</code>返回 Hello World!</p>
<h3 id="测试接口"><a class="header" href="#测试接口">测试接口</a></h3>
<p>使用接口测试工具，以GET的形式访问localhost:8080/试试吧！你将会得到一句 Hello World!</p>
<h2 id="第二个接口"><a class="header" href="#第二个接口">第二个接口</a></h2>
<p>第一个接口，我们只是单纯的访问了接口，没有传输任何数据，接下来我们将创建一个以传统的路径请求参数（如: url?id=1）携带数据的接口</p>
<h3 id="实践-1"><a class="header" href="#实践-1">实践</a></h3>
<p>定义一个GET形式，路径为 /get 的接口，传入2个参数请求和响应，我们在回调函数中通过<code>req.query</code>来获取路径上的所有请求参数，并将这些参数作为接口的返回值</p>
<pre><code class="language-js">app.get('/get', function (req, res) {
    let requestParams = req.query;
    res.send(requestParams);
});
</code></pre>
<h3 id="测试接口-1"><a class="header" href="#测试接口-1">测试接口</a></h3>
<p>使用接口测试工具，以GET的形式访问 localhost:8080/get?id=1&amp;name=evanp 试试吧！你将会得到这两个参数!</p>
<h2 id="下一节-请求类型"><a class="header" href="#下一节-请求类型">下一节-请求类型</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="请求类型"><a class="header" href="#请求类型">请求类型</a></h1>
<p>本节将介绍常见的http请求方式，并站在后端的角度初步感受它们的不同点</p>
<h2 id="各类http请求"><a class="header" href="#各类http请求">各类Http请求</a></h2>
<ul>
<li><strong>GET</strong><br />
意图是<strong>获取</strong>，不会对服务器上的数据产生影响，将要携带的数据放在<strong>URL</strong>上，通常不带请求体，带了也不一定兼容</li>
<li><strong>POST</strong><br />
意图是<strong>提交</strong>，通常用于修改和新增服务器上的数据，偏向<strong>新增</strong>，路径定位较模糊，要携带的数据通常放在<strong>请求体</strong>内</li>
<li><strong>PUT</strong><br />
类似POST，偏向<strong>更新</strong>，路径定位更明确，要携带的数据通常放在<strong>请求体</strong>内<br />
★ <strong>幂等性</strong>：连续PUT请求后，效果应当只有一次，而POST则会创建多个新资源，不过在REST风格下以及在后台有严格的检验情况下其实这些区别可以忽略<br />
★ <strong>缓存机制</strong>：由于PUT的幂等性，不存在缓存，而POST是缓存的，比如你在表单里用POST，不设置提交后清除，刷新页面它会将之前的数据再提交一遍</li>
<li><strong>DELETE</strong><br />
意图是删除，从服务器上删除某些数据</li>
<li><strong>HEAD</strong><br />
类似GET，但争对它的响应没有body，只有响应头，常用于判断资源是否存在、链接有效性等</li>
<li><strong>OPTIONS</strong><br />
意图是询问当前URL允许的请求方法等，常用于跨域请求前的预检和获取服务器的安全控制信息等</li>
<li><strong>TRACE</strong><br />
路径追踪，回显请求，常用于测试阶段</li>
<li><strong>PATCH</strong><br />
PUT的超类，指定资源的局部更新</li>
<li><strong>COPY</strong><br />
请求将页面拷贝到另一个URL，常用于Web资源的备份</li>
<li><strong>MOVE</strong><br />
请求将页面移动到另一个URL，常用于Web资源的搬迁</li>
<li><strong>LINK</strong><br />
请求与服务器建立链接</li>
<li><strong>UNLINK</strong><br />
断开与服务器的链接</li>
</ul>
<p>其中 GET, POST 最为广泛使用，同时可以使用PUT和DELETE让我们的接口的目的更具有指向性<br />
本书绝大部分接口都将采用类REST风格，即普遍的返回码200，数据格式为json</p>
<h2 id="express处理不同的请求"><a class="header" href="#express处理不同的请求">express处理不同的请求</a></h2>
<p>通过调用get,post,pu,delete...对应不同方法下的路由<br />
由于实际受不同的开发规范和业务环境影响，在这里只以GET和POST举例</p>
<h3 id="get请求"><a class="header" href="#get请求">get请求</a></h3>
<pre><code class="language-js">//省略了express项目的创建
class Item {
    constructor(name, value) {
      this.name = name;
      this.value = value;
    }
}

//get接口
app.get('/request', function (req, res) {
    let result = [];
    result.push(new Item(&quot;baseUrl&quot;,req.baseUrl));
    result.push(new Item(&quot;fresh&quot;,req.fresh));   //请求是否存活
    result.push(new Item(&quot;hostname&quot;,req.hostname)); //请求源域名
    result.push(new Item(&quot;ip&quot;,req.ip)); //请求源IP
    result.push(new Item(&quot;originalUrl&quot;,req.originalUrl));
    result.push(new Item(&quot;params&quot;,req.path));   //路径参数: /x/y/z/
    result.push(new Item(&quot;protocol&quot;,req.protocol)); //请求协议
    result.push(new Item(&quot;query&quot;,req.query));   //查询参数
    result.push(new Item(&quot;route&quot;,req.route));   //请求路由
    result.push(new Item(&quot;is:Content-Type&quot;,req.is('application/json')));

    res.send(result);
});
</code></pre>
<p>以上代码，定义了GET接口，并返回了关于请求的大部分信息</p>
<h3 id="测试接口-2"><a class="header" href="#测试接口-2">测试接口</a></h3>
<p>使用api调试工具，尝试用不同的携带数据方法以get形式访问该接口，比较不同的返回结果</p>
<h3 id="post请求"><a class="header" href="#post请求">post请求</a></h3>
<p>监听相同路径的post请求，开启json解析，一会我们调试时请求体采用最常用的json格式</p>
<pre><code class="language-js">//启用json解析
app.use(express.json({type: 'application/json'}));

app.post('/post', function (req, res) {
    let result = [];
    result.push(new Item(&quot;baseUrl&quot;,req.baseUrl));
    result.push(new Item(&quot;fresh&quot;,req.fresh));
    result.push(new Item(&quot;hostname&quot;,req.hostname));
    result.push(new Item(&quot;ip&quot;,req.ip));
    result.push(new Item(&quot;originalUrl&quot;,req.originalUrl));
    result.push(new Item(&quot;params&quot;,req.path));
    result.push(new Item(&quot;protocol&quot;,req.protocol));
    result.push(new Item(&quot;query&quot;,req.query));
    result.push(new Item(&quot;body&quot;,req.body));
    result.push(new Item(&quot;route&quot;,req.route));
    result.push(new Item(&quot;is:Content-Type&quot;,req.is('application/json')));

    res.send(result);
});
</code></pre>
<h3 id="测试接口-3"><a class="header" href="#测试接口-3">测试接口</a></h3>
<p>使用api调试工具，尝试用不同的携带数据方法以post形式访问该接口，比较不同的返回结果</p>
<h3 id="不限方法"><a class="header" href="#不限方法">不限方法</a></h3>
<p>如果你想让某个路由能以任意方法访问:</p>
<pre><code class="language-js">app.use('/any', function (req, res) {
    res.send('Bad World!');
});
</code></pre>
<p>尝试使用各种方法去访问 127.0.0.1:8080/any，都可以得到Bad World!</p>
<h2 id="下一节-处理请求数据"><a class="header" href="#下一节-处理请求数据">下一节-处理请求数据</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="处理请求数据"><a class="header" href="#处理请求数据">处理请求数据</a></h1>
<p>本节将具体介绍express后端处理请求源携带数据的一些方法和技巧</p>
<h2 id="动态路径"><a class="header" href="#动态路径">动态路径</a></h2>
<p>很多时候我们需要处理一些类似但有操作差别或不同对象的业务，我们可以监听一段基本路径，将其中某一个段或者某几段路径作为变量，在接口中根据不同的路径变量执行不同的业务操作，这是一种REST风格比较鲜明的动态接口设计策略</p>
<h3 id="实践-2"><a class="header" href="#实践-2">实践</a></h3>
<p>由于post也可以url传参，本节所有实例均采用post请求 </p>
<h4 id="第一个接口-1"><a class="header" href="#第一个接口-1">第一个接口</a></h4>
<p>这个接口以 /request/data/ 作为基路由，之后的kind变化的，在接口内部根据kind的值进行分支化处理。我指定了kind的3个值：PathVarible, RequestParam 和 body.<br />
所有的路径参数则可以由<code>req.params</code>（大概是个json对象）来获取，我要指定获取kind的值，就req.params.kind，而静态路径变量的值就等于它名字.</p>
<pre><code class="language-js">//忽略了express项目的创建和基本配置
class Item {
    constructor(name, value) {
      this.name = name;
      this.value = value;
    }
}
//启用json解析请求体
app.use(express.json({type: 'application/json'}));
app.post('/request/data/:kind', function (req, res) {
    let result = [];
    if (req.params.kind == 'PathVarible') {
        result.push(new Item(&quot;lesson&quot;,&quot;路径变量&quot;));
        result.push(new Item(&quot;info&quot;,&quot;在express中叫做params，路径上每个被双单斜杠'/'隔开的一个个词语就是路径参数，当你需要在同一个接口内动态响应不同的情景时，可以让某一处或多出的路径参数前面加上一个冒号，长得比较像vue中的动态绑定，动态路径在REST风格上被广泛运行，比如操作某个用户: 'user/:id =&gt; 'user/1&quot;))
    } else if (req.params.kind == 'RequestParam') {
        result.push(new Item(&quot;lesson&quot;,&quot;请求参数&quot;));
        result.push(new Item(&quot;info&quot;,&quot;在express中叫做query，和路径变量相比，前者更像是前端主动携带参数去访问特定的资源，而后者更像是后端要求必须携带的数据，前端被迫携带，反应在路径上形式一般是: '/stu?class=2&amp;sid=1&amp;name='evanp',在基本路径之后添上一个问号，然后在后面加上请求的参数，不同参数之间用'&amp;'符号隔开&quot;))
    } else if (req.params.kind == 'body') {
        result.push(new Item(&quot;lesson&quot;,&quot;请求体&quot;));
        result.push(new Item(&quot;info&quot;,&quot;路径变量和请求参数的数据都是透明的，这非常不注重隐私，因此更多时候前端应该将携带的数据放在请求体内进行传输。请求体的形式有很多，最常用的是表单和JSON，请在路径后新增一个路径变量，form-urlencode, multi-form-data或json导向不同的接口进行查看&quot;));
    } else {
        result.push(new Item(&quot;error&quot;,&quot;这个参数不认识&quot;));
    }
    res.send(result);
});
</code></pre>
<h4 id="接口测试"><a class="header" href="#接口测试">接口测试</a></h4>
<p>请使用接口调试工具，带上路径查询参数(query)，然后修改不同的kind为不同的值，去POST访问 localhost:8080/request/data/kind，看看它们的返回结果，注意kind前不要加冒号了，冒号是用来让express知道这段路径是可变的</p>
<h4 id="第二个接口-1"><a class="header" href="#第二个接口-1">第二个接口</a></h4>
<p>当第一个接口的某一个分支还可以有后续的操作时，可以再开一个接口以它作为基路由，往后新增动态路径，比如我现在要让body可以再导向不同的分支，就再开一个 /request/data/body/:kind 接口</p>
<pre><code class="language-js">app.post('/request/data/body/:kind', function (req, res) {
    let result = [];
    if (req.params.kind == 'json') {
        result.push(new Item(&quot;lesson&quot;,&quot;json请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
        result.push(new Item(&quot;info&quot;,&quot;express想解析json形式的body，必须先开启express.json: 'app.use(express.json)'，之后就可以用req.body来接收请求体了&quot;));
        result.push(new Item(&quot;trick&quot;,&quot;进阶技巧，读取请求体时可以用match模式匹配成自己想要的格式或命名，常用于实体注入及转化等&quot;));
    } else if (req.params.kind == 'form-urlencode') {
        result.push(new Item(&quot;lesson&quot;,&quot;form-urlencode请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
    } else if (req.params.kind == 'multi-form-data') {
        result.push(new Item(&quot;lesson&quot;,&quot;multi-form-data请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
    } else {
        result.push(new Item(&quot;error&quot;,&quot;这个参数不认识&quot;));
    }
    res.send(result);
});
</code></pre>
<h4 id="接口测试-1"><a class="header" href="#接口测试-1">接口测试</a></h4>
<p>请使用接口调试工具，带上JSON请求体，去POST访问 localhost:8080/request/data/body/kind，修改不同的kind，看看它们的返回结果</p>
<h2 id="获取路径参数"><a class="header" href="#获取路径参数">获取路径参数</a></h2>
<h3 id="基础"><a class="header" href="#基础">基础</a></h3>
<p>路径参数是指 '/url?id=1&amp;name=evanp' 这种url中的id和name，是明文的不具有隐私性<br />
可以通过 <code>req.query</code>获取</p>
<pre><code class="language-js">app.post('/request/data/query/info',checkQuery, (req, res)=&gt; {
    res.send(req.query);
});
</code></pre>
<p>尝试用接口调试工具访问 localhost:8080/request/data/query/info，并携带上任意的query参数</p>
<h3 id="query预检"><a class="header" href="#query预检">Query预检</a></h3>
<p>在实际场景中，每个接口会指定需要哪些名字的query参数，假设上面的接口需要id和name，则需要保证前端确实给接口传递了这两个query参数，express没有像springboot那样在入参的时候就可以规定检验，我们必须亲自对传过来的query进行检验。而这部分检验的操作不建议包含在我们接口的主体回调函数内，而应作为一个<strong>中间件</strong>，在回调之前就完成检验:</p>
<p>定义一个检查query的函数，判断是否有id和name，是的话继续，不是的话直接返回错误信息</p>
<pre><code class="language-js">function checkQuery(req,res) {
    if (req.query.id == undefined ||
        req.query.id == null ||
        req.query.name == undefined ||
        req.query.name == null){
        res.send({&quot;msg&quot;: &quot;query不齐全&quot;});
    }
}
</code></pre>
<p>在接口入参时引入该中间件函数</p>
<pre><code class="language-js">app.post('/request/data/query/info',checkQuery, (req, res)=&gt; {
    res.send(req.query);
});
</code></pre>
<p>尝试用接口调试工具访问 localhost:8080/request/data/query/info，并比较不携带id,name和携带了id,name的返回结果</p>
<h2 id="获取请求体"><a class="header" href="#获取请求体">获取请求体</a></h2>
<h3 id="json请求体"><a class="header" href="#json请求体">JSON请求体</a></h3>
<p>引入以下代码一次即可</p>
<pre><code class="language-js">app.use(express.json({type: 'application/json'}));
</code></pre>
<h3 id="表单x-www-form-urlencoded"><a class="header" href="#表单x-www-form-urlencoded">表单（x-www-form-urlencoded）</a></h3>
<p><strong>x-www-form-urlencode</strong>将表单数据编码为URL形式的字符串</p>
<p>引入以下代码一次即可</p>
<pre><code class="language-js">app.use(express.urlencoded({extended: true}));
</code></pre>
<p>关于extended参数，是指将（URL编码字符串形式的）表单数据解析为简单对象还是深度嵌套对象.<br />
什么意思呢？就比如当extended=false时，表单里是这么传数据的: 
其中，有两个相同的键名: 比如传了2个x
解析后该字段的指将是所有它们的值的数组集合：<code>x=1&amp;x=2</code> -&gt; <code>{'x': ['1','2']}</code>，即便2个x都为1，也是数组: <code>{'x': ['1','1']}</code><br />
其中，又有的键名是以对象属性格式传递的，比如下图的user[uname]:
<img src="https://evan-oss-bucket1.oss-cn-hangzhou.aliyuncs.com/express-demo/x-form.png" alt="表单传嵌套对象" />
假如我们在api调试工具访问之前那个body/form-urlencode接口，同时以表单方式传输了这两种情况的数据，将得到这样的返回结果: </p>
<pre><code class="language-json">[
    {
        &quot;name&quot;: &quot;lesson&quot;,
        &quot;value&quot;: &quot;form-urlencode请求体&quot;
    },
    {
        &quot;name&quot;: &quot;body&quot;,
        &quot;value&quot;: {
            &quot;user[uname]&quot;: &quot;evanp&quot;,
            &quot;user[passwd]&quot;: &quot;iloveu&quot;,
            &quot;x&quot;: [
                &quot;1&quot;,
                &quot;2&quot;
            ]
        }
    }
]
</code></pre>
<p>当extended=true时，则是:</p>
<pre><code class="language-json">[
    {
        &quot;name&quot;: &quot;lesson&quot;,
        &quot;value&quot;: &quot;form-urlencode请求体&quot;
    },
    {
        &quot;name&quot;: &quot;body&quot;,
        &quot;value&quot;: {
            &quot;user&quot;: {
                &quot;uname&quot;: &quot;evanp&quot;,
                &quot;passwd&quot;: &quot;iloveu&quot;
            },
            &quot;x&quot;: [
                &quot;1&quot;,
                &quot;2&quot;
            ]
        }
    }
]
</code></pre>
<p>通过对比我们可以发现，<code>extended=false</code>时express比较憨，不会智能解析user到一个对象上去；智能解析的用处，我想大概是省的我们手动一条条注入属性到对象上去了</p>
<h4 id="表单验证"><a class="header" href="#表单验证">表单验证</a></h4>
<p>对于请求参数我们有验证的需求，同样的，表单验证自然也会有，甚至可能需求性更高，因为需要考虑到安全问题<br />
如果没有什么特殊要求，可以自己写一个中间件函数来检查表单，如果有比较高级的需求，可以借助线程的js库，如<strong>express-validator</strong>等</p>
<h2 id="表单multi-form-data"><a class="header" href="#表单multi-form-data">表单（multi-form-data）</a></h2>
<p>这个是可以一边传字符串，还可以传文件的表单，其实就是基础表单的一个升级版</p>
<p>需要事先安装<strong>multer</strong>依赖: <code>npm install multer</code><br />
引入依赖中间件: </p>
<pre><code class="language-js">const multer = require('multer');
const uploads = multer();
</code></pre>
<p>在需要接收文件的接口引入该中间件uploads:</p>
<pre><code class="language-js">app.post('/request/data/body/:kind', uploads.any(), function (req, res) 
</code></pre>
<p>在主体回调函数中通过<code>req.files</code>可以获取到所有的文件:</p>
<pre><code class="language-js">console.log(req.files); //写在multi-form-data分支下，方便区分
</code></pre>
<h3 id="测试接口-4"><a class="header" href="#测试接口-4">测试接口</a></h3>
<p>使用api调试工具的复合表单携带文件发送请求到 body/multi-form-data 接口，查看我们的控制台:</p>
<pre><code class="language-bash">[
  {
    fieldname: 'file',
    originalname: 'C.jpeg',
    encoding: '7bit',
    mimetype: 'image/jpeg',
    buffer: &lt;Buffer ff d8 ff e0 00 10 4a 46 49 46 00 01 01 01 00 48 00 48 00 00 ff db 00 43 00 0a 07 08 09 08 06 0a 09 08 09 0c 0b 0a 0c 0f 1a 11 0f 0e 0e 0f 1f 16 18 13 ... 9752 more bytes&gt;,
    size: 9802
  }
]
</code></pre>
<p>是的，我刚刚传了一张名为 C.jpeg 的图片到服务器</p>
<h2 id="下一节-响应"><a class="header" href="#下一节-响应">下一节-响应</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="响应"><a class="header" href="#响应">响应</a></h1>
<p>上一节讲完了请求，这一节我们就来讲一下响应吧！<br />
本节作为初级内容，将罗列比较常用的响应方法以及其简单的使用形态</p>
<h2 id="准备工作-1"><a class="header" href="#准备工作-1">准备工作</a></h2>
<p>拷贝第一节Hello World项目</p>
<h2 id="status"><a class="header" href="#status">status</a></h2>
<p><strong>res.statue(status code)</strong>，这是很实用的一个方法，设置响应体的Http状态码，虽然REST-Apid的风格的是统一200，但在express.js中，有些情景下你必须设置status code为某个值</p>
<pre><code class="language-javascript">res.status(404);
</code></pre>
<h2 id="send"><a class="header" href="#send">send</a></h2>
<p><strong>res.send(content)</strong>，将任意类型的内容放在响应体内返回给请求源</p>
<pre><code class="language-javascript">app.get('/', function (req, res) {
    res.send('Hello World!');
});
</code></pre>
<p>也可以接在status后面:</p>
<pre><code class="language-javascript">res.status(200).send(&lt;p&gt;hello world&lt;/p&gt;);
</code></pre>
<h2 id="end"><a class="header" href="#end">end</a></h2>
<p><strong>res.end()</strong>，用于快速结束不需要返回数据的场景下的响应，不过end()也可以传送数据，但性能消耗较大，不建议用res.end传数据和信息</p>
<pre><code class="language-javascript">//END
app.get('/end',(req,res)=&gt;{
    res.status(404).end();
})
</code></pre>
<h2 id="json"><a class="header" href="#json">json</a></h2>
<p><strong>res.json(content)</strong>，以json格式的请求体返回给请求源，可能会收到跨域保护的限制，因此往往需要我们顶上设置的一串Allow</p>
<pre><code class="language-javascript">//json - 同源限制
app.get('/json',(req,res)=&gt;{
    let resp = {
        code: 200,
        msg: &quot;json&quot;,
        toPrint: function(){
            console.log(`resp[code: ${this.code}, msg: ${this.msg}]`);
        }
    }
    res.jsonp(resp);
})
</code></pre>
<h2 id="jsonp"><a class="header" href="#jsonp">jsonp</a></h2>
<p><strong>res.jsonp(content)</strong>，jsonp是开发者们自研的一种不正统的数据格式，和json基本一样，但不太会被跨域保护给拦着</p>
<pre><code class="language-javascript">//jsonp - 更容易的解决跨域
app.get('/jsonp',(req,res)=&gt;{
    let resp = {
        code: 200,
        msg: &quot;jsonp&quot;,
        toPrint: function(){
            console.log(`resp[code: ${this.code}, msg: ${this.msg}]`);
        }
    }
    res.jsonp(resp);
})
</code></pre>
<h2 id="sendfile"><a class="header" href="#sendfile">sendFile</a></h2>
<p><strong>res.sendFile(path,options)</strong>，静态传输文件，不能直接使用相对路径</p>
<pre><code class="language-js">//sendfile，传输文件
app.get('/sendfile',(req,res)=&gt;{
    //只能是静态路径，需要相对路径的话有很多方法，以下是其中一个
    res.sendFile(&quot;hello.txt&quot;, {root: __dirname});
})
</code></pre>
<h2 id="download"><a class="header" href="#download">download</a></h2>
<p><strong>res.download(path)</strong>，下载传输文件，这个可以直接使用相对路径</p>
<pre><code class="language-js">//download，下载文件
app.get('/download',(req,res)=&gt;{
    //可以直接相对路径
    res.download(&quot;./hello.txt&quot;);
})
</code></pre>
<h2 id="sendstatus"><a class="header" href="#sendstatus">sendStatus</a></h2>
<p><strong>res.sendStatus(status code)</strong>，设置响应码，并返回信息为该状态码预设好的文本，比如res.sendStatus(404)，则响应的状态码是s404，返回的信息是'not Found'</p>
<pre><code class="language-js">//sendstatus
app.get('/sendstatus',(req,res)=&gt;{
    //预先写好的httpStatus组合，改一下试试，如果你输入的status码不存在，msg将变成这个码的数字
    res.sendStatus(404);
})
</code></pre>
<h2 id="location"><a class="header" href="#location">location</a></h2>
<p><strong>res.location(route)</strong>，REST接口之间的转发，必须设置status为300~309之间的数字，才能成功转发</p>
<pre><code class="language-js">//location
app.get('/location/1',(req,res)=&gt;{
    //转发到最早的helloworld路由去
    res.location('/').status(302).send();
})

//location/2
app.get('/location/2',(req,res)=&gt;{
    //转达到下面定义的这个接口
    res.location('/location/index').status(302).send();
})

app.get('/location/index',(req,res)=&gt;{
    res.send(&quot;welcome to learn express.js by demos&quot;);
})
</code></pre>
<h2 id="redirect"><a class="header" href="#redirect">redirect</a></h2>
<p><strong>res.redirect()</strong>，路由重定向，这个比较特殊，我们放到路由控制那一节再讲</p>
<h2 id="下一节-sql-knex增删改查"><a class="header" href="#下一节-sql-knex增删改查">下一节-Sql-knex增删改查</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql增删改查"><a class="header" href="#sql增删改查">Sql增删改查</a></h1>
<p>本节使用knex作为sql框架，以sqlite数据库为例</p>
<h2 id="准备工作-2"><a class="header" href="#准备工作-2">准备工作</a></h2>
<p>knex是一个运行在各自数据库Driver上的框架，因此需要安装相应的js版数据库Driver，如: PostgreSQL -&gt; pg, mysql/mariadb -&gt; mysql, sqlite -&gt; sqlite3...</p>
<ul>
<li>安装sqlite3依赖 <code>npm install sqlite3</code></li>
<li>安装knex依赖 <code>npm install knex</code></li>
<li>引入依赖</li>
</ul>
<pre><code class="language-js">const app = express();
const knex = require('knex');
</code></pre>
<ul>
<li>建议安装一款合适的数据库界面工具，笔者使用的是Beekeeper Studio.</li>
</ul>
<h2 id="创建项目-1"><a class="header" href="#创建项目-1">创建项目</a></h2>
<p>拷贝第一节HelloWorld的项目</p>
<h2 id="创建sqlite连接"><a class="header" href="#创建sqlite连接">创建sqlite连接</a></h2>
<p>指明client为sqlite3（刚刚安装的sqlite3依赖），并指明要操作的sqlite数据库路径</p>
<pre><code>const sqlite = knex({
    client: 'sqlite3',
    connection: {
      filename: './data.db',
    },
});
</code></pre>
<p>创建了一个连接实例后，会自动创建一个连接池，因此初始化数据库只会发生一次</p>
<h3 id="连接配置"><a class="header" href="#连接配置">连接配置</a></h3>
<p>sqlite3默认的是单连接，如果你希望连接池有更多的连接，创建时带上pool:</p>
<pre><code class="language-js">const sqlite = knex({
    client: 'sqlite3',
    connection: {
      filename: './data.db',
    },
    pool: { min: 0, max: 7 }
});
</code></pre>
<h4 id="创建连接池的回调"><a class="header" href="#创建连接池的回调">创建连接池的回调</a></h4>
<p>用于检查连接池是否正常，通常不需要这步</p>
<pre><code>pool: {
    afterCreate: function (conn, done) {//...}
}
</code></pre>
<h4 id="acquireconnectiontimeout"><a class="header" href="#acquireconnectiontimeout">acquireConnectionTimeout</a></h4>
<p>连接超时时间</p>
<h4 id="日志"><a class="header" href="#日志">日志</a></h4>
<p>knex内置了打印警告、错误、弃用和调试信息的日志函数，如果你希望自定义日志操作，可以在log项里重写它们</p>
<pre><code class="language-JS">log: {
    warn(message) {
    },
    error(message) {
    },
    deprecate(message) {
    },
    debug(message) {
    }
}
</code></pre>
<h2 id="数据表"><a class="header" href="#数据表">数据表</a></h2>
<h3 id="建表"><a class="header" href="#建表">建表</a></h3>
<p>语法: <code>sqlite.schema.createTable(表名, table=&gt;{表结构})</code></p>
<p>添加一个PUT接口，监听 127.0.0.1:8080/db/:tbname<br />
根据我们想创建的表名尝试创建一个表，注意: sql执行是异步的，为了得到结果，建议使用 <strong>async/await</strong> 语法糖（当然你就是喜欢地狱回调也不是不行）</p>
<pre><code class="language-js">app.put('/db/:tbname', async function (req, res) {
    let resultSet = null;
    try {
        // Create a table
        resultSet = await sqlite.schema
          .createTable(req.params.tbname, table =&gt; {
            table.increments('id');
            table.string('uname');
            table.string('passwd');
          })
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>瞅瞅控制台:</p>
<pre><code class="language-bash">sqlite does not support inserting default values. Set the `useNullAsDefault` flag to hide this warning. (see docs https://knexjs.org/guide/query-builder.html#insert).
</code></pre>
<p>嗯？sqlite不支持default？不用管他，去看数据库，反正成功创建了user表，你要是加了<code>useNullAsDefault</code>这个flag，反而会告诉你<code> not supported by node-sqlite3</code></p>
<pre><code class="language-js">const sqlite = knex({
    client: 'sqlite3',
    connection: {
      filename: './data.db',
    },
});
</code></pre>
<h3 id="删表"><a class="header" href="#删表">删表</a></h3>
<p>语法: <code>sqlite.schema.deleteTable(表名)</code></p>
<pre><code class="language-js">app.delete('/db/:tbname', async function (req, res) {
    try {
        // Delete a table
        await sqlite.schema.dropTable(req.params.tbname);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
    };
    res.json(null);
});

</code></pre>
<h2 id="表记录crud"><a class="header" href="#表记录crud">表记录crud</a></h2>
<h3 id="增"><a class="header" href="#增">增</a></h3>
<p>往user表里面插入一条新的记录</p>
<pre><code class="language-js">app.use(express.json({type: 'application/json'}));
app.put('/db/:tbname/record', async function (req, res) {
    /*前端请求体格式:
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;iloveu&quot;
    }
    */
   let resultSet = null;
    try {
        // Insert a record
        resultSet = await sqlite(req.params.tbname).insert(req.body);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具PUT 127.0.0.1:8080/db/user/record，携带相应的请求体，将会得到<code>[1]</code>，这是影响的记录数，1代表成功了</p>
<h3 id="查"><a class="header" href="#查">查</a></h3>
<p>从user表里查询uname=我们刚刚插入的记录</p>
<pre><code class="language-js">app.get('/db/:tbname/record', async function (req, res) {
    //前端携带query: uname=evanp
   let resultSet = null;
    try {
        // select a record where uname=xxx
        resultSet = await sqlite(req.params.tbname).select('*').where('uname',req.query.uname);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具GET 127.0.0.1:8080/db/user/record?uname=evanp，将会得到:</p>
<pre><code class="language-json">[
    {
        &quot;id&quot;: 1,
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;iloveu&quot;
    }
]
</code></pre>
<h3 id="改"><a class="header" href="#改">改</a></h3>
<p>接下来我们修改uname=evanp这条记录的passwd为123456</p>
<pre><code class="language-js">app.post('/db/:tbname/record', async function (req, res) {
    //前端携带query: uname=evanp
    /*前端请求体格式:
    {
        &quot;passwd&quot;: &quot;123456&quot;
    }
    */
   let resultSet = null;
    try {
        // select a record where uname=xxx
        resultSet = await sqlite(req.params.tbname).update(req.body).where('uname',req.query.uname);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具POST 127.0.0.1:8080/db/user/record?uname=evanp，并携带相应请求体，将会得到: [1]，这代表影响记录1条，成功了</p>
<h3 id="删"><a class="header" href="#删">删</a></h3>
<p>接下来我们删除uname=evanp且passwd=123456的这条记录</p>
<pre><code class="language-js">app.delete('/db/:tbname/record', async function (req, res) {
    /*前端请求体格式:
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;123456&quot;
    }
    */
   let resultSet = null;
    try {
        // select a record where uname=xxx
        resultSet = await sqlite(req.params.tbname).del().where(req.body);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具DELETE 127.0.0.1:8080/db/user/record，并携带相应请求体，将会得到: [1]，这代表影响记录1条，成功了</p>
<h2 id="原生sql"><a class="header" href="#原生sql">原生sql</a></h2>
<p>当然了，如果你需要直接使用sql语句，也是可以的，调用<code>raw(sqlStr)</code>即可，既可以作为某一段sql的绑定，也可以直接当作整句sql</p>
<p>格式: <code>knex.raw(sql, [bindings]</code></p>
<pre><code class="language-json">sqlite.raw(&quot;select * from user&quot;,[1]).then((resp)=&gt;{//..})
</code></pre>
<p>在这里不做介绍</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>以上给出了使用knex实现增删改查的基本操作，这些方法并不是唯一的，在实际开发中往往要应对更复杂的场景，基础crud也是远远不够的<br />
关于knex的更多拓展使用方法，请移步knex官方文档<a href="https://knexjs.org/guide/">https://knexjs.org/guide/</a></p>
<h2 id="下一节-sql-orm增删改查"><a class="header" href="#下一节-sql-orm增删改查">下一节-Sql-ORM增删改查</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-orm增删改查"><a class="header" href="#sql-orm增删改查">Sql-ORM增删改查</a></h1>
<p>ORM框架: 对象关系映射，面对对象sql<br />
本节使用sequelize作为orm-sql框架，数据库为sqlite</p>
<h2 id="准备工作-3"><a class="header" href="#准备工作-3">准备工作</a></h2>
<p>同样的，需要安装相应的js版数据库Driver，如: PostgreSQL -&gt; pg, mysql/mariadb -&gt; mysql, sqlite -&gt; sqlite3...</p>
<ul>
<li>安装sqlite3依赖 <code>npm install sqlite3</code></li>
<li>安装sequelize依赖 <code>npm install sequelize</code></li>
<li>引入依赖</li>
</ul>
<pre><code class="language-js">const app = express();
const { Sequelize } = require('sequelize');
</code></pre>
<ul>
<li>建议安装一款合适的数据库界面工具，笔者使用的是Beekeeper Studio.</li>
</ul>
<h2 id="创建项目-2"><a class="header" href="#创建项目-2">创建项目</a></h2>
<p>拷贝第一节HelloWorld的项目</p>
<h2 id="创建sqlite连接-1"><a class="header" href="#创建sqlite连接-1">创建sqlite连接</a></h2>
<p>指定方言为sqlite，持久化路径为本目录下的data.db</p>
<pre><code class="language-js">const sqlite = new Sequelize({
    dialect: 'sqlite',
    storage: './data.db'
})
</code></pre>
<h2 id="定义表模型"><a class="header" href="#定义表模型">定义表模型</a></h2>
<p>sequelize主打一个面对对象sql，因此我们要建立一个对应数据表的类<br />
就和上一节一样，弄一张一模一样的user表吧:</p>
<ul>
<li>引入DataTypes</li>
</ul>
<pre><code>const { Sequelize,DataTypes } = require('sequelize');
</code></pre>
<ul>
<li>定义User对象</li>
</ul>
<p><code>Model.init(schema,options)</code></p>
<pre><code class="language-js">const User = sqlite.define('User', {
    id: {
        primaryKey: true,
        type: DataTypes.INTEGER,
        allowNull: false,
        autoIncrement: true
    },
    // 在这里定义模型属性
    uname: {
      type: DataTypes.STRING,
      allowNull: true
    },
    passwd: {
      type: DataTypes.STRING
      // allowNull 默认为 true
    }
  }, {
    // 直接指定表名，不指定的话sequelize将默认以模型的复数形式作为表名
    tableName: 'user'
});
</code></pre>
<p>还有另一种方法，效果是一样的，看个人喜好使用:</p>
<ul>
<li>额外引入Model</li>
</ul>
<pre><code class="language-js">const { Sequelize,DataTypes,Model } = require('sequelize');
</code></pre>
<ul>
<li>初始化User类</li>
</ul>
<p><code>Model.init(schema,options)</code></p>
<pre><code class="language-js">User继承Model类
class User extends Model {};
User.init(
    {
        id: {
            primaryKey: true,
            type: DataTypes.INTEGER,
            allowNull: false,
            autoIncrement: true
        },
        // 在这里定义模型属性
        uname: {
            type: DataTypes.STRING,
            allowNull: true,
        },
        passwd: {
            type: DataTypes.STRING，
            defaultValue: '123456', //默认值
            //allowNull 默认为 true
        }
    }, 
    {
        // 这是其他模型参数
        sqlite, // 我们需要传递连接实例
        modelName: 'User1', // 我们需要选择模型名称,
        // 直接指定表名
        tableName: 'user',
    }
);
</code></pre>
<h2 id="模型同步"><a class="header" href="#模型同步">模型同步</a></h2>
<p><code>Model.sync</code>: 底层执行的是 create table if not exist</p>
<ul>
<li>如果数据库中不存在对应的表，将根据模型直接创建表；若存在，不操作<br />
<code>Model.sync({force: true})</code>: 底层是先 drop if 然后 create</li>
<li>如果表已存在，将删除再根据模型创建表<br />
<code>Model.sync({alter: true})</code>: </li>
<li>如果表已存在，将修改表结构使之与模型匹配</li>
</ul>
<p>花里胡哨的，总之就是保证数据库中有和该模型对应的表</p>
<h2 id="创建user表"><a class="header" href="#创建user表">创建user表</a></h2>
<p>我们使用<code>User.sync()</code>创建一张user表</p>
<pre><code class="language-js">app.put('/db/user', async function (req, res) {
    let what = await User.sync();
    res.json(what);
});
</code></pre>
<p>使用api调试工具PUT 127.0.0.1:8080/db/user，将会得到1，注意只要能成功映射到到数据表都是1</p>
<p>用Beekeeper查看我们的user表，你会发现和我们定义的模型有点不一样：多了2个字段——createdAt和updatedAt，即创建时间和修改时间<br />
sequelize会自动管理这两个字段，注意当你使用了其他的sql工具修改表，这两个字段不会自动更新</p>
<p>如果你不想要这两个值，或者想换个名字，可以在定义模型时往options添加这些设置:</p>
<pre><code class="language-js">// 禁止createdAt和updatedAt
timestamps: false,
// 只禁止createdAt
createdAt: false,
// 给updatedAt换个名字
updatedAt: 'updateTime'
</code></pre>
<h2 id="删除user表"><a class="header" href="#删除user表">删除user表</a></h2>
<p>drop()方法，底层是 drop if，既可以作用于模型，也可作用于数据库:</p>
<pre><code class="language-js">sqlite.drop();  //这将删除当前data.db下所有的表
</code></pre>
<p>我们使用<code>User.drop()</code>来删除user表</p>
<pre><code class="language-js">app.delete('/db/user', async function (req, res) {
    let what = await User.drop();
    res.json(what);
});
</code></pre>
<p>使用api调试工具PUT 127.0.0.1:8080/db/user，将会得到1，注意即使表已经没了，也是1</p>
<h2 id="数据表crud"><a class="header" href="#数据表crud">数据表crud</a></h2>
<h3 id="增-1"><a class="header" href="#增-1">增</a></h3>
<p>在操作表记录前，我们先通过模型(<code>Model.build</code>)创建一个实例，然后调用<code>save()</code>将这个实例插入到表中<br />
当然，如果你从前端拿来的数据不需要进行处理和转化就能拿来用，也可以直接用<code>Model.create</code>插入记录</p>
<pre><code class="language-js">app.use(express.json({type: 'application/json'}));
app.put('/db/user/record', async function (req, res) {
    /**前端请求体
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;iloveu&quot;
    }
    */
    try {
        let user = User.build(req.body);
        let what = await user.save();
        // let what = await User.create(req.body);
        res.json(what);
    }catch(e){
        res.json(e);
    }
});
</code></pre>
<p>使用api调试工具PUT 127.0.0.1:8080/db/user/record，携带相应的请求体，将会得到:</p>
<pre><code class="language-json">{
    &quot;id&quot;: 1,
    &quot;uname&quot;: &quot;evanp&quot;,
    &quot;passwd&quot;: &quot;iloveu&quot;,
    &quot;updatedAt&quot;: &quot;2023-03-19T08:03:37.964Z&quot;,
    &quot;createdAt&quot;: &quot;2023-03-19T08:03:37.964Z&quot;
}

</code></pre>
<p>是的，添加记录成功后它会顺便把整条记录查出来作为返回结果</p>
<p>Ok，那么现在user表里已经有了id=1的一条记录了，让我们试一下创建相同id的记录会怎么样...<br />
服务器直接挂了，我们可不希望这样，这意味着有任何不妥的sql都可能导致服务器崩溃，那怎么办呢？</p>
<p>有的朋友可能记起来了，在上一节中，使用了try-catch语法糖包裹sql操作，这是一种不错的方法</p>
<h3 id="查-1"><a class="header" href="#查-1">查</a></h3>
<p>sequelize模型内置了一些方法使得我们可以基于模型直接查询</p>
<ul>
<li>findAll 查找全部，底层是<code>select * from ...</code></li>
<li>findOne 查找一个，底层是<code>select * from ... LIMIT 1</code></li>
<li>findByPk 根据主键查找</li>
<li>findAndCountAll 查找并返回符合的总条数，常用于分页</li>
<li>findOrCreate 找不到就创建</li>
</ul>
<p>这些方法都可以添加options参数设置WHERE,LIMIT等限制条件<br />
我们使用findOne来查询evanp和用户名和密码都对的上的一条记录:</p>
<pre><code class="language-js">//我为了方便直接url传参了，实际上为了隐私，至少应该放在请求体内
app.get('/db/user/record', async function (req, res) {
    let evanp = await User.findOne({where: req.query});
    res.json(evanp);
});
</code></pre>
<p>如果你只需要查询其中某些字段，就在options中设置attributes:</p>
<pre><code class="language-js">User.findAll({
    attributes: ['id','uname']
});
</code></pre>
<p>如果想给字段取别名，就比如像这样给id取名uid:</p>
<pre><code class="language-js">User.findAll({
    attributes: [['id','uid'],'uname']
});
</code></pre>
<h2 id="改-1"><a class="header" href="#改-1">改</a></h2>
<p><code>Model.update(修改项,限制)</code></p>
<pre><code class="language-js">app.post('/db/user/record', async function (req, res) {
    /*请求体
    {
        &quot;set&quot;:{
            &quot;passwd&quot;: &quot;123456&quot;
        },
        &quot;where&quot;: {
            &quot;uname&quot;: &quot;evanp&quot;,
            &quot;passwd&quot;: &quot;iloveu&quot;
        }
    }
    */
    let what = await User.update(req.body.set,{where: req.body.where})
    res.json(what);
});
</code></pre>
<p>使用api工具进行调试，修改成功将返回1，修改失败将返回0(找不到/改不了)</p>
<h2 id="删-1"><a class="header" href="#删-1">删</a></h2>
<p><code>Model.destroy(限制)</code></p>
<pre><code class="language-js">app.delete('/db/user/record', async function (req, res) {
    /*请求体
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;123456&quot;
    }
    */
    let what = await User.destroy({where: req.body})
    res.json(what);
});
</code></pre>
<p>使用api工具进行调试，删除成功将返回1，删除失败将返回0(找不到/删不了)</p>
<h2 id="原生sql-1"><a class="header" href="#原生sql-1">原生Sql</a></h2>
<p>当然了，如果你需要直接使用sql语句，也是可以的，<code>连接实例.query(sqlStr)</code>即可<br />
通常，返回结果包含2个值，一个是结果数组，一个是相关信息</p>
<pre><code class="language-js">app.post('/db/user/record/freely', async function (req, res) {
    /*json请求体
    {
        &quot;sql&quot;: &quot;xxx&quot;
    }
    */
    let what = null;
    try {
        what = await sqlite.query(req.body.sql);
    } catch (e) {
        what = e;
    }
    res.json(what);
});
</code></pre>
<p>执行insert前要注意，如果这张表是经过sequelize同步的，也许会有那两个时间字段的，别忘了</p>
<p>本节的例子仅仅为了演示在express.js中如何运用sequelize操作数据库，关于sequelize的更多拓展和高级使用方法，请移步sequelize官方文档<a href="https://www.sequelize.cn/">https://www.sequelize.cn/</a></p>
<h2 id="下一节-路由控制"><a class="header" href="#下一节-路由控制">下一节-路由控制</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="路由控制"><a class="header" href="#路由控制">路由控制</a></h1>
<h2 id="准备工作-4"><a class="header" href="#准备工作-4">准备工作</a></h2>
<p>拷贝第一节HelloWorld项目</p>
<h2 id="动态路由"><a class="header" href="#动态路由">动态路由</a></h2>
<p>这个最初我们就接触到了，路径中某一段前面加冒号</p>
<pre><code class="language-js">//路径变量-动态路由
app.get('/:var',(req, res)=&gt;{
    res.send(req.params.var);
});
</code></pre>
<h2 id="路由匹配"><a class="header" href="#路由匹配">路由匹配</a></h2>
<p>利用通配符 * 匹配符合的所有路由</p>
<ul>
<li>全通配</li>
</ul>
<p><strong>定义时</strong>，以 * 结尾，或者 * 之后除了斜杠没有其他字符，匹配*之后所有的路由</p>
<pre><code class="language-js">//全部匹配，囊括了match之下的所有路由，即便前端请求路径时在后面再来几段，也会被当作一个字符串 /x/1/6 -&gt; '/x/1/6'
//慎用，必须确保其他独立的路由不会被覆盖了
app.get('/matchall/*',(req, res)=&gt;{
    let what = {
        params: req.params,
        theVar: req.params['0']
    }
    res.send(what);
});
</code></pre>
<p>前端发来请求时，如何有2个定义的接口都能匹配到，优先匹配先定义的</p>
<pre><code class="language-js">//不起效
app.get('/matchall/w/xf',(req, res)=&gt;{
    res.send(&quot;there is w.xf&quot;);
});
</code></pre>
<ul>
<li>局部通配</li>
</ul>
<p>在两个字符之间(斜杠不算，除非你转义过了)使用 *，匹配这两个字符中间夹任何一段字符串的路由:<br />
xAy,xBy,xvenapy...</p>
<pre><code class="language-js">//xy中间随便夹
app.get('/match/x*y', function (req, res) {
    res.send('xy肉夹馍')
})
</code></pre>
<pre><code class="language-js">//除非通配符后面有除了斜杠以外的字符，不然全部被盖
app.get('/match/w*/x', function (req, res) {
    res.send('除非通配符后面有除了斜杠以外的字符，不然全部被盖')
})
</code></pre>
<ul>
<li>动态字符(串)</li>
</ul>
<p>问号前的字符可有可无，gback,goback</p>
<pre><code class="language-js">//问号前面这个字符可有可无
app.get('/match/go?back',(req, res)=&gt;{
    res.send(&quot;问号前面这个字符可有可无&quot;);
});
</code></pre>
<p>问号前被括号括住的字符串可有可无，xback,xgoback</p>
<pre><code class="language-js">app.get('/match/x(go)?back',(req, res)=&gt;{
    res.send(&quot;问号前面这个字符串可有可无，注意被括住的字符串前面不能没有字符&quot;);
});
</code></pre>
<p>加号前的字符可以重复，goback,gooback,goooback...</p>
<pre><code class="language-js">//可匹配到多个路由时，优先匹配先定义的路由
//一个或多个问号前字符
app.get('/match/go+back',(req, res)=&gt;{
    let what = {
        match: '/match/go+back',
        url: req.url,
        tip: &quot;加号前面的那个字符可以无限重复&quot;
    }
    res.send(what);
});
</code></pre>
<h2 id="正则匹配"><a class="header" href="#正则匹配">正则匹配</a></h2>
<p>可用于复杂路由的匹配，在路由中局部正则时，记得用括号包住</p>
<pre><code class="language-js">//正则匹配
//匹配了127.0.0.1:8080/x//数字useremm//
app.get('/x/(\/[0-9]useremm\/)', function (req,res) {
    console.log(req.body);
    res.send(&quot;正则可用于复杂路径的匹配&quot;);
})
</code></pre>
<h2 id="路由重定向"><a class="header" href="#路由重定向">路由重定向</a></h2>
<p>有时候我们希望某些情况下将路径转发到其他路径，比如404页面之类的<br />
格式: <code>res.redirect(status, url)</code><br />
status是干什么的？对于重定向后的路由不同的请求方法应该使用不同的status:</p>
<ul>
<li>GET</li>
</ul>
<pre><code class="language-js">//转发到 GET /1/2/3/4/5
app.post('/redirect',(req,res)=&gt;{
    res.redirect(301,'/1/2/3/4/5');
});

app.get('/1/2/3/4/5',(req,res)=&gt;{
    res.send(&quot;上山打老虎&quot;);
})
</code></pre>
<p>301或302都是可以的，301代表临时，302代表永久</p>
<p>接下来我们把转发后的路由改成POST，再去访问redirect:</p>
<pre><code class="language-js">app.post('/1/2/3/4/5',(req,res)=&gt;{
    res.send(&quot;上山打老虎&quot;);
})
</code></pre>
<p>是的，响应不到了，转发到POST路由，应当使用307或308，前者临时后者永久<br />
<code>res.redirect(301,'/1/2/3/4/5');</code></p>
<ul>
<li>JSON与重定向</li>
</ul>
<p>开启<code>app.use(express.json)</code>，再尝试访问redirect，结果又得不到响应了，这是为什么？<br />
开启了json解析后，请求变成了json，请求已经不是原始的请求了，变成了json对象，是没办法被转发的<br />
因此在有需要重定向的时候，我们不应该全局json解析了，而是在需要json解析的路由上开启json解析:</p>
<p>建个需要使用json解析的测试接口:</p>
<pre><code class="language-js">app.put('/some/json',(req,res)=&gt;{
    res.send(req.body);
});
</code></pre>
<p>自定义一个选择性body-json的中间件，判定 PUT:/some/json 时局部开启json解析:</p>
<pre><code class="language-js">app.use((req, res, next) =&gt; {
    // 判断当前请求路径是否需要解析JSON请求体
    if (req.path === '/some/json'&amp;&amp; req.method.match(&quot;PUT&quot;)) {
      bodyParser.json()(req, res, next);
    } else {
      next();
    }
});
</code></pre>
<p>尝试用api调试工具访问redirect，重定向成功了，再访问/some/json，也能成功打印请求体.</p>
<h2 id="下一节-jwt基础鉴权"><a class="header" href="#下一节-jwt基础鉴权">下一节-JWT基础鉴权</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jwt基础鉴权"><a class="header" href="#jwt基础鉴权">JWT基础鉴权</a></h1>
<p>Web安全是Web应用中非常重要的一环，主要由后端和服务器承担安全保障<br />
面对请求源，后端有着各种各样的鉴权机制: session,cookie,token,jwt,OAuth,OAuth2,api-key,signature...<br />
本节以jwt为例，演示一个极简的token鉴权</p>
<h2 id="准备工作-5"><a class="header" href="#准备工作-5">准备工作</a></h2>
<ul>
<li>拷贝第一节HelloWorld项目</li>
<li>安装一种jwt依赖(本节使用jsonwebtoken)</li>
</ul>
<h2 id="实践-3"><a class="header" href="#实践-3">实践</a></h2>
<p>接下来我们使用jsonwebtoken来实现最常见的登录鉴权，登录成功后返回一个token，之后凭借这个token去访问另外的路由</p>
<ul>
<li>首先引入jwt依赖</li>
</ul>
<pre><code class="language-js">const jwt = require('jsonwebtoken');
</code></pre>
<ul>
<li>定义一个密钥</li>
</ul>
<p>之后我们会利用这个密钥生成token，和检验token</p>
<pre><code class="language-js">const secret = 'mysecretkey';
</code></pre>
<ul>
<li>写个登录时生成token的函数</li>
</ul>
<p>传入用户名和密码，检验密码，正确就生成一个token<br />
生成token: <code>jwt.sign(标志,密钥,选项(生命周期等))</code></p>
<pre><code class="language-js">function getToken(user) {
    let token = null;
    const payload = {
      uname: user.uname,
    };
    if (user.uname == 'root' &amp;&amp; user.passwd == 'root') {
        token = jwt.sign(payload, secret, { expiresIn: '1h' });
    }
    return token;
}
</code></pre>
<ul>
<li>写一个访问时检验token的函数</li>
</ul>
<p>传入req,res,next，从请求头中取出名字为'token'的一个token，若请求头里不带token则返回请求报告没token，token校验通过了则放行</p>
<pre><code class="language-js">function checkToken(req, res, next) {
    const token = req.headers['token'];
    if (!token) return res.status(401).json({ message: 'No token provided.' });
    jwt.verify(token, secret, (err, decoded) =&gt; {
      if (err) return res.status(500).json({ message: 'Failed to authenticate token.' });
      req.userId = decoded.id;
      next();
    });
}  
</code></pre>
<ul>
<li>编写登录接口</li>
</ul>
<pre><code class="language-js">app.post('/login', (req, res) =&gt; {
    let user = req.body;
    let token = getToken(user);
    if(token!=null) {
        res.send(token);
    } else {
        res.status(401).send(&quot;wrong&quot;);
    }    
});
</code></pre>
<ul>
<li>编写一个需要校验token的接口</li>
</ul>
<p>将token检验函数作为中间件挂载到 /root 路由上</p>
<pre><code class="language-js">app.get('/root', checkToken, (req, res) =&gt; {
    res.send('hello root user!');
});
</code></pre>
<h2 id="接口测试-2"><a class="header" href="#接口测试-2">接口测试</a></h2>
<p>尝试用api调试工具先访问 login 接口，利用正确的用户名和密码获取token，然后用得到的token去访问 root 接口</p>
<h2 id="下一节-全局错误处理"><a class="header" href="#下一节-全局错误处理">下一节-全局错误处理</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局错误处理"><a class="header" href="#全局错误处理">全局错误处理</a></h1>
<p>在前面几节里，我们处理异常的方法都是手动在可能引发异常的地方捕捉错误，这固然是必要的，可以有针对性得处理异常，但很多时候，有许多潜在的异常，有一句话叫永远不要相信输入的数据，你永远都不知道什么时候可能会以什么方式触发某些阴间异常从而造成系统崩溃。因此，我们需要有一位好帮手能帮助我们捕获各种错误</p>
<p>而这位好帮手就是，<strong>异常处理中间件</strong></p>
<h2 id="自定义异常处理中间件"><a class="header" href="#自定义异常处理中间件">自定义异常处理中间件</a></h2>
<h3 id="同步异常"><a class="header" href="#同步异常">同步异常</a></h3>
<p>异常处理中间件需要传入4个参数: err,req,res和next，这样才会被express识别为异常处理中间件<br />
创建一个exhandler，并挂载到服务器上:<br />
注意: 挂载异常处理中间件的行为必须位于所有定义的接口之下，至于理由，会在下一节《中间件》中给出解答</p>
<pre><code class="language-js">let exhandler = (err, req, res, next)=&gt; {
    console.error('Error:', err);
    res.status(500).json(err);
}
app.use(exhandler);
</code></pre>
<p>我们在helloWorld接口中人为抛出一个异常试一下，可以直接throw，也可以传递给next（事实上，意外的异常发生时，会被express捕获并传递给next，然后再丢给我们的异常处理中间件）</p>
<pre><code>app.get('/', (req, res, next)=&gt; {
    const err = new Error();
    err.status = 500;
    err.message = '对不起，网站正在维护中';
    throw err;
    //next(err);
    // res.send('Hello World!');
});
</code></pre>
<h3 id="测试"><a class="header" href="#测试">测试</a></h3>
<p>使用api调试工具GET 127.0.0.1:8080/，我们的程序不会崩溃，并且你将得到被封装好的错误信息，并且响应码是500。</p>
<pre><code class="language-JSON">{
    &quot;name&quot;: &quot;无法访问&quot;,
    &quot;message&quot;: &quot;对不起，网站正在维护中&quot;
}
</code></pre>
<h3 id="异步异常"><a class="header" href="#异步异常">异步异常</a></h3>
<p>上面的异常是产生在串行的代码中的，那如果在异步操作中产生了异常呢？<br />
我们弄一个异步异常的接口试一下:</p>
<pre><code class="language-js">app.post('/', (req, res, next)=&gt; {
    setTimeout(()=&gt;{
        const err = new Error();
        err.name = '无法访问';
        err.message = '对不起，网站真的正在维护中！';
        next(err);
    },3000);
});
</code></pre>
<p>POST 127.0.0.1:8080/，你花费了3秒时间得到我们的维护信息！<br />
不过上面这个接口之所以能返回维护信息，是因为在同步流中，没有进行响应操作，那前端只要不超过设置的超时时间，就会一直等待，然后3秒后等来了我们的错误信息</p>
<p>我们在同步流内先进行响应，假如我们并不在乎异步操作的结果就可以响应了:</p>
<pre><code class="language-js">app.post('/', (req, res, next)=&gt; {
    setTimeout(()=&gt;{
        const err = new Error();
        err.name = '无法访问';
        err.message = '对不起，网站真的正在维护中！';
        next(err);
    },3000);
    res.send(&quot;Bad World!&quot;);
});
</code></pre>
<p>POST 127.0.0.1:8080/，这次你得到了Bad World!，因此只有当你的异常进入了未结束的同步流（用async/await语法糖，或者Promise回调等），才能被返回给请求源</p>
<h2 id="下一节-中间件"><a class="header" href="#下一节-中间件">下一节-中间件</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中间件"><a class="header" href="#中间件">中间件</a></h1>
<p>中间件，估计大家在前几节里面听的耳朵都要出茧子了吧！一直提到，一直不讲。别急，这不来了嘛</p>
<h2 id="准备工作-6"><a class="header" href="#准备工作-6">准备工作</a></h2>
<p>拷贝第一节Hello World项目</p>
<h2 id="什么是中间件"><a class="header" href="#什么是中间件">什么是中间件</a></h2>
<p>如果正在阅读本书之前的你，已经有过一些其他框架或语言的后端开发经历，那理应是知道中间件这个东西的。当然也不绝对，比如隔壁某个框架太贴心了，以至于笔者都觉得理所应当，在撰写本节时，才惊觉原来在那个框架里竟内置了这么多的中间件。</p>
<p>由于 express.js 是一个轻量级后端框架，因此中间件的身份变得非常的突出。</p>
<p>在 express.js 中，中间件（Middleware）是指应用中，用于<strong>额外</strong>处理 HTTP 请求和响应的函数，通常不涉及主体业务。中间件函数可以访问请求对象（request object）（req）、响应对象（response object）（res）和应用程序中处理请求-响应循环流程的<strong>下一个</strong>中间件函数（next）。
在 express.js 应用中，可以使用 use() 方法来挂载中间件函数。在处理 HTTP 请求时，express.js 会按照添加中间件函数的顺序依次调用它们，直到响应被发送为止。如果在某个中间件函数中没有调用 next() 方法，则<strong>请求-响应</strong>循环流程会在该中间件函数队伍中提前终止。</p>
<p>中间件的应用主要在日志，鉴权，预检，初步数据处理，异常处理等等。接下来，举几个简单的例子:</p>
<h2 id="路由中间件"><a class="header" href="#路由中间件">路由中间件</a></h2>
<p>是的，路由可以单独抽离出来的中间件，可以挂载在app也可以作为子路由挂载在其他路由上</p>
<pre><code class="language-javascript">//Route coule be middleware
const routers = express.Router();

routers.get('/', function (req, res) {
    res.send('Hello World!');
});

routers.post('/', (req,res)=&gt; {
    res.send('Bad World!');
    
})
app.use(routers)
</code></pre>
<h2 id="鉴权中间件"><a class="header" href="#鉴权中间件">鉴权中间件</a></h2>
<p>鉴权中间件，可以被挂载到单个路由，一系列路由以及app全局<br />
这是一个检查请求头token的鉴权中间件:</p>
<pre><code class="language-javascript">//鉴权中间件，可以被挂载到单个路由，一系列路由以及全局
let auth = (req,res,next) =&gt; {
    if (req.headers['token']!='evanp'){
        return res.send('Unauthorized');
    }
    next()
}

const router_root = express.Router();

router_root.post('/root', auth, (req,res)=&gt; {
    res.send('Hello root!')
})
app.use(router_root);
</code></pre>
<h2 id="异常处理中间件"><a class="header" href="#异常处理中间件">异常处理中间件</a></h2>
<p>异常处理中间件，全局捕捉异常，防止服务器崩溃</p>
<pre><code class="language-javascript">//异常中间件
const exhandler = (err,req,res,next)=&gt; {
    return res.json({ &quot;err&quot;:{ &quot;name&quot;: err.name, &quot;msg&quot;: err.message }});
}
app.use(exhandler);

//测试接口
router_err.get('/error', auth, (req,res)=&gt; {
    const err = new Error(&quot;error!&quot;);
    err.name = &quot;故意err&quot;;
    err.message = &quot;error!&quot;;
    throw err;
    res.status(200).json({msg: 'good!'});
})
app.use(router_err);
</code></pre>
<h2 id="第三方中间件"><a class="header" href="#第三方中间件">第三方中间件</a></h2>
<p>当然了，在实际生产中，并不需要每个中间件都我们自己写，一是自己造轮子麻烦，而是自己造的轮子可用性不高，不够专业，三是优秀团队开发的中间件性能更好，隐患更小<br />
可以更多的使用第三方团队开发的优秀的中间件，比如鉴权相关的passport.js，jsonwebtoken，sql相关的knex，sequelize等等。</p>
<h2 id="万物皆可中间件"><a class="header" href="#万物皆可中间件">万物皆可中间件</a></h2>
<p>上面给的几个例子，都是属于一个模块的不同部分作为中间件挂载到当前的应用，在express.js中，中间件远不止于次</p>
<p>app也可以作为中间件挂载到app!一般是负责不同功能的app聚合到一个总的app上，比如订单模块单独一个app，用户模块单独一个app，一起挂载到作为整个完整系统的app上，这样子把整个系统按不同模块切割成独立的app，更易于维护和管理，有点伪微服务架构的意味。</p>
<p>router也能把app作为他的子中间件，这种做法应该很少用吧，暂时不清楚有什么应用场景。</p>
<h2 id="下一章-架构整合"><a class="header" href="#下一章-架构整合">下一章-架构整合</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="架构整合"><a class="header" href="#架构整合">架构整合</a></h1>
<p>在第一章中，我们按功能分块学习了express后端中不同方面的技术，所有的代码基本都写在了一个文件中，在实际开发中这是不符合规范的，我们需要有一个合理的目录结构，在本章中，将结合常见的前后端架构思想，express.js特性以及借鉴其他语言的优秀框架的架构，每节介绍一种架构方式</p>
<p>注意，这些架构的名字仅仅是我自己这么称呼用的，不代表它们就一定叫这个</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="express-cli"><a class="header" href="#express-cli">express-cli</a></h1>
<p>首先介绍一下express官方的手脚架</p>
<h2 id="搭建"><a class="header" href="#搭建">搭建</a></h2>
<ul>
<li>创建一个目录</li>
<li>进入项目，终端内暗转express</li>
</ul>
<pre><code class="language-shell">npm install express
</code></pre>
<ul>
<li>利用express打架基础项目</li>
</ul>
<pre><code class="language-shell">express
</code></pre>
<ul>
<li>安装基础项目的依赖</li>
</ul>
<pre><code class="language-shell">npm install
</code></pre>
<p>你将获得这样的一个项目，可以通过<code>npm run start</code>运行:</p>
<pre><code class="language-text">│  app.js
│  package-lock.json
│  package.json
│
├─bin
│      www
│
├─node_modules
├──//...
│
├─public
│  ├─images
│  ├─javascripts
│  └─stylesheets
│          style.css
│
├─routes
│      index.js
│      users.js
│
└─views
        error.jade
        index.jade
        layout.jade
</code></pre>
<p>app.js是整个程序的入口文件，package.json是项目配置文件，node_modules是项目依赖，public是存放静态资源的目录，routes是存放我们定义的路由模块的目录，views是渲染层目录(里面的.jade是node.js的一种页面渲染模板)，bin是脚本目录</p>
<h2 id="启动脚本"><a class="header" href="#启动脚本">启动脚本</a></h2>
<p>bin目录下的www，其实就是一个写好的脚本，用来挂载express应用并启动服务器的:<br />
引入了app.js，设置了端口，创建了一个服务器，定义了错误监听和成功监听端口时的回调，基本上就这么一些东西</p>
<h2 id="静态目录"><a class="header" href="#静态目录">静态目录</a></h2>
<p>public没什么可说的，就存放静态资源的，如果是当作纯后端，就放点图片、LOGO、以及初始化文件之类的，前后端一体的话还多些css和js脚本等</p>
<h2 id="views"><a class="header" href="#views">views</a></h2>
<p>一体的前端，渲染模板用的jade，我不会，跳过</p>
<h2 id="routes"><a class="header" href="#routes">routes</a></h2>
<p>专门放定义的路由/接口，我们看其中一个:<br />
写完一个路由，然后导出，就这样</p>
<pre><code class="language-js">var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function(req, res, next) {
  res.render('index', { title: 'Express' });
});

module.exports = router;

</code></pre>
<p>当然，你也可以不止写一个路由，写成聚合路由集群，或者导出多个也是可以的，一般同属一个小模块的可以放在一个文件里</p>
<h2 id="补充"><a class="header" href="#补充">补充</a></h2>
<p>这个手脚架的结构就这么简单，实际开发中，我们肯定要加添加更多的目录，比如存放类的目录，存放封装好的sql或者工具函数的目录，存放自定义的中间件目录等等</p>
<p>本身express就是个轻量级框架，简单意味着你可以更加自由的组装你的项目结构</p>
<h2 id="下一节-mvc层级架构"><a class="header" href="#下一节-mvc层级架构">下一节-MVC层级架构</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mvc层级架构"><a class="header" href="#mvc层级架构">MVC层级架构</a></h1>
<p>M-V-C(model-view-control)是非常经典的一种web项目架构，将项目分为模型，视图和控制三大层。</p>
<p>这是我自己搭建的一种mvc架构:</p>
<pre><code class="language-text">│  app.js
│  package-lock.json
│  package.json
│
├─control
│  ├─routes
│  │      userRoutes.js
│  │
│  └─service
│          userService.js
│
├─model
│      resp.js
│      user.js
│
├─node_modules
│  //...
│
├─static
│      data.json
│
├─utils
│      sqlUtil.js
│      stringUtil.js
├─midwares
│      exhandler.js
│
└─views
        index.html
</code></pre>
<p>模型：实体类<br />
视图：页面<br />
控制：各种控制（逻辑、视图等）</p>
<p>他们各自还可以细分层次：</p>
<h2 id="model层"><a class="header" href="#model层">model层</a></h2>
<p>所有模块需要的模型都放到这里</p>
<p>model可以按照其用途、服务对象等分成普通对象、数据传输对象、完整对象的散对象、数据表映射对象等等，比如po, dto, vo等等，之前sequelize中的模型就算是数据表映射对象。<br />
当然这是一个跨语言的概念，由于js天生没有类型系统，很多时候你可以选择不定义某些对象，有更高的灵活性，定义对象，虽然灵活性降低，但更易于代码维护，看实际情况决定，当然，一些高复用性的建议定义好，比如给REST接口统一的返回格式，那你就可以专门设定一个对象:</p>
<pre><code class="language-js">let resp = {
  code: null,
  msg: null,
  data: null,

  Ok: (msg,data)=&gt;{
    this.code = 200;
    this.msg = msg!=undefined? msg : 'success';
    this.data = data!=undefined? data : null;
  }
}

let respOk = {
  code: 200,
  msg: 'success',
  data: null
}

module.exports = {
  resp: resp,
  respOk: respOk
}
</code></pre>
<h2 id="控制层"><a class="header" href="#控制层">控制层</a></h2>
<p>所有功能模块的路由，服务等等都放到这里</p>
<p>控制层可以再根据特性分层，比如路由单独搞个routes层，业务处理单独搞个service层等等</p>
<h2 id="补充-1"><a class="header" href="#补充-1">补充</a></h2>
<p>同样的，实际开发中需要更多的目录，比如工具目录，资源目录等等，放你的图片，放你的工具函数，放你封装好的sql函数，放你的中间件等等</p>
<h2 id="下一节-基于业务特性的分布式架构"><a class="header" href="#下一节-基于业务特性的分布式架构">下一节-基于业务特性的分布式架构</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于业务特性的分布式架构"><a class="header" href="#基于业务特性的分布式架构">基于业务特性的分布式架构</a></h1>
<p>上节的mvc架构，把所有不同模块的同层文件都放在一个目录下</p>
<p>我们也可以将你的项目结构按照业务模块进行划分，每一个模块内可以再按mvc分层，或者不分，这样子把不同模块独立出来的就叫做分布式架构(dcs)</p>
<h2 id="结构"><a class="header" href="#结构">结构</a></h2>
<pre><code>│  package-lock.json
│  package.json
│  server.js
│
├─assets
│      logo.svg
│
├─goodModule
│  │  app.js
│  │
│  ├─midwares
│  ├─model
│  │      good.js
│  │
│  ├─routes
│  ├─service
│  └─sqls
├─midwares
├─node_modules
│  //...
│
├─orderModule
│  │  app.js
│  │
│  ├─midwares
│  ├─model
│  │      order.js
│  │
│  ├─routes
│  ├─service
│  └─sqls
├─userModule
│  │  app.js
│  │
│  ├─midwares
│  ├─model
│  ├─routes
│  ├─service
│  └─sqls
├─utils
└─views
</code></pre>
<p>server.js是整个应用的入口文件，user，good和order分别创建了三个express app，完成各自的业务，最终挂载到server.js中去</p>
<h2 id="下一节-微服务架构"><a class="header" href="#下一节-微服务架构">下一节-微服务架构</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微服务架构"><a class="header" href="#微服务架构">微服务架构</a></h1>
<h2 id="下一章-高级进阶"><a class="header" href="#下一章-高级进阶">下一章-高级进阶</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
