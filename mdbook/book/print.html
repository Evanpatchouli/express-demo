<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>跟着例子学Express.js</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">模块化学习</li><li class="chapter-item expanded "><a href="chapter_1/intro.html"><strong aria-hidden="true">1.</strong> 本章简介</a></li><li class="chapter-item expanded "><a href="chapter_1/section_1.html"><strong aria-hidden="true">2.</strong> HelloWorld</a></li><li class="chapter-item expanded "><a href="chapter_1/section_2.html"><strong aria-hidden="true">3.</strong> 请求类型</a></li><li class="chapter-item expanded "><a href="chapter_1/section_3.html"><strong aria-hidden="true">4.</strong> 处理请求数据</a></li><li class="chapter-item expanded "><a href="chapter_1/section_4.html"><strong aria-hidden="true">5.</strong> Sql-knex增删改查</a></li><li class="chapter-item expanded "><a href="chapter_1/section_5.html"><strong aria-hidden="true">6.</strong> Sql-ORM增删改查</a></li><li class="chapter-item expanded "><a href="chapter_1/section_6.html"><strong aria-hidden="true">7.</strong> 路由控制</a></li><li class="chapter-item expanded "><a href="chapter_1/section_7.html"><strong aria-hidden="true">8.</strong> JWT基础鉴权</a></li><li class="chapter-item expanded "><a href="chapter_1/section_8.html"><strong aria-hidden="true">9.</strong> 全局错误处理</a></li><li class="chapter-item expanded "><a href="chapter_1/section_9.html"><strong aria-hidden="true">10.</strong> 中间件</a></li><li class="chapter-item expanded affix "><li class="part-title">架构整合</li><li class="chapter-item expanded "><a href="chapter_2/intro.html"><strong aria-hidden="true">11.</strong> 本章简介</a></li><li class="chapter-item expanded affix "><li class="part-title">高级进阶</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">跟着例子学Express.js</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="跟着例子学expressjs"><a class="header" href="#跟着例子学expressjs">跟着例子学express.js</a></h1>
<p>撰写本书的起因，是我的一个朋友有学习node后端的意愿，加之node在我手里落灰已久，于是决定趁着这个机会好好梳理一下，在空闲之余谱一份还算简明的渐进式教程，希望能对各位朋友以及未来又淡忘了express的自己有所帮助.</p>
<p>express-demo，跟着例子学express，先按不同的功能分块学习express.js，从路由，接口，数据库，鉴权等等一块一块地进行分布式的基础学习，等有了较为完备的基础，根据一定的架构思想形成一个完整的express.js后端，最后再介绍一些可能用得到的进阶技巧.</p>
<h4 id="源码"><a class="header" href="#源码">源码</a></h4>
<p>仓库有着每一节教程中的完整源码，在阅读本书时，请务必配合源码食用，动手是最好的老师</p>
<h4 id="进度"><a class="header" href="#进度">进度</a></h4>
<p>当前本书进度40%，敬请期待</p>
<h4 id="合作"><a class="header" href="#合作">合作</a></h4>
<p>如本书或者源码有任何的纰漏或者错误，欢迎指正，谢谢！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块化学习"><a class="header" href="#模块化学习">模块化学习</a></h1>
<p>我们将把express分为不同的知识模块进行独立学习，通常来说，建议按从前到后的顺序依次学习</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>本节我们将创建并运行我们的第一个express.js项目，并使用最简单的请求响应</p>
<h2 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h2>
<ul>
<li>本书系统环境为 <strong>windows10 64Bit</strong></li>
<li>请事先在你的开发环境中安装 <strong>Node.js</strong>，本书使用的是 <strong>node v16.17.1</strong></li>
<li>推荐使用 <strong>VsCode</strong> 作为开发工具，有良好的代码提示功能</li>
<li>事先安装一个api调试工具，如 <strong>postman</strong>, <strong>apipost</strong>等</li>
</ul>
<h2 id="创建项目"><a class="header" href="#创建项目">创建项目</a></h2>
<ol>
<li>创建一个文件夹作为项目根目录</li>
<li>下载express依赖<br />
在根目录下执行<code>npm install express</code></li>
<li>下载js-text-chart依赖<br />
在根目录下执行<code>npm install js-text-chart</code>，这是一个用于输出字符画的js库，本书在每一个示例中都使用了该库充当starter</li>
<li>在根目录下新建一个入口文件，如<strong>index.js</strong></li>
<li>在入口文件中引入依赖</li>
</ol>
<pre><code class="language-js">const express = require('express');
const evchart = require('js-text-chart').evchart;
</code></pre>
<h2 id="创建服务器"><a class="header" href="#创建服务器">创建服务器</a></h2>
<ol>
<li>先创建一个express实例</li>
</ol>
<pre><code class="language-js">const app = express();
</code></pre>
<ol start="2">
<li>创建服务器</li>
</ol>
<p>让我们刚刚创建的app实例挂载到指定的端口，如8080</p>
<pre><code class="language-js">const server = app.listen(8080);
</code></pre>
<ol start="3">
<li>添加服务器运行后的回调函数</li>
</ol>
<p>是指在服务器成功运行后的一系列操作，常用于输出信息和初始化等，我在这里打印该项目的基本信息<br />
我使用的是内联箭头函数 &quot;()=&gt;{//...}&quot;，也可以替换为普通的&quot;function {//...}&quot;</p>
<pre><code class="language-js">const server = app.listen(8080, () =&gt; {
    let host = server.address().address;
    let port = server.address().port;

    let str = &quot;EXPRESS-DEMO&quot;;
    let mode = [ &quot;close&quot;, &quot;far&quot;, undefined ];
    let chart = evchart.convert(str, mode[0]);
    console.log(chart);

    console.log(&quot;Server is ready on http://%s:%s&quot;, host, port);
})
</code></pre>
<ol start="4">
<li>跨域策略</li>
</ol>
<p>默认情况下可能不允许不同域名下进行交互，我们对请求进行一些基本的设置，允许跨域和所有的请求方式请求头格式化，并设置请求头内容为json格式</p>
<pre><code class="language-js">app.all(&quot;*&quot;, function (req, res, next) {
    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;);
    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);
    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);
    next();
});
</code></pre>
<h2 id="第一个接口"><a class="header" href="#第一个接口">第一个接口</a></h2>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<p>前后端交互是在后端暴露的接口进行的，而不同的接口对于后端端口上不同的url路径。前端使用不同的方式（GET,POST...）请求指定的路径，当后端有定义监听某种方式下的某种路径接口时，获取请求携带的数据，对请求进行处理，并返回结果给前端 </p>
<h3 id="实践"><a class="header" href="#实践">实践</a></h3>
<p>接下来，我们将添加一个以服务器的根路径（GET）作为返回欢迎信息的接口</p>
<pre><code class="language-js">app.get('/', function (req, res) {
    res.send('Hello World!');
});
</code></pre>
<p>以上代码，app实例<strong>监听</strong> <strong>localhost:8080/</strong> 路径的<strong>GET</strong>请求，传入2个参数，第一个是请求，第二个是响应<br />
当接收到以GET方式访问该接口的请求时，通过在回调函数中执行<code>res.send</code>返回 Hello World!</p>
<h3 id="测试接口"><a class="header" href="#测试接口">测试接口</a></h3>
<p>使用接口测试工具，以GET的形式访问localhost:8080/试试吧！你将会得到一句 Hello World!</p>
<h2 id="第二个接口"><a class="header" href="#第二个接口">第二个接口</a></h2>
<p>第一个接口，我们只是单纯的访问了接口，没有传输任何数据，接下来我们将创建一个以传统的路径请求参数（如: url?id=1）携带数据的接口</p>
<h3 id="实践-1"><a class="header" href="#实践-1">实践</a></h3>
<p>定义一个GET形式，路径为 /get 的接口，传入2个参数请求和响应，我们在回调函数中通过<code>req.query</code>来获取路径上的所有请求参数，并将这些参数作为接口的返回值</p>
<pre><code class="language-js">app.get('/get', function (req, res) {
    let requestParams = req.query;
    res.send(requestParams);
});
</code></pre>
<h3 id="测试接口-1"><a class="header" href="#测试接口-1">测试接口</a></h3>
<p>使用接口测试工具，以GET的形式访问 localhost:8080/get?id=1&amp;name=evanp 试试吧！你将会得到这两个参数!</p>
<h2 id="下一章-请求类型"><a class="header" href="#下一章-请求类型">下一章-请求类型</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="请求类型"><a class="header" href="#请求类型">请求类型</a></h1>
<p>本节将介绍常见的http请求方式，并站在后端的角度初步感受它们的不同点</p>
<h2 id="各类http请求"><a class="header" href="#各类http请求">各类Http请求</a></h2>
<ul>
<li><strong>GET</strong><br />
意图是<strong>获取</strong>，不会对服务器上的数据产生影响，将要携带的数据放在<strong>URL</strong>上，通常不带请求体，带了也不一定兼容</li>
<li><strong>POST</strong><br />
意图是<strong>提交</strong>，通常用于修改和新增服务器上的数据，偏向<strong>新增</strong>，路径定位较模糊，要携带的数据通常放在<strong>请求体</strong>内</li>
<li><strong>PUT</strong><br />
类似POST，偏向<strong>更新</strong>，路径定位更明确，要携带的数据通常放在<strong>请求体</strong>内<br />
★ <strong>幂等性</strong>：连续PUT请求后，效果应当只有一次，而POST则会创建多个新资源，不过在REST风格下以及在后台有严格的检验情况下其实这些区别可以忽略<br />
★ <strong>缓存机制</strong>：由于PUT的幂等性，不存在缓存，而POST是缓存的，比如你在表单里用POST，不设置提交后清除，刷新页面它会将之前的数据再提交一遍</li>
<li><strong>DELETE</strong><br />
意图是删除，从服务器上删除某些数据</li>
<li><strong>HEAD</strong><br />
类似GET，但争对它的响应没有body，只有响应头，常用于判断资源是否存在、链接有效性等</li>
<li><strong>OPTIONS</strong><br />
意图是询问当前URL允许的请求方法等，常用于跨域请求前的预检和获取服务器的安全控制信息等</li>
<li><strong>TRACE</strong><br />
路径追踪，回显请求，常用于测试阶段</li>
<li><strong>PATCH</strong><br />
PUT的超类，指定资源的局部更新</li>
<li><strong>COPY</strong><br />
请求将页面拷贝到另一个URL，常用于Web资源的备份</li>
<li><strong>MOVE</strong><br />
请求将页面移动到另一个URL，常用于Web资源的搬迁</li>
<li><strong>LINK</strong><br />
请求与服务器建立链接</li>
<li><strong>UNLINK</strong><br />
断开与服务器的链接</li>
</ul>
<p>其中 GET, POST 最为广泛使用，同时可以使用PUT和DELETE让我们的接口的目的更具有指向性<br />
本书绝大部分接口都将采用类REST风格，即普遍的返回码200，数据格式为json</p>
<h2 id="express处理不同的请求"><a class="header" href="#express处理不同的请求">express处理不同的请求</a></h2>
<p>通过调用get,post,pu,delete...对应不同方法下的路由<br />
由于实际受不同的开发规范和业务环境影响，在这里只以GET和POST举例</p>
<h3 id="get请求"><a class="header" href="#get请求">get请求</a></h3>
<pre><code class="language-js">//省略了express项目的创建
class Item {
    constructor(name, value) {
      this.name = name;
      this.value = value;
    }
}

//get接口
app.get('/request', function (req, res) {
    let result = [];
    result.push(new Item(&quot;baseUrl&quot;,req.baseUrl));
    result.push(new Item(&quot;fresh&quot;,req.fresh));   //请求是否存活
    result.push(new Item(&quot;hostname&quot;,req.hostname)); //请求源域名
    result.push(new Item(&quot;ip&quot;,req.ip)); //请求源IP
    result.push(new Item(&quot;originalUrl&quot;,req.originalUrl));
    result.push(new Item(&quot;params&quot;,req.path));   //路径参数: /x/y/z/
    result.push(new Item(&quot;protocol&quot;,req.protocol)); //请求协议
    result.push(new Item(&quot;query&quot;,req.query));   //查询参数
    result.push(new Item(&quot;route&quot;,req.route));   //请求路由
    result.push(new Item(&quot;is:Content-Type&quot;,req.is('application/json')));

    res.send(result);
});
</code></pre>
<p>以上代码，定义了GET接口，并返回了关于请求的大部分信息</p>
<h3 id="测试接口-2"><a class="header" href="#测试接口-2">测试接口</a></h3>
<p>使用api调试工具，尝试用不同的携带数据方法以get形式访问该接口，比较不同的返回结果</p>
<h3 id="post请求"><a class="header" href="#post请求">post请求</a></h3>
<p>监听相同路径的post请求，开启json解析，一会我们调试时请求体采用最常用的json格式</p>
<pre><code class="language-js">//启用json解析
app.use(express.json({type: 'application/json'}));

app.post('/post', function (req, res) {
    let result = [];
    result.push(new Item(&quot;baseUrl&quot;,req.baseUrl));
    result.push(new Item(&quot;fresh&quot;,req.fresh));
    result.push(new Item(&quot;hostname&quot;,req.hostname));
    result.push(new Item(&quot;ip&quot;,req.ip));
    result.push(new Item(&quot;originalUrl&quot;,req.originalUrl));
    result.push(new Item(&quot;params&quot;,req.path));
    result.push(new Item(&quot;protocol&quot;,req.protocol));
    result.push(new Item(&quot;query&quot;,req.query));
    result.push(new Item(&quot;body&quot;,req.body));
    result.push(new Item(&quot;route&quot;,req.route));
    result.push(new Item(&quot;is:Content-Type&quot;,req.is('application/json')));

    res.send(result);
});
</code></pre>
<h3 id="测试接口-3"><a class="header" href="#测试接口-3">测试接口</a></h3>
<p>使用api调试工具，尝试用不同的携带数据方法以post形式访问该接口，比较不同的返回结果</p>
<h3 id="不限方法"><a class="header" href="#不限方法">不限方法</a></h3>
<p>如果你想让某个某个路由能以任意方法访问:</p>
<pre><code class="language-js">app.use('/any', function (req, res) {
    res.send('Bad World!');
});
</code></pre>
<p>尝试使用各种方法去访问 127.0.0.1:8080/any，都可以得到Bad World!</p>
<h2 id="下一章-处理请求数据"><a class="header" href="#下一章-处理请求数据">下一章-处理请求数据</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="处理请求数据"><a class="header" href="#处理请求数据">处理请求数据</a></h1>
<p>本节将具体介绍express后端处理请求源携带数据的一些方法和技巧</p>
<h2 id="动态路径"><a class="header" href="#动态路径">动态路径</a></h2>
<p>很多时候我们需要处理一些类似但有操作差别或不同对象的业务，我们可以监听一段基本路径，将其中某一个段或者某几段路径作为变量，在接口中根据不同的路径变量执行不同的业务操作，这是一种REST风格比较鲜明的动态接口设计策略</p>
<h3 id="实践-2"><a class="header" href="#实践-2">实践</a></h3>
<p>由于post也可以url传参，本节所有实例均采用post请求 </p>
<h4 id="第一个接口-1"><a class="header" href="#第一个接口-1">第一个接口</a></h4>
<p>这个接口以 /request/data/ 作为基路由，之后的kind变化的，在接口内部根据kind的值进行分支化处理。我指定了kind的3个值：PathVarible, RequestParam 和 body.<br />
所有的路径参数则可以由<code>req.params</code>（大概是个json对象）来获取，我要指定获取kind的值，就req.params.kind，而静态路径变量的值就等于它名字.</p>
<pre><code class="language-js">//忽略了express项目的创建和基本配置
class Item {
    constructor(name, value) {
      this.name = name;
      this.value = value;
    }
}
//启用json解析请求体
app.use(express.json({type: 'application/json'}));
app.post('/request/data/:kind', function (req, res) {
    let result = [];
    if (req.params.kind == 'PathVarible') {
        result.push(new Item(&quot;lesson&quot;,&quot;路径变量&quot;));
        result.push(new Item(&quot;info&quot;,&quot;在express中叫做params，路径上每个被双单斜杠'/'隔开的一个个词语就是路径参数，当你需要在同一个接口内动态响应不同的情景时，可以让某一处或多出的路径参数前面加上一个冒号，长得比较像vue中的动态绑定，动态路径在REST风格上被广泛运行，比如操作某个用户: 'user/:id =&gt; 'user/1&quot;))
    } else if (req.params.kind == 'RequestParam') {
        result.push(new Item(&quot;lesson&quot;,&quot;请求参数&quot;));
        result.push(new Item(&quot;info&quot;,&quot;在express中叫做query，和路径变量相比，前者更像是前端主动携带参数去访问特定的资源，而后者更像是后端要求必须携带的数据，前端被迫携带，反应在路径上形式一般是: '/stu?class=2&amp;sid=1&amp;name='evanp',在基本路径之后添上一个问号，然后在后面加上请求的参数，不同参数之间用'&amp;'符号隔开&quot;))
    } else if (req.params.kind == 'body') {
        result.push(new Item(&quot;lesson&quot;,&quot;请求体&quot;));
        result.push(new Item(&quot;info&quot;,&quot;路径变量和请求参数的数据都是透明的，这非常不注重隐私，因此更多时候前端应该将携带的数据放在请求体内进行传输。请求体的形式有很多，最常用的是表单和JSON，请在路径后新增一个路径变量，form-urlencode, multi-form-data或json导向不同的接口进行查看&quot;));
    } else {
        result.push(new Item(&quot;error&quot;,&quot;这个参数不认识&quot;));
    }
    res.send(result);
});
</code></pre>
<h4 id="接口测试"><a class="header" href="#接口测试">接口测试</a></h4>
<p>请使用接口调试工具，带上路径查询参数(query)，然后修改不同的kind为不同的值，去POST访问 localhost:8080/request/data/kind，看看它们的返回结果，注意kind前不要加冒号了，冒号是用来让express知道这段路径是可变的</p>
<h4 id="第二个接口-1"><a class="header" href="#第二个接口-1">第二个接口</a></h4>
<p>当第一个接口的某一个分支还可以有后续的操作时，可以再开一个接口以它作为基路由，往后新增动态路径，比如我现在要让body可以再导向不同的分支，就再开一个 /request/data/body/:kind 接口</p>
<pre><code class="language-js">app.post('/request/data/body/:kind', function (req, res) {
    let result = [];
    if (req.params.kind == 'json') {
        result.push(new Item(&quot;lesson&quot;,&quot;json请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
        result.push(new Item(&quot;info&quot;,&quot;express想解析json形式的body，必须先开启express.json: 'app.use(express.json)'，之后就可以用req.body来接收请求体了&quot;));
        result.push(new Item(&quot;trick&quot;,&quot;进阶技巧，读取请求体时可以用match模式匹配成自己想要的格式或命名，常用于实体注入及转化等&quot;));
    } else if (req.params.kind == 'form-urlencode') {
        result.push(new Item(&quot;lesson&quot;,&quot;form-urlencode请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
    } else if (req.params.kind == 'multi-form-data') {
        result.push(new Item(&quot;lesson&quot;,&quot;multi-form-data请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
    } else {
        result.push(new Item(&quot;error&quot;,&quot;这个参数不认识&quot;));
    }
    res.send(result);
});
</code></pre>
<h4 id="接口测试-1"><a class="header" href="#接口测试-1">接口测试</a></h4>
<p>请使用接口调试工具，带上JSON请求体，去POST访问 localhost:8080/request/data/body/kind，修改不同的kind，看看它们的返回结果</p>
<h2 id="获取路径参数"><a class="header" href="#获取路径参数">获取路径参数</a></h2>
<h3 id="基础"><a class="header" href="#基础">基础</a></h3>
<p>路径参数是指 '/url?id=1&amp;name=evanp' 这种url中的id和name，是明文的不具有隐私性<br />
可以通过 <code>req.query</code>获取</p>
<pre><code class="language-js">app.post('/request/data/query/info',checkQuery, (req, res)=&gt; {
    res.send(req.query);
});
</code></pre>
<p>尝试用接口调试工具访问 localhost:8080/request/data/query/info，并携带上任意的query参数</p>
<h3 id="query预检"><a class="header" href="#query预检">Query预检</a></h3>
<p>在实际场景中，每个接口会指定需要哪些名字的query参数，假设上面的接口需要id和name，则需要保证前端确实给接口传递了这两个query参数，express没有像springboot那样在入参的时候就可以规定检验，我们必须亲自对传过来的query进行检验。而这部分检验的操作不建议包含在我们接口的主体回调函数内，而应作为一个<strong>中间件</strong>，在回调之前就完成检验:</p>
<p>定义一个检查query的函数，判断是否有id和name，是的话继续，不是的话直接返回错误信息</p>
<pre><code class="language-js">function checkQuery(req,res) {
    if (req.query.id == undefined ||
        req.query.id == null ||
        req.query.name == undefined ||
        req.query.name == null){
        res.send({&quot;msg&quot;: &quot;query不齐全&quot;});
    }
}
</code></pre>
<p>在接口入参时引入该中间件函数</p>
<pre><code class="language-js">app.post('/request/data/query/info',checkQuery, (req, res)=&gt; {
    res.send(req.query);
});
</code></pre>
<p>尝试用接口调试工具访问 localhost:8080/request/data/query/info，并比较不携带id,name和携带了id,name的返回结果</p>
<h2 id="获取请求体"><a class="header" href="#获取请求体">获取请求体</a></h2>
<h3 id="json请求体"><a class="header" href="#json请求体">JSON请求体</a></h3>
<p>引入以下代码一次即可</p>
<pre><code class="language-js">app.use(express.json({type: 'application/json'}));
</code></pre>
<h3 id="表单x-www-form-urlencoded"><a class="header" href="#表单x-www-form-urlencoded">表单（x-www-form-urlencoded）</a></h3>
<p><strong>x-www-form-urlencode</strong>将表单数据编码为URL形式的字符串</p>
<p>引入以下代码一次即可</p>
<pre><code class="language-js">app.use(express.urlencoded({extended: true}));
</code></pre>
<p>关于extended参数，是指将（URL编码字符串形式的）表单数据解析为简单对象还是深度嵌套对象.<br />
什么意思呢？就比如当extended=false时，表单里是这么传数据的: 
其中，有两个相同的键名: 比如传了2个x
解析后该字段的指将是所有它们的值的数组集合：<code>x=1&amp;x=2</code> -&gt; <code>{'x': ['1','2']}</code>，即便2个x都为1，也是数组: <code>{'x': ['1','1']}</code><br />
其中，又有的键名是以对象属性格式传递的，比如下图的user[uname]:
<img src="https://evan-oss-bucket1.oss-cn-hangzhou.aliyuncs.com/express-demo/x-form.png" alt="表单传嵌套对象" />
假如我们在api调试工具访问之前那个body/form-urlencode接口，同时以表单方式传输了这两种情况的数据，将得到这样的返回结果: </p>
<pre><code class="language-json">[
    {
        &quot;name&quot;: &quot;lesson&quot;,
        &quot;value&quot;: &quot;form-urlencode请求体&quot;
    },
    {
        &quot;name&quot;: &quot;body&quot;,
        &quot;value&quot;: {
            &quot;user[uname]&quot;: &quot;evanp&quot;,
            &quot;user[passwd]&quot;: &quot;iloveu&quot;,
            &quot;x&quot;: [
                &quot;1&quot;,
                &quot;2&quot;
            ]
        }
    }
]
</code></pre>
<p>当extended=true时，则是:</p>
<pre><code class="language-json">[
    {
        &quot;name&quot;: &quot;lesson&quot;,
        &quot;value&quot;: &quot;form-urlencode请求体&quot;
    },
    {
        &quot;name&quot;: &quot;body&quot;,
        &quot;value&quot;: {
            &quot;user&quot;: {
                &quot;uname&quot;: &quot;evanp&quot;,
                &quot;passwd&quot;: &quot;iloveu&quot;
            },
            &quot;x&quot;: [
                &quot;1&quot;,
                &quot;2&quot;
            ]
        }
    }
]
</code></pre>
<p>通过对比我们可以发现，<code>extended=false</code>时express比较憨，不会智能解析user到一个对象上去；智能解析的用处，我想大概是省的我们手动一条条注入属性到对象上去了</p>
<h4 id="表单验证"><a class="header" href="#表单验证">表单验证</a></h4>
<p>对于请求参数我们有验证的需求，同样的，表单验证自然也会有，甚至可能需求性更高，因为需要考虑到安全问题<br />
如果没有什么特殊要求，可以自己写一个中间件函数来检查表单，如果有比较高级的需求，可以借助线程的js库，如<strong>express-validator</strong>等</p>
<h2 id="表单multi-form-data"><a class="header" href="#表单multi-form-data">表单（multi-form-data）</a></h2>
<p>这个是可以一边传字符串，还可以传文件的表单，其实就是基础表单的一个升级版</p>
<p>需要事先安装<strong>multer</strong>依赖: <code>npm install multer</code><br />
引入依赖中间件: </p>
<pre><code class="language-js">const multer = require('multer');
const uploads = multer();
</code></pre>
<p>在需要接收文件的接口引入该中间件uploads:</p>
<pre><code class="language-js">app.post('/request/data/body/:kind', uploads.any(), function (req, res) 
</code></pre>
<p>在主体回调函数中通过<code>req.files</code>可以获取到所有的文件:</p>
<pre><code class="language-js">console.log(req.files); //写在multi-form-data分支下，方便区分
</code></pre>
<h3 id="测试接口-4"><a class="header" href="#测试接口-4">测试接口</a></h3>
<p>使用api调试工具的复合表单携带文件发送请求到 body/multi-form-data 接口，查看我们的控制台:</p>
<pre><code class="language-bash">[
  {
    fieldname: 'file',
    originalname: 'C.jpeg',
    encoding: '7bit',
    mimetype: 'image/jpeg',
    buffer: &lt;Buffer ff d8 ff e0 00 10 4a 46 49 46 00 01 01 01 00 48 00 48 00 00 ff db 00 43 00 0a 07 08 09 08 06 0a 09 08 09 0c 0b 0a 0c 0f 1a 11 0f 0e 0e 0f 1f 16 18 13 ... 9752 more bytes&gt;,
    size: 9802
  }
]
</code></pre>
<p>是的，我刚刚传了一张名为 C.jpeg 的图片到服务器</p>
<h2 id="下一章-sql增删改查"><a class="header" href="#下一章-sql增删改查">下一章-Sql增删改查</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql增删改查"><a class="header" href="#sql增删改查">Sql增删改查</a></h1>
<p>本节使用knex作为sql框架，以sqlite数据库为例</p>
<h2 id="准备工作-1"><a class="header" href="#准备工作-1">准备工作</a></h2>
<p>knex是一个运行在各自数据库Driver上的框架，因此需要安装相应的js版数据库Driver，如: PostgreSQL -&gt; pg, mysql/mariadb -&gt; mysql, sqlite -&gt; sqlite3...</p>
<ul>
<li>安装sqlite3依赖 <code>npm install sqlite3</code></li>
<li>安装knex依赖 <code>npm install knex</code></li>
<li>引入依赖</li>
</ul>
<pre><code class="language-js">const app = express();
const knex = require('knex');
</code></pre>
<ul>
<li>建议安装一款合适的数据库界面工具，笔者使用的是Beekeeper Studio.</li>
</ul>
<h2 id="创建项目-1"><a class="header" href="#创建项目-1">创建项目</a></h2>
<p>拷贝第一节HelloWorld的项目</p>
<h2 id="创建sqlite连接"><a class="header" href="#创建sqlite连接">创建sqlite连接</a></h2>
<p>指明client为sqlite3（刚刚安装的sqlite3依赖），并指明要操作的sqlite数据库路径</p>
<pre><code>const sqlite = knex({
    client: 'sqlite3',
    connection: {
      filename: './data.db',
    },
});
</code></pre>
<p>创建了一个连接实例后，会自动创建一个连接池，因此初始化数据库只会发生一次</p>
<h3 id="连接配置"><a class="header" href="#连接配置">连接配置</a></h3>
<p>sqlite3默认的是单连接，如果你希望连接池有更多的连接，创建时带上pool:</p>
<pre><code class="language-js">const sqlite = knex({
    client: 'sqlite3',
    connection: {
      filename: './data.db',
    },
    pool: { min: 0, max: 7 }
});
</code></pre>
<h4 id="创建连接池的回调"><a class="header" href="#创建连接池的回调">创建连接池的回调</a></h4>
<p>用于检查连接池是否正常，通常不需要这步</p>
<pre><code>pool: {
    afterCreate: function (conn, done) {//...}
}
</code></pre>
<h4 id="acquireconnectiontimeout"><a class="header" href="#acquireconnectiontimeout">acquireConnectionTimeout</a></h4>
<p>连接超时时间</p>
<h4 id="日志"><a class="header" href="#日志">日志</a></h4>
<p>knex内置了打印警告、错误、弃用和调试信息的日志函数，如果你希望自定义日志操作，可以在log项里重写它们</p>
<pre><code class="language-JS">log: {
    warn(message) {
    },
    error(message) {
    },
    deprecate(message) {
    },
    debug(message) {
    }
}
</code></pre>
<h2 id="数据表"><a class="header" href="#数据表">数据表</a></h2>
<h3 id="建表"><a class="header" href="#建表">建表</a></h3>
<p>语法: <code>sqlite.schema.createTable(表名, table=&gt;{表结构})</code></p>
<p>添加一个PUT接口，监听 127.0.0.1:8080/db/:tbname<br />
根据我们想创建的表名尝试创建一个表，注意: sql执行是异步的，为了得到结果，建议使用 <strong>async/await</strong> 语法糖（当然你就是喜欢地狱回调也不是不行）</p>
<pre><code class="language-js">app.put('/db/:tbname', async function (req, res) {
    let resultSet = null;
    try {
        // Create a table
        resultSet = await sqlite.schema
          .createTable(req.params.tbname, table =&gt; {
            table.increments('id');
            table.string('uname');
            table.string('passwd');
          })
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>瞅瞅控制台:</p>
<pre><code class="language-bash">sqlite does not support inserting default values. Set the `useNullAsDefault` flag to hide this warning. (see docs https://knexjs.org/guide/query-builder.html#insert).
</code></pre>
<p>嗯？sqlite不支持default？不用管他，去看数据库，反正成功创建了user表，你要是加了<code>useNullAsDefault</code>这个flag，反而会告诉你<code> not supported by node-sqlite3</code></p>
<pre><code class="language-js">const sqlite = knex({
    client: 'sqlite3',
    connection: {
      filename: './data.db',
    },
});
</code></pre>
<h3 id="删表"><a class="header" href="#删表">删表</a></h3>
<p>语法: <code>sqlite.schema.deleteTable(表名)</code></p>
<pre><code class="language-js">app.delete('/db/:tbname', async function (req, res) {
    try {
        // Delete a table
        await sqlite.schema.dropTable(req.params.tbname);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
    };
    res.json(null);
});

</code></pre>
<h2 id="表记录crud"><a class="header" href="#表记录crud">表记录crud</a></h2>
<h3 id="增"><a class="header" href="#增">增</a></h3>
<p>往user表里面插入一条新的记录</p>
<pre><code class="language-js">app.use(express.json({type: 'application/json'}));
app.put('/db/:tbname/record', async function (req, res) {
    /*前端请求体格式:
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;iloveu&quot;
    }
    */
   let resultSet = null;
    try {
        // Insert a record
        resultSet = await sqlite(req.params.tbname).insert(req.body);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具PUT 127.0.0.1:8080/db/user/record，携带相应的请求体，将会得到<code>[1]</code>，这是影响的记录数，1代表成功了</p>
<h3 id="查"><a class="header" href="#查">查</a></h3>
<p>从user表里查询uname=我们刚刚插入的记录</p>
<pre><code class="language-js">app.get('/db/:tbname/record', async function (req, res) {
    //前端携带query: uname=evanp
   let resultSet = null;
    try {
        // select a record where uname=xxx
        resultSet = await sqlite(req.params.tbname).select('*').where('uname',req.query.uname);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具GET 127.0.0.1:8080/db/user/record?uname=evanp，将会得到:</p>
<pre><code class="language-json">[
    {
        &quot;id&quot;: 1,
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;iloveu&quot;
    }
]
</code></pre>
<h3 id="改"><a class="header" href="#改">改</a></h3>
<p>接下来我们修改uname=evanp这条记录的passwd为123456</p>
<pre><code class="language-js">app.post('/db/:tbname/record', async function (req, res) {
    //前端携带query: uname=evanp
    /*前端请求体格式:
    {
        &quot;passwd&quot;: &quot;123456&quot;
    }
    */
   let resultSet = null;
    try {
        // select a record where uname=xxx
        resultSet = await sqlite(req.params.tbname).update(req.body).where('uname',req.query.uname);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具POST 127.0.0.1:8080/db/user/record?uname=evanp，并携带相应请求体，将会得到: [1]，这代表影响记录1条，成功了</p>
<h3 id="删"><a class="header" href="#删">删</a></h3>
<p>接下来我们删除uname=evanp且passwd=123456的这条记录</p>
<pre><code class="language-js">app.delete('/db/:tbname/record', async function (req, res) {
    /*前端请求体格式:
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;123456&quot;
    }
    */
   let resultSet = null;
    try {
        // select a record where uname=xxx
        resultSet = await sqlite(req.params.tbname).del().where(req.body);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具DELETE 127.0.0.1:8080/db/user/record，并携带相应请求体，将会得到: [1]，这代表影响记录1条，成功了</p>
<h2 id="原生sql"><a class="header" href="#原生sql">原生sql</a></h2>
<p>当然了，如果你需要直接使用sql语句，也是可以的，调用<code>raw(sqlStr)</code>即可，既可以作为某一段sql的绑定，也可以直接当作整句sql</p>
<p>格式: <code>knex.raw(sql, [bindings]</code></p>
<pre><code class="language-json">sqlite.raw(&quot;select * from user&quot;,[1]).then((resp)=&gt;{//..})
</code></pre>
<p>在这里不做介绍</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>以上给出了使用knex实现增删改查的基本操作，这些方法并不是唯一的，在实际开发中往往要应对更复杂的场景，基础crud也是远远不够的<br />
关于knex的更多拓展使用方法，请移步knex官方文档<a href="https://knexjs.org/guide/">https://knexjs.org/guide/</a></p>
<h2 id="下一章-sql-orm增删改查"><a class="header" href="#下一章-sql-orm增删改查">下一章-Sql-ORM增删改查</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-orm增删改查"><a class="header" href="#sql-orm增删改查">Sql-ORM增删改查</a></h1>
<p>ORM框架: 对象关系映射，面对对象sql<br />
本节使用sequelize作为orm-sql框架，数据库为sqlite</p>
<h2 id="准备工作-2"><a class="header" href="#准备工作-2">准备工作</a></h2>
<p>同样的，需要安装相应的js版数据库Driver，如: PostgreSQL -&gt; pg, mysql/mariadb -&gt; mysql, sqlite -&gt; sqlite3...</p>
<ul>
<li>安装sqlite3依赖 <code>npm install sqlite3</code></li>
<li>安装sequelize依赖 <code>npm install sequelize</code></li>
<li>引入依赖</li>
</ul>
<pre><code class="language-js">const app = express();
const { Sequelize } = require('sequelize');
</code></pre>
<ul>
<li>建议安装一款合适的数据库界面工具，笔者使用的是Beekeeper Studio.</li>
</ul>
<h2 id="创建项目-2"><a class="header" href="#创建项目-2">创建项目</a></h2>
<p>拷贝第一节HelloWorld的项目</p>
<h2 id="创建sqlite连接-1"><a class="header" href="#创建sqlite连接-1">创建sqlite连接</a></h2>
<p>指定方言为sqlite，持久化路径为本目录下的data.db</p>
<pre><code class="language-js">const sqlite = new Sequelize({
    dialect: 'sqlite',
    storage: './data.db'
})
</code></pre>
<h2 id="定义表模型"><a class="header" href="#定义表模型">定义表模型</a></h2>
<p>sequelize主打一个面对对象sql，因此我们要建立一个对应数据表的类<br />
就和上一节一样，弄一张一模一样的user表吧:</p>
<ul>
<li>引入DataTypes</li>
</ul>
<pre><code>const { Sequelize,DataTypes } = require('sequelize');
</code></pre>
<ul>
<li>定义User对象</li>
</ul>
<p><code>Model.init(schema,options)</code></p>
<pre><code class="language-js">const User = sqlite.define('User', {
    id: {
        primaryKey: true,
        type: DataTypes.INTEGER,
        allowNull: false,
        autoIncrement: true
    },
    // 在这里定义模型属性
    uname: {
      type: DataTypes.STRING,
      allowNull: true
    },
    passwd: {
      type: DataTypes.STRING
      // allowNull 默认为 true
    }
  }, {
    // 直接指定表名，不指定的话sequelize将默认以模型的复数形式作为表名
    tableName: 'user'
});
</code></pre>
<p>还有另一种方法，效果是一样的，看个人喜好使用:</p>
<ul>
<li>额外引入Model</li>
</ul>
<pre><code class="language-js">const { Sequelize,DataTypes,Model } = require('sequelize');
</code></pre>
<ul>
<li>初始化User类</li>
</ul>
<p><code>Model.init(schema,options)</code></p>
<pre><code class="language-js">User继承Model类
class User extends Model {};
User.init(
    {
        id: {
            primaryKey: true,
            type: DataTypes.INTEGER,
            allowNull: false,
            autoIncrement: true
        },
        // 在这里定义模型属性
        uname: {
            type: DataTypes.STRING,
            allowNull: true,
        },
        passwd: {
            type: DataTypes.STRING，
            defaultValue: '123456', //默认值
            //allowNull 默认为 true
        }
    }, 
    {
        // 这是其他模型参数
        sqlite, // 我们需要传递连接实例
        modelName: 'User1', // 我们需要选择模型名称,
        // 直接指定表名
        tableName: 'user',
    }
);
</code></pre>
<h2 id="模型同步"><a class="header" href="#模型同步">模型同步</a></h2>
<p><code>Model.sync</code>: 底层执行的是 create table if not exist</p>
<ul>
<li>如果数据库中不存在对应的表，将根据模型直接创建表；若存在，不操作<br />
<code>Model.sync({force: true})</code>: 底层是先 drop if 然后 create</li>
<li>如果表已存在，将删除再根据模型创建表<br />
<code>Model.sync({alter: true})</code>: </li>
<li>如果表已存在，将修改表结构使之与模型匹配</li>
</ul>
<p>花里胡哨的，总之就是保证数据库中有和该模型对应的表</p>
<h2 id="创建user表"><a class="header" href="#创建user表">创建user表</a></h2>
<p>我们使用<code>User.sync()</code>创建一张user表</p>
<pre><code class="language-js">app.put('/db/user', async function (req, res) {
    let what = await User.sync();
    res.json(what);
});
</code></pre>
<p>使用api调试工具PUT 127.0.0.1:8080/db/user，将会得到1，注意只要能成功映射到到数据表都是1</p>
<p>用Beekeeper查看我们的user表，你会发现和我们定义的模型有点不一样：多了2个字段——createdAt和updatedAt，即创建时间和修改时间<br />
sequelize会自动管理这两个字段，注意当你使用了其他的sql工具修改表，这两个字段不会自动更新</p>
<p>如果你不想要这两个值，或者想换个名字，可以在定义模型时往options添加这些设置:</p>
<pre><code class="language-js">// 禁止createdAt和updatedAt
timestamps: false,
// 只禁止createdAt
createdAt: false,
// 给updatedAt换个名字
updatedAt: 'updateTime'
</code></pre>
<h2 id="删除user表"><a class="header" href="#删除user表">删除user表</a></h2>
<p>drop()方法，底层是 drop if，既可以作用于模型，也可作用于数据库:</p>
<pre><code class="language-js">sqlite.drop();  //这将删除当前data.db下所有的表
</code></pre>
<p>我们使用<code>User.drop()</code>来删除user表</p>
<pre><code class="language-js">app.delete('/db/user', async function (req, res) {
    let what = await User.drop();
    res.json(what);
});
</code></pre>
<p>使用api调试工具PUT 127.0.0.1:8080/db/user，将会得到1，注意即使表已经没了，也是1</p>
<h2 id="数据表crud"><a class="header" href="#数据表crud">数据表crud</a></h2>
<h3 id="增-1"><a class="header" href="#增-1">增</a></h3>
<p>在操作表记录前，我们先通过模型(<code>Model.build</code>)创建一个实例，然后调用<code>save()</code>将这个实例插入到表中<br />
当然，如果你从前端拿来的数据不需要进行处理和转化就能拿来用，也可以直接用<code>Model.create</code>插入记录</p>
<pre><code class="language-js">app.use(express.json({type: 'application/json'}));
app.put('/db/user/record', async function (req, res) {
    /**前端请求体
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;iloveu&quot;
    }
    */
    try {
        let user = User.build(req.body);
        let what = await user.save();
        // let what = await User.create(req.body);
        res.json(what);
    }catch(e){
        res.json(e);
    }
});
</code></pre>
<p>使用api调试工具PUT 127.0.0.1:8080/db/user/record，携带相应的请求体，将会得到:</p>
<pre><code class="language-json">{
    &quot;id&quot;: 1,
    &quot;uname&quot;: &quot;evanp&quot;,
    &quot;passwd&quot;: &quot;iloveu&quot;,
    &quot;updatedAt&quot;: &quot;2023-03-19T08:03:37.964Z&quot;,
    &quot;createdAt&quot;: &quot;2023-03-19T08:03:37.964Z&quot;
}

</code></pre>
<p>是的，添加记录成功后它会顺便把整条记录查出来作为返回结果</p>
<p>Ok，那么现在user表里已经有了id=1的一条记录了，让我们试一下创建相同id的记录会怎么样...<br />
服务器直接挂了，我们可不希望这样，这意味着有任何不妥的sql都可能导致服务器崩溃，那怎么办呢？</p>
<p>有的朋友可能记起来了，在上一节中，使用了try-catch语法糖包裹sql操作，这是一种不错的方法</p>
<h3 id="查-1"><a class="header" href="#查-1">查</a></h3>
<p>sequelize模型内置了一些方法使得我们可以基于模型直接查询</p>
<ul>
<li>findAll 查找全部，底层是<code>select * from ...</code></li>
<li>findOne 查找一个，底层是<code>select * from ... LIMIT 1</code></li>
<li>findByPk 根据主键查找</li>
<li>findAndCountAll 查找并返回符合的总条数，常用于分页</li>
<li>findOrCreate 找不到就创建</li>
</ul>
<p>这些方法都可以添加options参数设置WHERE,LIMIT等限制条件<br />
我们使用findOne来查询evanp和用户名和密码都对的上的一条记录:</p>
<pre><code class="language-js">//我为了方便直接url传参了，实际上为了隐私，至少应该放在请求体内
app.get('/db/user/record', async function (req, res) {
    let evanp = await User.findOne({where: req.query});
    res.json(evanp);
});
</code></pre>
<p>如果你只需要查询其中某些字段，就在options中设置attributes:</p>
<pre><code class="language-js">User.findAll({
    attributes: ['id','uname']
});
</code></pre>
<p>如果想给字段取别名，就比如像这样给id取名uid:</p>
<pre><code class="language-js">User.findAll({
    attributes: [['id','uid'],'uname']
});
</code></pre>
<h2 id="改-1"><a class="header" href="#改-1">改</a></h2>
<p><code>Model.update(修改项,限制)</code></p>
<pre><code class="language-js">app.post('/db/user/record', async function (req, res) {
    /*请求体
    {
        &quot;set&quot;:{
            &quot;passwd&quot;: &quot;123456&quot;
        },
        &quot;where&quot;: {
            &quot;uname&quot;: &quot;evanp&quot;,
            &quot;passwd&quot;: &quot;iloveu&quot;
        }
    }
    */
    let what = await User.update(req.body.set,{where: req.body.where})
    res.json(what);
});
</code></pre>
<p>使用api工具进行调试，修改成功将返回1，修改失败将返回0(找不到/改不了)</p>
<h2 id="删-1"><a class="header" href="#删-1">删</a></h2>
<p><code>Model.destroy(限制)</code></p>
<pre><code class="language-js">app.delete('/db/user/record', async function (req, res) {
    /*请求体
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;123456&quot;
    }
    */
    let what = await User.destroy({where: req.body})
    res.json(what);
});
</code></pre>
<p>使用api工具进行调试，删除成功将返回1，删除失败将返回0(找不到/删不了)</p>
<h2 id="原生sql-1"><a class="header" href="#原生sql-1">原生Sql</a></h2>
<p>当然了，如果你需要直接使用sql语句，也是可以的，<code>连接实例.query(sqlStr)</code>即可<br />
通常，返回结果包含2个值，一个是结果数组，一个是相关信息</p>
<pre><code class="language-js">app.post('/db/user/record/freely', async function (req, res) {
    /*json请求体
    {
        &quot;sql&quot;: &quot;xxx&quot;
    }
    */
    let what = null;
    try {
        what = await sqlite.query(req.body.sql);
    } catch (e) {
        what = e;
    }
    res.json(what);
});
</code></pre>
<p>执行insert前要注意，如果这张表是经过sequelize同步的，也许会有那两个时间字段的，别忘了</p>
<p>本节的例子仅仅为了演示在express.js中如何运用sequelize操作数据库，关于sequelize的更多拓展和高级使用方法，请移步sequelize官方文档<a href="https://www.sequelize.cn/">https://www.sequelize.cn/</a></p>
<h2 id="下一章-路由控制"><a class="header" href="#下一章-路由控制">下一章-路由控制</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="路由控制"><a class="header" href="#路由控制">路由控制</a></h1>
<h2 id="准备工作-3"><a class="header" href="#准备工作-3">准备工作</a></h2>
<p>拷贝第一节HelloWorld项目</p>
<h2 id="动态路由"><a class="header" href="#动态路由">动态路由</a></h2>
<p>这个最初我们就接触到了，路径中某一段前面加冒号</p>
<pre><code class="language-js">//路径变量-动态路由
app.get('/:var',(req, res)=&gt;{
    res.send(req.params.var);
});
</code></pre>
<h2 id="路由匹配"><a class="header" href="#路由匹配">路由匹配</a></h2>
<p>利用通配符 * 匹配符合的所有路由</p>
<ul>
<li>全通配</li>
</ul>
<p><strong>定义时</strong>，以 * 结尾，或者 * 之后除了斜杠没有其他字符，匹配*之后所有的路由</p>
<pre><code class="language-js">//全部匹配，囊括了match之下的所有路由，即便前端请求路径时在后面再来几段，也会被当作一个字符串 /x/1/6 -&gt; '/x/1/6'
//慎用，必须确保其他独立的路由不会被覆盖了
app.get('/matchall/*',(req, res)=&gt;{
    let what = {
        params: req.params,
        theVar: req.params['0']
    }
    res.send(what);
});
</code></pre>
<p>前端发来请求时，如何有2个定义的接口都能匹配到，优先匹配先定义的</p>
<pre><code class="language-js">//不起效
app.get('/matchall/w/xf',(req, res)=&gt;{
    res.send(&quot;there is w.xf&quot;);
});
</code></pre>
<ul>
<li>局部通配</li>
</ul>
<p>在两个字符之间(斜杠不算，除非你转义过了)使用 *，匹配这两个字符中间夹任何一段字符串的路由:<br />
xAy,xBy,xvenapy...</p>
<pre><code class="language-js">//xy中间随便夹
app.get('/match/x*y', function (req, res) {
    res.send('xy肉夹馍')
})
</code></pre>
<pre><code class="language-js">//除非通配符后面有除了斜杠以外的字符，不然全部被盖
app.get('/match/w*/x', function (req, res) {
    res.send('除非通配符后面有除了斜杠以外的字符，不然全部被盖')
})
</code></pre>
<ul>
<li>动态字符(串)</li>
</ul>
<p>问号前的字符可有可无，gback,goback</p>
<pre><code class="language-js">//问号前面这个字符可有可无
app.get('/match/go?back',(req, res)=&gt;{
    res.send(&quot;问号前面这个字符可有可无&quot;);
});
</code></pre>
<p>问号前被括号括住的字符串可有可无，xback,xgoback</p>
<pre><code class="language-js">app.get('/match/x(go)?back',(req, res)=&gt;{
    res.send(&quot;问号前面这个字符串可有可无，注意被括住的字符串前面不能没有字符&quot;);
});
</code></pre>
<p>加号前的字符可以重复，goback,gooback,goooback...</p>
<pre><code class="language-js">//可匹配到多个路由时，优先匹配先定义的路由
//一个或多个问号前字符
app.get('/match/go+back',(req, res)=&gt;{
    let what = {
        match: '/match/go+back',
        url: req.url,
        tip: &quot;加号前面的那个字符可以无限重复&quot;
    }
    res.send(what);
});
</code></pre>
<h2 id="正则匹配"><a class="header" href="#正则匹配">正则匹配</a></h2>
<p>可用于复杂路由的匹配，在路由中局部正则时，记得用括号包住</p>
<pre><code class="language-js">//正则匹配
//匹配了127.0.0.1:8080/x//数字useremm//
app.get('/x/(\/[0-9]useremm\/)', function (req,res) {
    console.log(req.body);
    res.send(&quot;正则可用于复杂路径的匹配&quot;);
})
</code></pre>
<h2 id="路由重定向"><a class="header" href="#路由重定向">路由重定向</a></h2>
<p>有时候我们希望某些情况下将路径转发到其他路径，比如404页面之类的<br />
格式: <code>res.redirect(status, url)</code><br />
status是干什么的？对于重定向后的路由不同的请求方法应该使用不同的status:</p>
<ul>
<li>GET</li>
</ul>
<pre><code class="language-js">//转发到 GET /1/2/3/4/5
app.post('/redirect',(req,res)=&gt;{
    res.redirect(301,'/1/2/3/4/5');
});

app.get('/1/2/3/4/5',(req,res)=&gt;{
    res.send(&quot;上山打老虎&quot;);
})
</code></pre>
<p>301或302都是可以的，301代表临时，302代表永久</p>
<p>接下来我们把转发后的路由改成POST，再去访问redirect:</p>
<pre><code class="language-js">app.post('/1/2/3/4/5',(req,res)=&gt;{
    res.send(&quot;上山打老虎&quot;);
})
</code></pre>
<p>是的，响应不到了，转发到POST路由，应当使用307或308，前者临时后者永久<br />
<code>res.redirect(301,'/1/2/3/4/5');</code></p>
<ul>
<li>JSON与重定向</li>
</ul>
<p>开启<code>app.use(express.json)</code>，再尝试访问redirect，结果又得不到响应了，这是为什么？<br />
开启了json解析后，请求变成了json，请求已经不是原始的请求了，变成了json对象，是没办法被转发的<br />
因此在有需要重定向的时候，我们不应该全局json解析了，而是在需要json解析的路由上开启json解析:</p>
<p>建个需要使用json解析的测试接口:</p>
<pre><code class="language-js">app.put('/some/json',(req,res)=&gt;{
    res.send(req.body);
});
</code></pre>
<p>自定义一个选择性body-json的中间件，判定 PUT:/some/json 时局部开启json解析:</p>
<pre><code class="language-js">app.use((req, res, next) =&gt; {
    // 判断当前请求路径是否需要解析JSON请求体
    if (req.path === '/some/json'&amp;&amp; req.method.match(&quot;PUT&quot;)) {
      bodyParser.json()(req, res, next);
    } else {
      next();
    }
});
</code></pre>
<p>尝试用api调试工具访问redirect，重定向成功了，再访问/some/json，也能成功打印请求体.</p>
<h2 id="下一章-jwt基础鉴权"><a class="header" href="#下一章-jwt基础鉴权">下一章-JWT基础鉴权</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jwt基础鉴权"><a class="header" href="#jwt基础鉴权">JWT基础鉴权</a></h1>
<h2 id="下一章-全局错误处理"><a class="header" href="#下一章-全局错误处理">下一章-全局错误处理</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局错误处理"><a class="header" href="#全局错误处理">全局错误处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中间件"><a class="header" href="#中间件">中间件</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="架构整合"><a class="header" href="#架构整合">架构整合</a></h1>
<p>在第一章中，我们按功能分块学习了express后端中不同方面的技术，所有的代码基本都写在了一个文件中，在实际开发中这是不符合规范的，我们需要有一个合理的目录结构，在本章中，将结合常见的前后端架构思想，express.js特性以及借鉴其他语言的优秀框架的架构，每节介绍一种架构方式</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
