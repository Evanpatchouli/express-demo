<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>跟着例子学Express.js</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">模块化学习</li><li class="chapter-item expanded "><a href="chapter_1/intro.html"><strong aria-hidden="true">1.</strong> 本章简介</a></li><li class="chapter-item expanded "><a href="chapter_1/HelloWorld.html"><strong aria-hidden="true">2.</strong> HelloWorld</a></li><li class="chapter-item expanded "><a href="chapter_1/请求类型.html"><strong aria-hidden="true">3.</strong> 请求类型</a></li><li class="chapter-item expanded "><a href="chapter_1/处理请求数据.html"><strong aria-hidden="true">4.</strong> 处理请求数据</a></li><li class="chapter-item expanded "><a href="chapter_1/响应.html"><strong aria-hidden="true">5.</strong> 响应</a></li><li class="chapter-item expanded "><a href="chapter_1/knex增删改查.html"><strong aria-hidden="true">6.</strong> Sql-knex增删改查</a></li><li class="chapter-item expanded "><a href="chapter_1/ORM增删改查.html"><strong aria-hidden="true">7.</strong> Sql-ORM增删改查</a></li><li class="chapter-item expanded "><a href="chapter_1/路由控制.html"><strong aria-hidden="true">8.</strong> 路由控制</a></li><li class="chapter-item expanded "><a href="chapter_1/JWT基础鉴权.html"><strong aria-hidden="true">9.</strong> JWT基础鉴权</a></li><li class="chapter-item expanded "><a href="chapter_1/全局错误处理.html"><strong aria-hidden="true">10.</strong> 全局错误处理</a></li><li class="chapter-item expanded "><a href="chapter_1/中间件.html"><strong aria-hidden="true">11.</strong> 中间件</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">架构整合</li><li class="chapter-item expanded "><a href="chapter_2/intro.html"><strong aria-hidden="true">12.</strong> 本章简介</a></li><li class="chapter-item expanded "><a href="chapter_2/express-cli.html"><strong aria-hidden="true">13.</strong> express-cli</a></li><li class="chapter-item expanded "><a href="chapter_2/MVC层级架构.html"><strong aria-hidden="true">14.</strong> MVC层级架构</a></li><li class="chapter-item expanded "><a href="chapter_2/分布式结构.html"><strong aria-hidden="true">15.</strong> 分布式结构</a></li><li class="chapter-item expanded "><a href="chapter_2/微服务架构.html"><strong aria-hidden="true">16.</strong> 微服务架构</a></li><li class="chapter-item expanded "><a href="chapter_2/evp-express-cli.html"><strong aria-hidden="true">17.</strong> evp-express-cli</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">高级进阶</li><li class="chapter-item expanded "><a href="chapter_3/intro.html"><strong aria-hidden="true">18.</strong> 本章简介</a></li><li class="chapter-item expanded "><a href="chapter_3/全局变量与配置文件.html"><strong aria-hidden="true">19.</strong> 全局变量与配置文件</a></li><li class="chapter-item expanded "><a href="chapter_3/错误分类和日志分级.html"><strong aria-hidden="true">20.</strong> 错误分类和日志分级</a></li><li class="chapter-item expanded "><a href="chapter_3/数据库初始化.html"><strong aria-hidden="true">21.</strong> 数据库初始化</a></li><li class="chapter-item expanded "><a href="chapter_3/页面渲染.html"><strong aria-hidden="true">22.</strong> 页面渲染</a></li><li class="chapter-item expanded "><a href="chapter_3/express-validator.html"><strong aria-hidden="true">23.</strong> express-validator</a></li><li class="chapter-item expanded "><a href="chapter_3/使用zod检验.html"><strong aria-hidden="true">24.</strong> 使用zod检验</a></li><li class="chapter-item expanded "><a href="chapter_3/集成redis.html"><strong aria-hidden="true">25.</strong> 集成Redis</a></li><li class="chapter-item expanded "><a href="chapter_3/集成rabbitmq.html"><strong aria-hidden="true">26.</strong> 集成RabbitMQ</a></li><li class="chapter-item expanded "><a href="chapter_3/集成websocket.html"><strong aria-hidden="true">27.</strong> 集成Websocket</a></li><li class="chapter-item expanded "><a href="chapter_3/集成SocketIO.html"><strong aria-hidden="true">28.</strong> 集成SocketIO</a></li><li class="chapter-item expanded "><a href="chapter_3/全面鉴权.html"><strong aria-hidden="true">29.</strong> 全面鉴权</a></li><li class="chapter-item expanded "><a href="chapter_3/软件测试.html"><strong aria-hidden="true">30.</strong> 软件测试</a></li><li class="chapter-item expanded "><a href="chapter_3/软件构建.html"><strong aria-hidden="true">31.</strong> 软件构建</a></li><li class="chapter-item expanded "><a href="chapter_3/Docker部署.html"><strong aria-hidden="true">32.</strong> Docker部署</a></li><li class="chapter-item expanded "><a href="chapter_3/pm2进程管理.html"><strong aria-hidden="true">33.</strong> pm2进程管理</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">最佳实践</li><li class="chapter-item expanded "><a href="chapter_4/代码规范.html"><strong aria-hidden="true">34.</strong> 代码规范</a></li><li class="chapter-item expanded "><a href="chapter_4/高性能.html"><strong aria-hidden="true">35.</strong> 高性能</a></li><li class="chapter-item expanded "><a href="chapter_4/安全性.html"><strong aria-hidden="true">36.</strong> 安全性</a></li><li class="chapter-item expanded "><a href="chapter_4/健康检查.html"><strong aria-hidden="true">37.</strong> 健康检查</a></li><li class="chapter-item expanded affix "><a href="后记.html">后记</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">跟着例子学Express.js</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="跟着例子学expressjs"><a class="header" href="#跟着例子学expressjs">跟着例子学express.js</a></h1>
<p>撰写本书的起因，是我的一个同事有学习node后端的意愿，加之node在我手里落灰已久，于是决定趁着这个机会好好梳理一下，在空闲之余谱一份还算简明的渐进式教程，希望能对各位朋友以及未来又淡忘了express的自己有所帮助.</p>
<p>express-demo，跟着例子学express，先按不同的功能分块学习express.js，从路由，接口，数据库，鉴权等等一块一块地进行分布式的基础学习，等有了较为完备的基础，根据一定的架构思想形成一个完整的express.js后端，最后再介绍一些可能用得到的进阶技巧.</p>
<h4 id="源码"><a class="header" href="#源码">源码</a></h4>
<p>仓库有着每一节教程中的完整源码，在阅读本书时，请务必配合源码食用，动手是最好的老师！</p>
<h4 id="进度"><a class="header" href="#进度">进度</a></h4>
<p>当前本书进度65%，敬请期待</p>
<h4 id="合作"><a class="header" href="#合作">合作</a></h4>
<p>如本书或者源码有任何的纰漏或者错误，欢迎指正，谢谢！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块化学习"><a class="header" href="#模块化学习">模块化学习</a></h1>
<p>本章将express分为不同的模块进行独立学习，主要分为以下几方面:</p>
<ul>
<li>处理请求</li>
<li>处理响应</li>
<li>路由/接口</li>
<li>数据库</li>
<li>中间件</li>
</ul>
<p>通常来说，建议按从前到后的顺序依次学习，有层层递进的关系。 当有了全面的了解之后，应当就初步具备了写基于 express.js 的完整项目(后端)的能力于水准。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>本节我们将创建并运行我们的第一个express.js项目，并使用最简单的请求响应</p>
<h2 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h2>
<ul>
<li>本书系统环境为 <strong>windows10 64Bit</strong></li>
<li>请事先在你的开发环境中安装 <strong>Node.js</strong>，本书使用的是 <strong>node v16.17.1</strong></li>
<li>推荐使用 <strong>VsCode</strong> 作为开发工具，有良好的代码提示功能</li>
<li>事先安装一个api调试工具，如 <strong>postman</strong>, <strong>apipost</strong>等</li>
</ul>
<h2 id="创建项目"><a class="header" href="#创建项目">创建项目</a></h2>
<ol>
<li>创建一个文件夹作为项目根目录</li>
<li>下载express依赖<br />
在根目录下执行<code>npm install express</code></li>
<li>下载js-text-chart依赖<br />
在根目录下执行<code>npm install js-text-chart</code>，这是一个用于输出字符画的js库，本书在每一个示例中都使用了该库充当starter</li>
<li>在根目录下新建一个入口文件，如<strong>index.js</strong></li>
<li>在入口文件中引入依赖</li>
</ol>
<pre><code class="language-js">const express = require('express');
const evchart = require('js-text-chart').evchart;
</code></pre>
<h2 id="创建服务器"><a class="header" href="#创建服务器">创建服务器</a></h2>
<ol>
<li>先创建一个express实例</li>
</ol>
<pre><code class="language-js">const app = express();
</code></pre>
<ol start="2">
<li>创建服务器</li>
</ol>
<p>让我们刚刚创建的app实例挂载到指定的端口，如8080</p>
<pre><code class="language-js">const server = app.listen(8080);
</code></pre>
<ol start="3">
<li>添加服务器运行后的回调函数</li>
</ol>
<p>是指在服务器成功运行后的一系列操作，常用于输出信息和初始化等，我在这里打印该项目的基本信息<br />
我使用的是内联箭头函数 &quot;()=&gt;{//...}&quot;，也可以替换为普通的&quot;function {//...}&quot;</p>
<pre><code class="language-js">const server = app.listen(8080, () =&gt; {
    let host = server.address().address;
    let port = server.address().port;

    let str = &quot;EXPRESS-DEMO&quot;;
    let mode = [ &quot;close&quot;, &quot;far&quot;, undefined ];
    let chart = evchart.convert(str, mode[0]);
    console.log(chart);

    console.log(&quot;Server is ready on http://%s:%s&quot;, host, port);
})
</code></pre>
<ol start="4">
<li>跨域策略</li>
</ol>
<p>默认情况下可能不允许不同域名下进行交互，我们对请求进行一些基本的设置，允许跨域和所有的请求方式请求头格式化，并设置请求头内容为json格式</p>
<pre><code class="language-js">app.all(&quot;*&quot;, function (req, res, next) {
    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;);
    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);
    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);
    next();
});
</code></pre>
<h2 id="第一个接口"><a class="header" href="#第一个接口">第一个接口</a></h2>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<p>前后端交互是在后端暴露的接口进行的，而不同的接口对于后端端口上不同的url路径。前端使用不同的方式（GET,POST...）请求指定的路径，当后端有定义监听某种方式下的某种路径接口时，获取请求携带的数据，对请求进行处理，并返回结果给前端 </p>
<h3 id="实践"><a class="header" href="#实践">实践</a></h3>
<p>接下来，我们将添加一个以服务器的根路径（GET）作为返回欢迎信息的接口</p>
<pre><code class="language-js">app.get('/', function (req, res) {
    res.send('Hello World!');
});
</code></pre>
<p>以上代码，app实例<strong>监听</strong> <strong>localhost:8080/</strong> 路径的<strong>GET</strong>请求，传入2个参数，第一个是请求，第二个是响应<br />
当接收到以GET方式访问该接口的请求时，通过在回调函数中执行<code>res.send</code>返回 Hello World!</p>
<h3 id="测试接口"><a class="header" href="#测试接口">测试接口</a></h3>
<p>使用接口测试工具，以GET的形式访问localhost:8080/试试吧！你将会得到一句 Hello World!</p>
<h2 id="第二个接口"><a class="header" href="#第二个接口">第二个接口</a></h2>
<p>第一个接口，我们只是单纯的访问了接口，没有传输任何数据，接下来我们将创建一个以传统的路径请求参数（如: url?id=1）携带数据的接口</p>
<h3 id="实践-1"><a class="header" href="#实践-1">实践</a></h3>
<p>定义一个GET形式，路径为 /get 的接口，传入2个参数请求和响应，我们在回调函数中通过<code>req.query</code>来获取路径上的所有请求参数，并将这些参数作为接口的返回值</p>
<pre><code class="language-js">app.get('/get', function (req, res) {
    let requestParams = req.query;
    res.send(requestParams);
});
</code></pre>
<h3 id="测试接口-1"><a class="header" href="#测试接口-1">测试接口</a></h3>
<p>使用接口测试工具，以GET的形式访问 localhost:8080/get?id=1&amp;name=evanp 试试吧！你将会得到这两个参数!</p>
<h2 id="下一节-请求类型"><a class="header" href="#下一节-请求类型">下一节-请求类型</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="请求类型"><a class="header" href="#请求类型">请求类型</a></h1>
<p>本节将介绍常见的http请求方式，并站在后端的角度初步感受它们的不同点</p>
<h2 id="各类http请求"><a class="header" href="#各类http请求">各类Http请求</a></h2>
<ul>
<li><strong>GET</strong><br />
意图是<strong>获取</strong>，不会对服务器上的数据产生影响，将要携带的数据放在<strong>URL</strong>上，通常不带请求体，带了也不一定兼容</li>
<li><strong>POST</strong><br />
意图是<strong>提交</strong>，通常用于修改和新增服务器上的数据，偏向<strong>新增</strong>，路径定位较模糊，要携带的数据通常放在<strong>请求体</strong>内</li>
<li><strong>PUT</strong><br />
类似POST，偏向<strong>更新</strong>，路径定位更明确，要携带的数据通常放在<strong>请求体</strong>内<br />
★ <strong>幂等性</strong>：连续PUT请求后，效果应当只有一次，而POST则会创建多个新资源，不过在REST风格下以及在后台有严格的检验情况下其实这些区别可以忽略<br />
★ <strong>缓存机制</strong>：由于PUT的幂等性，不存在缓存，而POST是缓存的，比如你在表单里用POST，不设置提交后清除，刷新页面它会将之前的数据再提交一遍</li>
<li><strong>DELETE</strong><br />
意图是删除，从服务器上删除某些数据</li>
<li><strong>HEAD</strong><br />
类似GET，但争对它的响应没有body，只有响应头，常用于判断资源是否存在、链接有效性等</li>
<li><strong>OPTIONS</strong><br />
意图是询问当前URL允许的请求方法等，常用于跨域请求前的预检和获取服务器的安全控制信息等</li>
<li><strong>TRACE</strong><br />
路径追踪，回显请求，常用于测试阶段</li>
<li><strong>PATCH</strong><br />
PUT的超类，指定资源的局部更新</li>
<li><strong>COPY</strong><br />
请求将页面拷贝到另一个URL，常用于Web资源的备份</li>
<li><strong>MOVE</strong><br />
请求将页面移动到另一个URL，常用于Web资源的搬迁</li>
<li><strong>LINK</strong><br />
请求与服务器建立链接</li>
<li><strong>UNLINK</strong><br />
断开与服务器的链接</li>
</ul>
<p>其中 GET, POST 最为广泛使用，同时可以使用PUT和DELETE让我们的接口的目的更具有指向性<br />
本书绝大部分接口都将采用类REST风格，即普遍的返回码200，数据格式为json</p>
<h2 id="express处理不同的请求"><a class="header" href="#express处理不同的请求">express处理不同的请求</a></h2>
<p>通过调用get,post,pu,delete...对应不同方法下的路由<br />
由于实际受不同的开发规范和业务环境影响，在这里只以GET和POST举例</p>
<h3 id="get请求"><a class="header" href="#get请求">get请求</a></h3>
<pre><code class="language-js">//省略了express项目的创建
class Item {
    constructor(name, value) {
      this.name = name;
      this.value = value;
    }
}

//get接口
app.get('/request', function (req, res) {
    let result = [];
    result.push(new Item(&quot;baseUrl&quot;,req.baseUrl));
    result.push(new Item(&quot;fresh&quot;,req.fresh));   //请求是否存活
    result.push(new Item(&quot;hostname&quot;,req.hostname)); //请求源域名
    result.push(new Item(&quot;ip&quot;,req.ip)); //请求源IP
    result.push(new Item(&quot;originalUrl&quot;,req.originalUrl));
    result.push(new Item(&quot;params&quot;,req.path));   //路径参数: /x/y/z/
    result.push(new Item(&quot;protocol&quot;,req.protocol)); //请求协议
    result.push(new Item(&quot;query&quot;,req.query));   //查询参数
    result.push(new Item(&quot;route&quot;,req.route));   //请求路由
    result.push(new Item(&quot;is:Content-Type&quot;,req.is('application/json')));

    res.send(result);
});
</code></pre>
<p>以上代码，定义了GET接口，并返回了关于请求的大部分信息</p>
<h3 id="测试接口-2"><a class="header" href="#测试接口-2">测试接口</a></h3>
<p>使用api调试工具，尝试用不同的携带数据方法以get形式访问该接口，比较不同的返回结果</p>
<h3 id="post请求"><a class="header" href="#post请求">post请求</a></h3>
<p>监听相同路径的post请求，开启json解析，一会我们调试时请求体采用最常用的json格式</p>
<pre><code class="language-js">//启用json解析
app.use(express.json({type: 'application/json'}));

app.post('/post', function (req, res) {
    let result = [];
    result.push(new Item(&quot;baseUrl&quot;,req.baseUrl));
    result.push(new Item(&quot;fresh&quot;,req.fresh));
    result.push(new Item(&quot;hostname&quot;,req.hostname));
    result.push(new Item(&quot;ip&quot;,req.ip));
    result.push(new Item(&quot;originalUrl&quot;,req.originalUrl));
    result.push(new Item(&quot;params&quot;,req.path));
    result.push(new Item(&quot;protocol&quot;,req.protocol));
    result.push(new Item(&quot;query&quot;,req.query));
    result.push(new Item(&quot;body&quot;,req.body));
    result.push(new Item(&quot;route&quot;,req.route));
    result.push(new Item(&quot;is:Content-Type&quot;,req.is('application/json')));

    res.send(result);
});
</code></pre>
<h3 id="测试接口-3"><a class="header" href="#测试接口-3">测试接口</a></h3>
<p>使用api调试工具，尝试用不同的携带数据方法以post形式访问该接口，比较不同的返回结果</p>
<h3 id="不限方法"><a class="header" href="#不限方法">不限方法</a></h3>
<p>如果你想让某个路由能以任意方法访问:</p>
<pre><code class="language-js">app.use('/any', function (req, res) {
    res.send('Bad World!');
});
</code></pre>
<p>尝试使用各种方法去访问 127.0.0.1:8080/any，都可以得到Bad World!</p>
<h2 id="下一节-处理请求数据"><a class="header" href="#下一节-处理请求数据">下一节-处理请求数据</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="处理请求数据"><a class="header" href="#处理请求数据">处理请求数据</a></h1>
<p>本节将具体介绍express后端处理请求源携带数据的一些方法和技巧</p>
<h2 id="动态路径"><a class="header" href="#动态路径">动态路径</a></h2>
<p>很多时候我们需要处理一些类似但有操作差别或不同对象的业务，我们可以监听一段基本路径，将其中某一个段或者某几段路径作为变量，在接口中根据不同的路径变量执行不同的业务操作，这是一种REST风格比较鲜明的动态接口设计策略</p>
<h3 id="实践-2"><a class="header" href="#实践-2">实践</a></h3>
<p>由于post也可以url传参，本节所有实例均采用post请求 </p>
<h4 id="第一个接口-1"><a class="header" href="#第一个接口-1">第一个接口</a></h4>
<p>这个接口以 /request/data/ 作为基路由，之后的kind变化的，在接口内部根据kind的值进行分支化处理。我指定了kind的3个值：PathVarible, RequestParam 和 body.<br />
所有的路径参数则可以由<code>req.params</code>（大概是个json对象）来获取，我要指定获取kind的值，就req.params.kind，而静态路径变量的值就等于它名字.</p>
<pre><code class="language-js">//忽略了express项目的创建和基本配置
class Item {
    constructor(name, value) {
      this.name = name;
      this.value = value;
    }
}
//启用json解析请求体
app.use(express.json({type: 'application/json'}));
app.post('/request/data/:kind', function (req, res) {
    let result = [];
    if (req.params.kind == 'PathVarible') {
        result.push(new Item(&quot;lesson&quot;,&quot;路径变量&quot;));
        result.push(new Item(&quot;info&quot;,&quot;在express中叫做params，路径上每个被双单斜杠'/'隔开的一个个词语就是路径参数，当你需要在同一个接口内动态响应不同的情景时，可以让某一处或多出的路径参数前面加上一个冒号，长得比较像vue中的动态绑定，动态路径在REST风格上被广泛运行，比如操作某个用户: 'user/:id =&gt; 'user/1&quot;))
    } else if (req.params.kind == 'RequestParam') {
        result.push(new Item(&quot;lesson&quot;,&quot;请求参数&quot;));
        result.push(new Item(&quot;info&quot;,&quot;在express中叫做query，和路径变量相比，前者更像是前端主动携带参数去访问特定的资源，而后者更像是后端要求必须携带的数据，前端被迫携带，反应在路径上形式一般是: '/stu?class=2&amp;sid=1&amp;name='evanp',在基本路径之后添上一个问号，然后在后面加上请求的参数，不同参数之间用'&amp;'符号隔开&quot;))
    } else if (req.params.kind == 'body') {
        result.push(new Item(&quot;lesson&quot;,&quot;请求体&quot;));
        result.push(new Item(&quot;info&quot;,&quot;路径变量和请求参数的数据都是透明的，这非常不注重隐私，因此更多时候前端应该将携带的数据放在请求体内进行传输。请求体的形式有很多，最常用的是表单和JSON，请在路径后新增一个路径变量，form-urlencode, multi-form-data或json导向不同的接口进行查看&quot;));
    } else {
        result.push(new Item(&quot;error&quot;,&quot;这个参数不认识&quot;));
    }
    res.send(result);
});
</code></pre>
<h4 id="接口测试"><a class="header" href="#接口测试">接口测试</a></h4>
<p>请使用接口调试工具，带上路径查询参数(query)，然后修改不同的kind为不同的值，去POST访问 localhost:8080/request/data/kind，看看它们的返回结果，注意kind前不要加冒号了，冒号是用来让express知道这段路径是可变的</p>
<h4 id="第二个接口-1"><a class="header" href="#第二个接口-1">第二个接口</a></h4>
<p>当第一个接口的某一个分支还可以有后续的操作时，可以再开一个接口以它作为基路由，往后新增动态路径，比如我现在要让body可以再导向不同的分支，就再开一个 /request/data/body/:kind 接口</p>
<pre><code class="language-js">app.post('/request/data/body/:kind', function (req, res) {
    let result = [];
    if (req.params.kind == 'json') {
        result.push(new Item(&quot;lesson&quot;,&quot;json请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
        result.push(new Item(&quot;info&quot;,&quot;express想解析json形式的body，必须先开启express.json: 'app.use(express.json)'，之后就可以用req.body来接收请求体了&quot;));
        result.push(new Item(&quot;trick&quot;,&quot;进阶技巧，读取请求体时可以用match模式匹配成自己想要的格式或命名，常用于实体注入及转化等&quot;));
    } else if (req.params.kind == 'form-urlencode') {
        result.push(new Item(&quot;lesson&quot;,&quot;form-urlencode请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
    } else if (req.params.kind == 'multi-form-data') {
        result.push(new Item(&quot;lesson&quot;,&quot;multi-form-data请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
    } else {
        result.push(new Item(&quot;error&quot;,&quot;这个参数不认识&quot;));
    }
    res.send(result);
});
</code></pre>
<h4 id="接口测试-1"><a class="header" href="#接口测试-1">接口测试</a></h4>
<p>请使用接口调试工具，带上JSON请求体，去POST访问 localhost:8080/request/data/body/kind，修改不同的kind，看看它们的返回结果</p>
<h2 id="获取路径参数"><a class="header" href="#获取路径参数">获取路径参数</a></h2>
<h3 id="基础"><a class="header" href="#基础">基础</a></h3>
<p>路径参数是指 '/url?id=1&amp;name=evanp' 这种url中的id和name，是明文的不具有隐私性<br />
可以通过 <code>req.query</code>获取</p>
<pre><code class="language-js">app.post('/request/data/query/info',checkQuery, (req, res)=&gt; {
    res.send(req.query);
});
</code></pre>
<p>尝试用接口调试工具访问 localhost:8080/request/data/query/info，并携带上任意的query参数</p>
<h3 id="query预检"><a class="header" href="#query预检">Query预检</a></h3>
<p>在实际场景中，每个接口会指定需要哪些名字的query参数，假设上面的接口需要id和name，则需要保证前端确实给接口传递了这两个query参数，express没有像springboot那样在入参的时候就可以规定检验，我们必须亲自对传过来的query进行检验。而这部分检验的操作不建议包含在我们接口的主体回调函数内，而应作为一个<strong>中间件</strong>，在回调之前就完成检验:</p>
<p>定义一个检查query的函数，判断是否有id和name，是的话继续，不是的话直接返回错误信息</p>
<pre><code class="language-js">function checkQuery(req,res,next) {
    if (req.query.id == undefined ||
        req.query.id == null ||
        req.query.name == undefined ||
        req.query.name == null){
        res.send({&quot;msg&quot;: &quot;query不齐全&quot;});
    } else {
        next();
    }
}
</code></pre>
<p>在接口入参时引入该中间件函数</p>
<pre><code class="language-js">app.post('/request/data/query/info',checkQuery, (req, res)=&gt; {
    res.send(req.query);
});
</code></pre>
<p>尝试用接口调试工具访问 localhost:8080/request/data/query/info，并比较不携带id,name和携带了id,name的返回结果</p>
<h2 id="获取请求体"><a class="header" href="#获取请求体">获取请求体</a></h2>
<h3 id="json请求体"><a class="header" href="#json请求体">JSON请求体</a></h3>
<p>引入以下代码一次即可</p>
<pre><code class="language-js">app.use(express.json({type: 'application/json'}));
</code></pre>
<h3 id="表单x-www-form-urlencoded"><a class="header" href="#表单x-www-form-urlencoded">表单（x-www-form-urlencoded）</a></h3>
<p><strong>x-www-form-urlencode</strong>将表单数据编码为URL形式的字符串</p>
<p>引入以下代码一次即可</p>
<pre><code class="language-js">app.use(express.urlencoded({extended: true}));
</code></pre>
<p>关于extended参数，是指将（URL编码字符串形式的）表单数据解析为简单对象还是深度嵌套对象.<br />
什么意思呢？就比如当extended=false时，表单里是这么传数据的: 
其中，有两个相同的键名: 比如传了2个x
解析后该字段的指将是所有它们的值的数组集合：<code>x=1&amp;x=2</code> -&gt; <code>{'x': ['1','2']}</code>，即便2个x都为1，也是数组: <code>{'x': ['1','1']}</code><br />
其中，又有的键名是以对象属性格式传递的，比如下图的user[uname]:
<img src="https://evan-oss-bucket1.oss-cn-hangzhou.aliyuncs.com/express-demo/x-form.png" alt="表单传嵌套对象" />
假如我们在api调试工具访问之前那个body/form-urlencode接口，同时以表单方式传输了这两种情况的数据，将得到这样的返回结果: </p>
<pre><code class="language-json">[
    {
        &quot;name&quot;: &quot;lesson&quot;,
        &quot;value&quot;: &quot;form-urlencode请求体&quot;
    },
    {
        &quot;name&quot;: &quot;body&quot;,
        &quot;value&quot;: {
            &quot;user[uname]&quot;: &quot;evanp&quot;,
            &quot;user[passwd]&quot;: &quot;iloveu&quot;,
            &quot;x&quot;: [
                &quot;1&quot;,
                &quot;2&quot;
            ]
        }
    }
]
</code></pre>
<p>当extended=true时，则是:</p>
<pre><code class="language-json">[
    {
        &quot;name&quot;: &quot;lesson&quot;,
        &quot;value&quot;: &quot;form-urlencode请求体&quot;
    },
    {
        &quot;name&quot;: &quot;body&quot;,
        &quot;value&quot;: {
            &quot;user&quot;: {
                &quot;uname&quot;: &quot;evanp&quot;,
                &quot;passwd&quot;: &quot;iloveu&quot;
            },
            &quot;x&quot;: [
                &quot;1&quot;,
                &quot;2&quot;
            ]
        }
    }
]
</code></pre>
<p>通过对比我们可以发现，<code>extended=false</code>时express比较憨，不会智能解析user到一个对象上去；智能解析的用处，我想大概是省的我们手动一条条注入属性到对象上去了</p>
<h4 id="表单验证"><a class="header" href="#表单验证">表单验证</a></h4>
<p>对于请求参数我们有验证的需求，同样的，表单验证自然也会有，甚至可能需求性更高，因为需要考虑到安全问题<br />
如果没有什么特殊要求，可以自己写一个中间件函数来检查表单，如果有比较高级的需求，可以借助线程的js库，如<strong>express-validator</strong>等</p>
<h2 id="表单multi-form-data"><a class="header" href="#表单multi-form-data">表单（multi-form-data）</a></h2>
<p>这个是可以一边传字符串，还可以传文件的表单，其实就是基础表单的一个升级版</p>
<p>需要事先安装<strong>multer</strong>依赖: <code>npm install multer</code><br />
引入依赖中间件: </p>
<pre><code class="language-js">const multer = require('multer');
const uploads = multer();
</code></pre>
<p>在需要接收文件的接口引入该中间件uploads:</p>
<pre><code class="language-js">app.post('/request/data/body/:kind', uploads.any(), function (req, res) 
</code></pre>
<p>在主体回调函数中通过<code>req.files</code>可以获取到所有的文件:</p>
<pre><code class="language-js">console.log(req.files); //写在multi-form-data分支下，方便区分
</code></pre>
<h3 id="测试接口-4"><a class="header" href="#测试接口-4">测试接口</a></h3>
<p>使用api调试工具的复合表单携带文件发送请求到 body/multi-form-data 接口，查看我们的控制台:</p>
<pre><code class="language-bash">[
  {
    fieldname: 'file',
    originalname: 'C.jpeg',
    encoding: '7bit',
    mimetype: 'image/jpeg',
    buffer: &lt;Buffer ff d8 ff e0 00 10 4a 46 49 46 00 01 01 01 00 48 00 48 00 00 ff db 00 43 00 0a 07 08 09 08 06 0a 09 08 09 0c 0b 0a 0c 0f 1a 11 0f 0e 0e 0f 1f 16 18 13 ... 9752 more bytes&gt;,
    size: 9802
  }
]
</code></pre>
<p>是的，我刚刚传了一张名为 C.jpeg 的图片到服务器</p>
<h2 id="下一节-响应"><a class="header" href="#下一节-响应">下一节-响应</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="响应"><a class="header" href="#响应">响应</a></h1>
<p>上一节讲完了请求，这一节我们就来讲一下响应吧！<br />
本节作为初级内容，将罗列比较常用的响应方法以及其简单的使用形态</p>
<h2 id="准备工作-1"><a class="header" href="#准备工作-1">准备工作</a></h2>
<p>拷贝第一节Hello World项目</p>
<h2 id="status"><a class="header" href="#status">status</a></h2>
<p><strong>res.statue(status code)</strong>，这是很实用的一个方法，设置响应体的Http状态码，虽然REST-Apid的风格的是统一200，但在express.js中，有些情景下你必须设置status code为某个值</p>
<pre><code class="language-javascript">res.status(404);
</code></pre>
<h2 id="send"><a class="header" href="#send">send</a></h2>
<p><strong>res.send(content)</strong>，将任意类型的内容放在响应体内返回给请求源</p>
<pre><code class="language-javascript">app.get('/', function (req, res) {
    res.send('Hello World!');
});
</code></pre>
<p>也可以接在status后面:</p>
<pre><code class="language-javascript">res.status(200).send(&lt;p&gt;hello world&lt;/p&gt;);
</code></pre>
<h2 id="end"><a class="header" href="#end">end</a></h2>
<p><strong>res.end()</strong>，用于快速结束不需要返回数据的场景下的响应，不过end()也可以传送数据，但性能消耗较大，不建议用res.end传数据和信息</p>
<pre><code class="language-javascript">//END
app.get('/end',(req,res)=&gt;{
    res.status(404).end();
})
</code></pre>
<h2 id="json"><a class="header" href="#json">json</a></h2>
<p><strong>res.json(content)</strong>，以json格式的请求体返回给请求源，可能会收到跨域保护的限制，因此往往需要我们顶上设置的一串Allow</p>
<pre><code class="language-javascript">//json - 同源限制
app.get('/json',(req,res)=&gt;{
    let resp = {
        code: 200,
        msg: &quot;json&quot;,
        toPrint: function(){
            console.log(`resp[code: ${this.code}, msg: ${this.msg}]`);
        }
    }
    res.jsonp(resp);
})
</code></pre>
<h2 id="jsonp"><a class="header" href="#jsonp">jsonp</a></h2>
<p><strong>res.jsonp(content)</strong>，jsonp是开发者们自研的一种不正统的数据格式，和json基本一样，但不太会被跨域保护给拦着</p>
<pre><code class="language-javascript">//jsonp - 更容易的解决跨域
app.get('/jsonp',(req,res)=&gt;{
    let resp = {
        code: 200,
        msg: &quot;jsonp&quot;,
        toPrint: function(){
            console.log(`resp[code: ${this.code}, msg: ${this.msg}]`);
        }
    }
    res.jsonp(resp);
})
</code></pre>
<h2 id="sendfile"><a class="header" href="#sendfile">sendFile</a></h2>
<p><strong>res.sendFile(path,options)</strong>，静态传输文件，不能直接使用相对路径</p>
<pre><code class="language-js">//sendfile，传输文件
app.get('/sendfile',(req,res)=&gt;{
    //只能是静态路径，需要相对路径的话有很多方法，以下是其中一个
    res.sendFile(&quot;hello.txt&quot;, {root: __dirname});
})
</code></pre>
<h2 id="download"><a class="header" href="#download">download</a></h2>
<p><strong>res.download(path)</strong>，下载传输文件，这个可以直接使用相对路径</p>
<pre><code class="language-js">//download，下载文件
app.get('/download',(req,res)=&gt;{
    //可以直接相对路径
    res.download(&quot;./hello.txt&quot;);
})
</code></pre>
<h2 id="sendstatus"><a class="header" href="#sendstatus">sendStatus</a></h2>
<p><strong>res.sendStatus(status code)</strong>，设置响应码，并返回信息为该状态码预设好的文本，比如res.sendStatus(404)，则响应的状态码是s404，返回的信息是'not Found'</p>
<pre><code class="language-js">//sendstatus
app.get('/sendstatus',(req,res)=&gt;{
    //预先写好的httpStatus组合，改一下试试，如果你输入的status码不存在，msg将变成这个码的数字
    res.sendStatus(404);
})
</code></pre>
<h2 id="location"><a class="header" href="#location">location</a></h2>
<p><strong>res.location(route)</strong>，REST接口之间的转发，必须设置status为300~309之间的数字，才能成功转发</p>
<pre><code class="language-js">//location
app.get('/location/1',(req,res)=&gt;{
    //转发到最早的helloworld路由去
    res.location('/').status(302).send();
})

//location/2
app.get('/location/2',(req,res)=&gt;{
    //转达到下面定义的这个接口
    res.location('/location/index').status(302).send();
})

app.get('/location/index',(req,res)=&gt;{
    res.send(&quot;welcome to learn express.js by demos&quot;);
})
</code></pre>
<h2 id="redirect"><a class="header" href="#redirect">redirect</a></h2>
<p><strong>res.redirect()</strong>，路由重定向，这个比较特殊，我们放到路由控制那一节再讲</p>
<h2 id="下一节-sql-knex增删改查"><a class="header" href="#下一节-sql-knex增删改查">下一节-Sql-knex增删改查</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql增删改查"><a class="header" href="#sql增删改查">Sql增删改查</a></h1>
<p>本节使用knex作为sql框架，以sqlite数据库为例</p>
<h2 id="准备工作-2"><a class="header" href="#准备工作-2">准备工作</a></h2>
<p>knex是一个运行在各自数据库Driver上的框架，因此需要安装相应的js版数据库Driver，如: PostgreSQL -&gt; pg, mysql/mariadb -&gt; mysql, sqlite -&gt; sqlite3...</p>
<ul>
<li>安装sqlite3依赖 <code>npm install sqlite3</code></li>
<li>安装knex依赖 <code>npm install knex</code></li>
<li>引入依赖</li>
</ul>
<pre><code class="language-js">const app = express();
const knex = require('knex');
</code></pre>
<ul>
<li>建议安装一款合适的数据库界面工具，笔者使用的是Beekeeper Studio.</li>
</ul>
<h2 id="创建项目-1"><a class="header" href="#创建项目-1">创建项目</a></h2>
<p>拷贝第一节HelloWorld的项目</p>
<h2 id="创建sqlite连接"><a class="header" href="#创建sqlite连接">创建sqlite连接</a></h2>
<p>指明client为sqlite3（刚刚安装的sqlite3依赖），并指明要操作的sqlite数据库路径</p>
<pre><code>const sqlite = knex({
    client: 'sqlite3',
    connection: {
      filename: './data.db',
    },
});
</code></pre>
<p>创建了一个连接实例后，会自动创建一个连接池，因此初始化数据库只会发生一次</p>
<h3 id="连接配置"><a class="header" href="#连接配置">连接配置</a></h3>
<p>sqlite3默认的是单连接，如果你希望连接池有更多的连接，创建时带上pool:</p>
<pre><code class="language-js">const sqlite = knex({
    client: 'sqlite3',
    connection: {
      filename: './data.db',
    },
    pool: { min: 0, max: 7 }
});
</code></pre>
<h4 id="创建连接池的回调"><a class="header" href="#创建连接池的回调">创建连接池的回调</a></h4>
<p>用于检查连接池是否正常，通常不需要这步</p>
<pre><code>pool: {
    afterCreate: function (conn, done) {//...}
}
</code></pre>
<h4 id="acquireconnectiontimeout"><a class="header" href="#acquireconnectiontimeout">acquireConnectionTimeout</a></h4>
<p>连接超时时间</p>
<h4 id="日志"><a class="header" href="#日志">日志</a></h4>
<p>knex内置了打印警告、错误、弃用和调试信息的日志函数，如果你希望自定义日志操作，可以在log项里重写它们</p>
<pre><code class="language-JS">log: {
    warn(message) {
    },
    error(message) {
    },
    deprecate(message) {
    },
    debug(message) {
    }
}
</code></pre>
<h2 id="数据表"><a class="header" href="#数据表">数据表</a></h2>
<h3 id="建表"><a class="header" href="#建表">建表</a></h3>
<p>语法: <code>sqlite.schema.createTable(表名, table=&gt;{表结构})</code></p>
<p>添加一个PUT接口，监听 127.0.0.1:8080/db/:tbname<br />
根据我们想创建的表名尝试创建一个表，注意: sql执行是异步的，为了得到结果，建议使用 <strong>async/await</strong> 语法糖（当然你就是喜欢地狱回调也不是不行）</p>
<pre><code class="language-js">app.put('/db/:tbname', async function (req, res) {
    let resultSet = null;
    try {
        // Create a table
        resultSet = await sqlite.schema
          .createTable(req.params.tbname, table =&gt; {
            table.increments('id');
            table.string('uname');
            table.string('passwd');
          })
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>瞅瞅控制台:</p>
<pre><code class="language-bash">sqlite does not support inserting default values. Set the `useNullAsDefault` flag to hide this warning. (see docs https://knexjs.org/guide/query-builder.html#insert).
</code></pre>
<p>嗯？sqlite不支持default？不用管他，去看数据库，反正成功创建了user表，你要是加了<code>useNullAsDefault</code>这个flag，反而会告诉你<code> not supported by node-sqlite3</code></p>
<pre><code class="language-js">const sqlite = knex({
    client: 'sqlite3',
    connection: {
      filename: './data.db',
    },
});
</code></pre>
<h3 id="删表"><a class="header" href="#删表">删表</a></h3>
<p>语法: <code>sqlite.schema.deleteTable(表名)</code></p>
<pre><code class="language-js">app.delete('/db/:tbname', async function (req, res) {
    try {
        // Delete a table
        await sqlite.schema.dropTable(req.params.tbname);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
    };
    res.json(null);
});

</code></pre>
<h2 id="表记录crud"><a class="header" href="#表记录crud">表记录crud</a></h2>
<h3 id="增"><a class="header" href="#增">增</a></h3>
<p>往user表里面插入一条新的记录</p>
<pre><code class="language-js">app.use(express.json({type: 'application/json'}));
app.put('/db/:tbname/record', async function (req, res) {
    /*前端请求体格式:
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;iloveu&quot;
    }
    */
   let resultSet = null;
    try {
        // Insert a record
        resultSet = await sqlite(req.params.tbname).insert(req.body);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具PUT 127.0.0.1:8080/db/user/record，携带相应的请求体，将会得到<code>[1]</code>，这是影响的记录数，1代表成功了</p>
<h3 id="查"><a class="header" href="#查">查</a></h3>
<p>从user表里查询uname=我们刚刚插入的记录</p>
<pre><code class="language-js">app.get('/db/:tbname/record', async function (req, res) {
    //前端携带query: uname=evanp
   let resultSet = null;
    try {
        // select a record where uname=xxx
        resultSet = await sqlite(req.params.tbname).select('*').where('uname',req.query.uname);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具GET 127.0.0.1:8080/db/user/record?uname=evanp，将会得到:</p>
<pre><code class="language-json">[
    {
        &quot;id&quot;: 1,
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;iloveu&quot;
    }
]
</code></pre>
<h3 id="改"><a class="header" href="#改">改</a></h3>
<p>接下来我们修改uname=evanp这条记录的passwd为123456</p>
<pre><code class="language-js">app.post('/db/:tbname/record', async function (req, res) {
    //前端携带query: uname=evanp
    /*前端请求体格式:
    {
        &quot;passwd&quot;: &quot;123456&quot;
    }
    */
   let resultSet = null;
    try {
        // select a record where uname=xxx
        resultSet = await sqlite(req.params.tbname).update(req.body).where('uname',req.query.uname);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具POST 127.0.0.1:8080/db/user/record?uname=evanp，并携带相应请求体，将会得到: [1]，这代表影响记录1条，成功了</p>
<h3 id="删"><a class="header" href="#删">删</a></h3>
<p>接下来我们删除uname=evanp且passwd=123456的这条记录</p>
<pre><code class="language-js">app.delete('/db/:tbname/record', async function (req, res) {
    /*前端请求体格式:
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;123456&quot;
    }
    */
   let resultSet = null;
    try {
        // select a record where uname=xxx
        resultSet = await sqlite(req.params.tbname).del().where(req.body);
        // Finally, add a catch statement
      } catch(e) {
        console.error(e);
        resultSet = e;
    };
    res.json(resultSet);
});
</code></pre>
<p>尝试用api调试工具DELETE 127.0.0.1:8080/db/user/record，并携带相应请求体，将会得到: [1]，这代表影响记录1条，成功了</p>
<h2 id="原生sql"><a class="header" href="#原生sql">原生sql</a></h2>
<p>当然了，如果你需要直接使用sql语句，也是可以的，调用<code>raw(sqlStr)</code>即可，既可以作为某一段sql的绑定，也可以直接当作整句sql</p>
<p>格式: <code>knex.raw(sql, [bindings]</code></p>
<pre><code class="language-json">sqlite.raw(&quot;select * from user&quot;,[1]).then((resp)=&gt;{//..})
</code></pre>
<p>在这里不做介绍</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>以上给出了使用knex实现增删改查的基本操作，这些方法并不是唯一的，在实际开发中往往要应对更复杂的场景，基础crud也是远远不够的<br />
关于knex的更多拓展使用方法，请移步knex官方文档<a href="https://knexjs.org/guide/">https://knexjs.org/guide/</a></p>
<h2 id="下一节-sql-orm增删改查"><a class="header" href="#下一节-sql-orm增删改查">下一节-Sql-ORM增删改查</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-orm增删改查"><a class="header" href="#sql-orm增删改查">Sql-ORM增删改查</a></h1>
<p>ORM框架: 对象关系映射，面对对象sql<br />
本节使用sequelize作为orm-sql框架，数据库为sqlite</p>
<h2 id="准备工作-3"><a class="header" href="#准备工作-3">准备工作</a></h2>
<p>同样的，需要安装相应的js版数据库Driver，如: PostgreSQL -&gt; pg, mysql/mariadb -&gt; mysql, sqlite -&gt; sqlite3...</p>
<ul>
<li>安装sqlite3依赖 <code>npm install sqlite3</code></li>
<li>安装sequelize依赖 <code>npm install sequelize</code></li>
<li>引入依赖</li>
</ul>
<pre><code class="language-js">const app = express();
const { Sequelize } = require('sequelize');
</code></pre>
<ul>
<li>建议安装一款合适的数据库界面工具，笔者使用的是Beekeeper Studio.</li>
</ul>
<h2 id="创建项目-2"><a class="header" href="#创建项目-2">创建项目</a></h2>
<p>拷贝第一节HelloWorld的项目</p>
<h2 id="创建sqlite连接-1"><a class="header" href="#创建sqlite连接-1">创建sqlite连接</a></h2>
<p>指定方言为sqlite，持久化路径为本目录下的data.db</p>
<pre><code class="language-js">const sqlite = new Sequelize({
    dialect: 'sqlite',
    storage: './data.db'
})
</code></pre>
<h2 id="定义表模型"><a class="header" href="#定义表模型">定义表模型</a></h2>
<p>sequelize主打一个面对对象sql，因此我们要建立一个对应数据表的类<br />
就和上一节一样，弄一张一模一样的user表吧:</p>
<ul>
<li>引入DataTypes</li>
</ul>
<pre><code>const { Sequelize,DataTypes } = require('sequelize');
</code></pre>
<ul>
<li>定义User对象</li>
</ul>
<p><code>Model.init(schema,options)</code></p>
<pre><code class="language-js">const User = sqlite.define('User', {
    id: {
        primaryKey: true,
        type: DataTypes.INTEGER,
        allowNull: false,
        autoIncrement: true
    },
    // 在这里定义模型属性
    uname: {
      type: DataTypes.STRING,
      allowNull: true
    },
    passwd: {
      type: DataTypes.STRING
      // allowNull 默认为 true
    }
  }, {
    // 直接指定表名，不指定的话sequelize将默认以模型的复数形式作为表名
    tableName: 'user'
});
</code></pre>
<p>还有另一种方法，效果是一样的，看个人喜好使用:</p>
<ul>
<li>额外引入Model</li>
</ul>
<pre><code class="language-js">const { Sequelize,DataTypes,Model } = require('sequelize');
</code></pre>
<ul>
<li>初始化User类</li>
</ul>
<p><code>Model.init(schema,options)</code></p>
<pre><code class="language-js">User继承Model类
class User extends Model {};
User.init(
    {
        id: {
            primaryKey: true,
            type: DataTypes.INTEGER,
            allowNull: false,
            autoIncrement: true
        },
        // 在这里定义模型属性
        uname: {
            type: DataTypes.STRING,
            allowNull: true,
        },
        passwd: {
            type: DataTypes.STRING，
            defaultValue: '123456', //默认值
            //allowNull 默认为 true
        }
    }, 
    {
        // 这是其他模型参数
        sqlite, // 我们需要传递连接实例
        modelName: 'User1', // 我们需要选择模型名称,
        // 直接指定表名
        tableName: 'user',
    }
);
</code></pre>
<h2 id="模型同步"><a class="header" href="#模型同步">模型同步</a></h2>
<p><code>Model.sync</code>: 底层执行的是 create table if not exist</p>
<ul>
<li>如果数据库中不存在对应的表，将根据模型直接创建表；若存在，不操作<br />
<code>Model.sync({force: true})</code>: 底层是先 drop if 然后 create</li>
<li>如果表已存在，将删除再根据模型创建表<br />
<code>Model.sync({alter: true})</code>: </li>
<li>如果表已存在，将修改表结构使之与模型匹配</li>
</ul>
<p>花里胡哨的，总之就是保证数据库中有和该模型对应的表</p>
<h2 id="创建user表"><a class="header" href="#创建user表">创建user表</a></h2>
<p>我们使用<code>User.sync()</code>创建一张user表</p>
<pre><code class="language-js">app.put('/db/user', async function (req, res) {
    let what = await User.sync();
    res.json(what);
});
</code></pre>
<p>使用api调试工具PUT 127.0.0.1:8080/db/user，将会得到1，注意只要能成功映射到到数据表都是1</p>
<p>用Beekeeper查看我们的user表，你会发现和我们定义的模型有点不一样：多了2个字段——createdAt和updatedAt，即创建时间和修改时间<br />
sequelize会自动管理这两个字段，注意当你使用了其他的sql工具修改表，这两个字段不会自动更新</p>
<p>如果你不想要这两个值，或者想换个名字，可以在定义模型时往options添加这些设置:</p>
<pre><code class="language-js">// 禁止createdAt和updatedAt
timestamps: false,
// 只禁止createdAt
createdAt: false,
// 给updatedAt换个名字
updatedAt: 'updateTime'
</code></pre>
<h2 id="删除user表"><a class="header" href="#删除user表">删除user表</a></h2>
<p>drop()方法，底层是 drop if，既可以作用于模型，也可作用于数据库:</p>
<pre><code class="language-js">sqlite.drop();  //这将删除当前data.db下所有的表
</code></pre>
<p>我们使用<code>User.drop()</code>来删除user表</p>
<pre><code class="language-js">app.delete('/db/user', async function (req, res) {
    let what = await User.drop();
    res.json(what);
});
</code></pre>
<p>使用api调试工具PUT 127.0.0.1:8080/db/user，将会得到1，注意即使表已经没了，也是1</p>
<h2 id="数据表crud"><a class="header" href="#数据表crud">数据表crud</a></h2>
<h3 id="增-1"><a class="header" href="#增-1">增</a></h3>
<p>在操作表记录前，我们先通过模型(<code>Model.build</code>)创建一个实例，然后调用<code>save()</code>将这个实例插入到表中<br />
当然，如果你从前端拿来的数据不需要进行处理和转化就能拿来用，也可以直接用<code>Model.create</code>插入记录</p>
<pre><code class="language-js">app.use(express.json({type: 'application/json'}));
app.put('/db/user/record', async function (req, res) {
    /**前端请求体
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;iloveu&quot;
    }
    */
    try {
        let user = User.build(req.body);
        let what = await user.save();
        // let what = await User.create(req.body);
        res.json(what);
    }catch(e){
        res.json(e);
    }
});
</code></pre>
<p>使用api调试工具PUT 127.0.0.1:8080/db/user/record，携带相应的请求体，将会得到:</p>
<pre><code class="language-json">{
    &quot;id&quot;: 1,
    &quot;uname&quot;: &quot;evanp&quot;,
    &quot;passwd&quot;: &quot;iloveu&quot;,
    &quot;updatedAt&quot;: &quot;2023-03-19T08:03:37.964Z&quot;,
    &quot;createdAt&quot;: &quot;2023-03-19T08:03:37.964Z&quot;
}

</code></pre>
<p>是的，添加记录成功后它会顺便把整条记录查出来作为返回结果</p>
<p>Ok，那么现在user表里已经有了id=1的一条记录了，让我们试一下创建相同id的记录会怎么样...<br />
服务器直接挂了，我们可不希望这样，这意味着有任何不妥的sql都可能导致服务器崩溃，那怎么办呢？</p>
<p>有的朋友可能记起来了，在上一节中，使用了try-catch语法糖包裹sql操作，这是一种不错的方法</p>
<h3 id="查-1"><a class="header" href="#查-1">查</a></h3>
<p>sequelize模型内置了一些方法使得我们可以基于模型直接查询</p>
<ul>
<li>findAll 查找全部，底层是<code>select * from ...</code></li>
<li>findOne 查找一个，底层是<code>select * from ... LIMIT 1</code></li>
<li>findByPk 根据主键查找</li>
<li>findAndCountAll 查找并返回符合的总条数，常用于分页</li>
<li>findOrCreate 找不到就创建</li>
</ul>
<p>这些方法都可以添加options参数设置WHERE,LIMIT等限制条件<br />
我们使用findOne来查询evanp和用户名和密码都对的上的一条记录:</p>
<pre><code class="language-js">//我为了方便直接url传参了，实际上为了隐私，至少应该放在请求体内
app.get('/db/user/record', async function (req, res) {
    let evanp = await User.findOne({where: req.query});
    res.json(evanp);
});
</code></pre>
<p>如果你只需要查询其中某些字段，就在options中设置attributes:</p>
<pre><code class="language-js">User.findAll({
    attributes: ['id','uname']
});
</code></pre>
<p>如果想给字段取别名，就比如像这样给id取名uid:</p>
<pre><code class="language-js">User.findAll({
    attributes: [['id','uid'],'uname']
});
</code></pre>
<h2 id="改-1"><a class="header" href="#改-1">改</a></h2>
<p><code>Model.update(修改项,限制)</code></p>
<pre><code class="language-js">app.post('/db/user/record', async function (req, res) {
    /*请求体
    {
        &quot;set&quot;:{
            &quot;passwd&quot;: &quot;123456&quot;
        },
        &quot;where&quot;: {
            &quot;uname&quot;: &quot;evanp&quot;,
            &quot;passwd&quot;: &quot;iloveu&quot;
        }
    }
    */
    let what = await User.update(req.body.set,{where: req.body.where})
    res.json(what);
});
</code></pre>
<p>使用api工具进行调试，修改成功将返回1，修改失败将返回0(找不到/改不了)</p>
<h2 id="删-1"><a class="header" href="#删-1">删</a></h2>
<p><code>Model.destroy(限制)</code></p>
<pre><code class="language-js">app.delete('/db/user/record', async function (req, res) {
    /*请求体
    {
        &quot;uname&quot;: &quot;evanp&quot;,
        &quot;passwd&quot;: &quot;123456&quot;
    }
    */
    let what = await User.destroy({where: req.body})
    res.json(what);
});
</code></pre>
<p>使用api工具进行调试，删除成功将返回1，删除失败将返回0(找不到/删不了)</p>
<h2 id="原生sql-1"><a class="header" href="#原生sql-1">原生Sql</a></h2>
<p>当然了，如果你需要直接使用sql语句，也是可以的，<code>连接实例.query(sqlStr)</code>即可<br />
通常，返回结果包含2个值，一个是结果数组，一个是相关信息</p>
<pre><code class="language-js">app.post('/db/user/record/freely', async function (req, res) {
    /*json请求体
    {
        &quot;sql&quot;: &quot;xxx&quot;
    }
    */
    let what = null;
    try {
        what = await sqlite.query(req.body.sql);
    } catch (e) {
        what = e;
    }
    res.json(what);
});
</code></pre>
<p>执行insert前要注意，如果这张表是经过sequelize同步的，也许会有那两个时间字段的，别忘了</p>
<p>本节的例子仅仅为了演示在express.js中如何运用sequelize操作数据库，关于sequelize的更多拓展和高级使用方法，请移步sequelize官方文档<a href="https://www.sequelize.cn/">https://www.sequelize.cn/</a></p>
<h2 id="下一节-路由控制"><a class="header" href="#下一节-路由控制">下一节-路由控制</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="路由控制"><a class="header" href="#路由控制">路由控制</a></h1>
<h2 id="准备工作-4"><a class="header" href="#准备工作-4">准备工作</a></h2>
<p>拷贝第一节HelloWorld项目</p>
<h2 id="动态路由"><a class="header" href="#动态路由">动态路由</a></h2>
<p>这个最初我们就接触到了，路径中某一段前面加冒号</p>
<pre><code class="language-js">//路径变量-动态路由
app.get('/:var',(req, res)=&gt;{
    res.send(req.params.var);
});
</code></pre>
<h2 id="路由匹配"><a class="header" href="#路由匹配">路由匹配</a></h2>
<p>利用通配符 * 匹配符合的所有路由</p>
<ul>
<li>全通配</li>
</ul>
<p><strong>定义时</strong>，以 * 结尾，或者 * 之后除了斜杠没有其他字符，匹配*之后所有的路由</p>
<pre><code class="language-js">//全部匹配，囊括了match之下的所有路由，即便前端请求路径时在后面再来几段，也会被当作一个字符串 /x/1/6 -&gt; '/x/1/6'
//慎用，必须确保其他独立的路由不会被覆盖了
app.get('/matchall/*',(req, res)=&gt;{
    let what = {
        params: req.params,
        theVar: req.params['0']
    }
    res.send(what);
});
</code></pre>
<p>前端发来请求时，如何有2个定义的接口都能匹配到，优先匹配先定义的</p>
<pre><code class="language-js">//不起效
app.get('/matchall/w/xf',(req, res)=&gt;{
    res.send(&quot;there is w.xf&quot;);
});
</code></pre>
<ul>
<li>局部通配</li>
</ul>
<p>在两个字符之间(斜杠不算，除非你转义过了)使用 *，匹配这两个字符中间夹任何一段字符串的路由:<br />
xAy,xBy,xvenapy...</p>
<pre><code class="language-js">//xy中间随便夹
app.get('/match/x*y', function (req, res) {
    res.send('xy肉夹馍')
})
</code></pre>
<pre><code class="language-js">//除非通配符后面有除了斜杠以外的字符，不然全部被盖
app.get('/match/w*/x', function (req, res) {
    res.send('除非通配符后面有除了斜杠以外的字符，不然全部被盖')
})
</code></pre>
<ul>
<li>动态字符(串)</li>
</ul>
<p>问号前的字符可有可无，gback,goback</p>
<pre><code class="language-js">//问号前面这个字符可有可无
app.get('/match/go?back',(req, res)=&gt;{
    res.send(&quot;问号前面这个字符可有可无&quot;);
});
</code></pre>
<p>问号前被括号括住的字符串可有可无，xback,xgoback</p>
<pre><code class="language-js">app.get('/match/x(go)?back',(req, res)=&gt;{
    res.send(&quot;问号前面这个字符串可有可无，注意被括住的字符串前面不能没有字符&quot;);
});
</code></pre>
<p>加号前的字符可以重复，goback,gooback,goooback...</p>
<pre><code class="language-js">//可匹配到多个路由时，优先匹配先定义的路由
//一个或多个问号前字符
app.get('/match/go+back',(req, res)=&gt;{
    let what = {
        match: '/match/go+back',
        url: req.url,
        tip: &quot;加号前面的那个字符可以无限重复&quot;
    }
    res.send(what);
});
</code></pre>
<h2 id="正则匹配"><a class="header" href="#正则匹配">正则匹配</a></h2>
<p>可用于复杂路由的匹配，在路由中局部正则时，记得用括号包住</p>
<pre><code class="language-js">//正则匹配
//匹配了127.0.0.1:8080/x//数字useremm//
app.get('/x/(\/[0-9]useremm\/)', function (req,res) {
    console.log(req.body);
    res.send(&quot;正则可用于复杂路径的匹配&quot;);
})
</code></pre>
<h2 id="路由重定向"><a class="header" href="#路由重定向">路由重定向</a></h2>
<p>有时候我们希望某些情况下将路径转发到其他路径，比如404页面之类的<br />
格式: <code>res.redirect(status, url)</code><br />
status是干什么的？对于重定向后的路由不同的请求方法应该使用不同的status:</p>
<ul>
<li>GET</li>
</ul>
<pre><code class="language-js">//转发到 GET /1/2/3/4/5
app.post('/redirect',(req,res)=&gt;{
    res.redirect(301,'/1/2/3/4/5');
});

app.get('/1/2/3/4/5',(req,res)=&gt;{
    res.send(&quot;上山打老虎&quot;);
})
</code></pre>
<p>301或302都是可以的，301代表临时，302代表永久</p>
<p>接下来我们把转发后的路由改成POST，再去访问redirect:</p>
<pre><code class="language-js">app.post('/1/2/3/4/5',(req,res)=&gt;{
    res.send(&quot;上山打老虎&quot;);
})
</code></pre>
<p>是的，响应不到了，转发到POST路由，应当使用307或308，前者临时后者永久<br />
<code>res.redirect(301,'/1/2/3/4/5');</code></p>
<ul>
<li>JSON与重定向</li>
</ul>
<p>开启<code>app.use(express.json)</code>，再尝试访问redirect，结果又得不到响应了，这是为什么？<br />
开启了json解析后，请求变成了json，请求已经不是原始的请求了，变成了json对象，是没办法被转发的<br />
因此在有需要重定向的时候，我们不应该全局json解析了，而是在需要json解析的路由上开启json解析:</p>
<p>建个需要使用json解析的测试接口:</p>
<pre><code class="language-js">app.put('/some/json',(req,res)=&gt;{
    res.send(req.body);
});
</code></pre>
<p>自定义一个选择性body-json的中间件，判定 PUT:/some/json 时局部开启json解析:</p>
<pre><code class="language-js">app.use((req, res, next) =&gt; {
    // 判断当前请求路径是否需要解析JSON请求体
    if (req.path === '/some/json'&amp;&amp; req.method.match(&quot;PUT&quot;)) {
      bodyParser.json()(req, res, next);
    } else {
      next();
    }
});
</code></pre>
<p>尝试用api调试工具访问redirect，重定向成功了，再访问/some/json，也能成功打印请求体.</p>
<h2 id="下一节-jwt基础鉴权"><a class="header" href="#下一节-jwt基础鉴权">下一节-JWT基础鉴权</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jwt基础鉴权"><a class="header" href="#jwt基础鉴权">JWT基础鉴权</a></h1>
<p>Web安全是Web应用中非常重要的一环，主要由后端和服务器承担安全保障<br />
面对请求源，后端有着各种各样的鉴权机制: session,cookie,token,jwt,OAuth,OAuth2,api-key,signature...<br />
本节以jwt为例，演示一个极简的token鉴权</p>
<h2 id="准备工作-5"><a class="header" href="#准备工作-5">准备工作</a></h2>
<ul>
<li>拷贝第一节HelloWorld项目</li>
<li>安装一种jwt依赖(本节使用jsonwebtoken)</li>
</ul>
<h2 id="实践-3"><a class="header" href="#实践-3">实践</a></h2>
<p>接下来我们使用jsonwebtoken来实现最常见的登录鉴权，登录成功后返回一个token，之后凭借这个token去访问另外的路由</p>
<ul>
<li>首先引入jwt依赖</li>
</ul>
<pre><code class="language-js">const jwt = require('jsonwebtoken');
</code></pre>
<ul>
<li>定义一个密钥</li>
</ul>
<p>之后我们会利用这个密钥生成token，和检验token</p>
<pre><code class="language-js">const secret = 'mysecretkey';
</code></pre>
<ul>
<li>写个登录时生成token的函数</li>
</ul>
<p>传入用户名和密码，检验密码，正确就生成一个token<br />
生成token: <code>jwt.sign(标志,密钥,选项(生命周期等))</code></p>
<pre><code class="language-js">function getToken(user) {
    let token = null;
    const payload = {
      uname: user.uname,
    };
    if (user.uname == 'root' &amp;&amp; user.passwd == 'root') {
        token = jwt.sign(payload, secret, { expiresIn: '1h' });
    }
    return token;
}
</code></pre>
<ul>
<li>写一个访问时检验token的函数</li>
</ul>
<p>传入req,res,next，从请求头中取出名字为'token'的一个token，若请求头里不带token则返回请求报告没token，token校验通过了则放行</p>
<pre><code class="language-js">function checkToken(req, res, next) {
    const token = req.headers['token'];
    if (!token) return res.status(401).json({ message: 'No token provided.' });
    jwt.verify(token, secret, (err, decoded) =&gt; {
      if (err) return res.status(500).json({ message: 'Failed to authenticate token.' });
      req.userId = decoded.id;
      next();
    });
}  
</code></pre>
<ul>
<li>编写登录接口</li>
</ul>
<pre><code class="language-js">app.post('/login', (req, res) =&gt; {
    let user = req.body;
    let token = getToken(user);
    if(token!=null) {
        res.send(token);
    } else {
        res.status(401).send(&quot;wrong&quot;);
    }    
});
</code></pre>
<ul>
<li>编写一个需要校验token的接口</li>
</ul>
<p>将token检验函数作为中间件挂载到 /root 路由上</p>
<pre><code class="language-js">app.get('/root', checkToken, (req, res) =&gt; {
    res.send('hello root user!');
});
</code></pre>
<h2 id="接口测试-2"><a class="header" href="#接口测试-2">接口测试</a></h2>
<p>尝试用api调试工具先访问 login 接口，利用正确的用户名和密码获取token，然后用得到的token去访问 root 接口</p>
<h2 id="下一节-全局错误处理"><a class="header" href="#下一节-全局错误处理">下一节-全局错误处理</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局错误处理"><a class="header" href="#全局错误处理">全局错误处理</a></h1>
<p>在前面几节里，我们处理异常的方法都是手动在可能引发异常的地方捕捉错误，这固然是必要的，可以有针对性得处理异常，但很多时候，有许多潜在的异常，有一句话叫永远不要相信输入的数据，你永远都不知道什么时候可能会以什么方式触发某些阴间异常从而造成系统崩溃。因此，我们需要有一位好帮手能帮助我们捕获各种错误</p>
<p>而这位好帮手就是，<strong>异常处理中间件</strong></p>
<h2 id="自定义异常处理中间件"><a class="header" href="#自定义异常处理中间件">自定义异常处理中间件</a></h2>
<h3 id="同步异常"><a class="header" href="#同步异常">同步异常</a></h3>
<p>异常处理中间件需要传入4个参数: err,req,res和next，这样才会被express识别为异常处理中间件<br />
创建一个exhandler，并挂载到服务器上:<br />
注意: 挂载异常处理中间件的行为必须位于所有定义的接口之下，至于理由，会在下一节《中间件》中给出解答</p>
<pre><code class="language-js">let exhandler = (err, req, res, next)=&gt; {
    console.error('Error:', err.message);
    res.status(500).json(err);
}
app.use(exhandler);
</code></pre>
<p>我们在helloWorld接口中人为抛出一个异常试一下，可以直接throw，也可以传递给next（事实上，意外的异常发生时，会被express捕获并传递给next，然后再丢给我们的异常处理中间件）</p>
<pre><code class="language-js">app.get('/', (req, res, next)=&gt; {
    const err = new Error();
    err.name = '无法访问';
    err.message = '对不起，网站正在维护中';
    // next(err);
    throw err;
});
</code></pre>
<h3 id="测试"><a class="header" href="#测试">测试</a></h3>
<p>使用api调试工具GET 127.0.0.1:8080/，我们的程序不会崩溃，并且你将得到被封装好的错误信息，并且响应码是500。</p>
<pre><code class="language-JSON">{
    &quot;name&quot;: &quot;无法访问&quot;,
    &quot;message&quot;: &quot;对不起，网站正在维护中&quot;
}
</code></pre>
<h3 id="异步异常"><a class="header" href="#异步异常">异步异常</a></h3>
<p>上面的异常是产生在串行的代码中的，那如果在异步操作中产生了异常呢？<br />
我们弄一个异步异常的接口试一下:</p>
<pre><code class="language-js">app.post('/', async (req, res, next)=&gt; {
    res.send(await error()).end();
});

function error() {
    let err = new Error('网站维护');
    err.message = &quot;自定义的错误&quot;;
    return Promise.reject(err);
}
</code></pre>
<p>POST 127.0.0.1:8080/，程序报错，之前的中间件并未捕获到这个错误。</p>
<p>可以手动在处理函数内加上 try-catch 语句块，但这样比较繁琐，一个更方便的方法是使用 <strong>express-async-errors</strong>:</p>
<pre><code class="language-shell">npm i express-async-errors
</code></pre>
<p>然后引入即可:</p>
<pre><code class="language-js">require('express-async-errors');
</code></pre>
<p>POST 127.0.0.1:8080/，这次成功捕获到了异步错误！</p>
<h2 id="下一节-中间件"><a class="header" href="#下一节-中间件">下一节-中间件</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中间件"><a class="header" href="#中间件">中间件</a></h1>
<p>中间件，估计大家在前几节里面听的耳朵都要出茧子了吧！一直提到，一直不讲。别急，这不来了嘛</p>
<h2 id="准备工作-6"><a class="header" href="#准备工作-6">准备工作</a></h2>
<p>拷贝第一节Hello World项目</p>
<h2 id="什么是中间件"><a class="header" href="#什么是中间件">什么是中间件</a></h2>
<p>如果正在阅读本书之前的你，已经有过一些其他框架或语言的后端开发经历，那理应是知道中间件这个东西的。当然也不绝对，比如隔壁某个框架太贴心了，以至于笔者都觉得理所应当，在撰写本节时，才惊觉原来在那个框架里竟内置了这么多的中间件。</p>
<p>由于 express.js 是一个轻量级后端框架，因此中间件的身份变得非常的突出。</p>
<p>在 express.js 中，中间件（Middleware）是指应用中，用于<strong>额外</strong>处理 HTTP 请求和响应的函数，通常不涉及主体业务。中间件函数可以访问请求对象（request object）（req）、响应对象（response object）（res）和应用程序中处理请求-响应循环流程的<strong>下一个</strong>中间件函数（next）。
在 express.js 应用中，可以使用 use() 方法来挂载中间件函数。在处理 HTTP 请求时，express.js 会按照添加中间件函数的顺序依次调用它们，直到响应被发送为止。如果在某个中间件函数中没有调用 next() 方法，则<strong>请求-响应</strong>循环流程会在该中间件函数队伍中提前终止。</p>
<p>中间件的应用主要在日志，鉴权，预检，初步数据处理，异常处理等等。接下来，举几个简单的例子:</p>
<h2 id="路由中间件"><a class="header" href="#路由中间件">路由中间件</a></h2>
<p>是的，路由可以单独抽离出来的中间件，可以挂载在app也可以作为子路由挂载在其他路由上</p>
<pre><code class="language-javascript">//Route coule be middleware
const routers = express.Router();

routers.get('/', function (req, res) {
    res.send('Hello World!');
});

routers.post('/', (req,res)=&gt; {
    res.send('Bad World!');
    
})
app.use(routers)
</code></pre>
<h2 id="鉴权中间件"><a class="header" href="#鉴权中间件">鉴权中间件</a></h2>
<p>鉴权中间件，可以被挂载到单个路由，一系列路由以及app全局<br />
这是一个检查请求头token的鉴权中间件:</p>
<pre><code class="language-javascript">//鉴权中间件，可以被挂载到单个路由，一系列路由以及全局
let auth = (req,res,next) =&gt; {
    if (req.headers['token']!='evanp'){
        return res.send('Unauthorized');
    }
    next()
}

const router_root = express.Router();

router_root.post('/root', auth, (req,res)=&gt; {
    res.send('Hello root!')
})
app.use(router_root);
</code></pre>
<h2 id="异常处理中间件"><a class="header" href="#异常处理中间件">异常处理中间件</a></h2>
<p>异常处理中间件，全局捕捉异常，防止服务器崩溃</p>
<pre><code class="language-javascript">//异常中间件
const exhandler = (err,req,res,next)=&gt; {
    return res.json({ &quot;err&quot;:{ &quot;name&quot;: err.name, &quot;msg&quot;: err.message }});
}
app.use(exhandler);

//测试接口
router_err.get('/error', auth, (req,res)=&gt; {
    const err = new Error(&quot;error!&quot;);
    err.name = &quot;故意err&quot;;
    err.message = &quot;error!&quot;;
    throw err;
    res.status(200).json({msg: 'good!'});
})
app.use(router_err);
</code></pre>
<h2 id="第三方中间件"><a class="header" href="#第三方中间件">第三方中间件</a></h2>
<p>当然了，在实际生产中，并不需要每个中间件都我们自己写，一是自己造轮子麻烦，而是自己造的轮子可用性不高，不够专业，三是优秀团队开发的中间件性能更好，隐患更小<br />
可以更多的使用第三方团队开发的优秀的中间件，比如鉴权相关的passport.js，jsonwebtoken，sql相关的knex，sequelize等等。</p>
<h2 id="万物皆可中间件"><a class="header" href="#万物皆可中间件">万物皆可中间件</a></h2>
<p>上面给的几个例子，都是属于一个模块的不同部分作为中间件挂载到当前的应用，在express.js中，中间件远不止于次</p>
<p>app也可以作为中间件挂载到app!一般是负责不同功能的app聚合到一个总的app上，比如订单模块单独一个app，用户模块单独一个app，一起挂载到作为整个完整系统的app上，这样子把整个系统按不同模块切割成独立的app，更易于维护和管理，有点伪微服务架构的意味。</p>
<p>router也能把app作为他的子中间件，这种做法应该很少用吧，暂时不清楚有什么应用场景。</p>
<h2 id="下一章-架构整合"><a class="header" href="#下一章-架构整合">下一章-架构整合</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="架构整合"><a class="header" href="#架构整合">架构整合</a></h1>
<p>在第一章中，我们按功能分块学习了express后端中不同方面的技术，所有的代码基本都写在了一个文件中，在实际开发中这是不符合规范的，我们需要有一个合理的目录结构，在本章中，将结合常见的前后端架构思想，express.js特性以及借鉴其他语言的优秀框架的架构，每节介绍一种架构方式</p>
<p>注意，这些架构的名字仅仅是我自己这么称呼用的，不代表它们就一定叫这个</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="express-cli"><a class="header" href="#express-cli">express-cli</a></h1>
<p>首先介绍一下express官方的手脚架</p>
<h2 id="搭建"><a class="header" href="#搭建">搭建</a></h2>
<ul>
<li>创建一个目录</li>
<li>进入项目，终端内暗转express</li>
</ul>
<pre><code class="language-shell">npm install express
</code></pre>
<ul>
<li>利用express打架基础项目</li>
</ul>
<pre><code class="language-shell">express
</code></pre>
<ul>
<li>安装基础项目的依赖</li>
</ul>
<pre><code class="language-shell">npm install
</code></pre>
<p>你将获得这样的一个项目，可以通过<code>npm run start</code>运行:</p>
<pre><code class="language-text">│  app.js
│  package-lock.json
│  package.json
│
├─bin
│      www
│
├─node_modules
├──//...
│
├─public
│  ├─images
│  ├─javascripts
│  └─stylesheets
│          style.css
│
├─routes
│      index.js
│      users.js
│
└─views
        error.jade
        index.jade
        layout.jade
</code></pre>
<p>app.js是整个程序的入口文件，package.json是项目配置文件，node_modules是项目依赖，public是存放静态资源的目录，routes是存放我们定义的路由模块的目录，views是渲染层目录(里面的.jade是node.js的一种页面渲染模板)，bin是脚本目录</p>
<h2 id="启动脚本"><a class="header" href="#启动脚本">启动脚本</a></h2>
<p>bin目录下的www，其实就是一个写好的脚本，用来挂载express应用并启动服务器的:<br />
引入了app.js，设置了端口，创建了一个服务器，定义了错误监听和成功监听端口时的回调，基本上就这么一些东西</p>
<h2 id="静态目录"><a class="header" href="#静态目录">静态目录</a></h2>
<p>public没什么可说的，就存放静态资源的，如果是当作纯后端，就放点图片、LOGO、以及初始化文件之类的，前后端一体的话还多些css和js脚本等</p>
<h2 id="views"><a class="header" href="#views">views</a></h2>
<p>一体的前端，渲染模板用的jade，我不会，跳过</p>
<h2 id="routes"><a class="header" href="#routes">routes</a></h2>
<p>专门放定义的路由/接口，我们看其中一个:<br />
写完一个路由，然后导出，就这样</p>
<pre><code class="language-js">var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function(req, res, next) {
  res.render('index', { title: 'Express' });
});

module.exports = router;

</code></pre>
<p>当然，你也可以不止写一个路由，写成聚合路由集群，或者导出多个也是可以的，一般同属一个小模块的可以放在一个文件里</p>
<h2 id="补充"><a class="header" href="#补充">补充</a></h2>
<p>这个手脚架的结构就这么简单，实际开发中，我们肯定要加添加更多的目录，比如存放类的目录，存放封装好的sql或者工具函数的目录，存放自定义的中间件目录等等</p>
<p>本身express就是个轻量级框架，简单意味着你可以更加自由的组装你的项目结构</p>
<h2 id="下一节-mvc层级架构"><a class="header" href="#下一节-mvc层级架构">下一节-MVC层级架构</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mvc层级架构"><a class="header" href="#mvc层级架构">MVC层级架构</a></h1>
<p>M-V-C(model-view-control)是非常经典的一种web项目架构，将项目分为模型，视图和控制三大层。</p>
<p>这是我自己搭建的一种mvc架构:</p>
<pre><code class="language-text">│  app.js
│  package-lock.json
│  package.json
│
├─control
│  ├─routes
│  │      userRoutes.js
│  │
│  └─service
│          userService.js
│
├─model
│      resp.js
│      user.js
│
├─node_modules
│  //...
│
├─static
│      data.json
│
├─utils
│      sqlUtil.js
│      stringUtil.js
├─midwares
│      exhandler.js
│
└─views
        index.html
</code></pre>
<p>模型：实体类<br />
视图：页面<br />
控制：各种控制（逻辑、视图等）</p>
<p>他们各自还可以细分层次：</p>
<h2 id="model层"><a class="header" href="#model层">model层</a></h2>
<p>所有模块需要的模型都放到这里</p>
<p>model可以按照其用途、服务对象等分成普通对象、数据传输对象、完整对象的散对象、数据表映射对象等等，比如po, dto, vo等等，之前sequelize中的模型就算是数据表映射对象。<br />
当然这是一个跨语言的概念，由于js天生没有类型系统，很多时候你可以选择不定义某些对象，有更高的灵活性，定义对象，虽然灵活性降低，但更易于代码维护，看实际情况决定，当然，一些高复用性的建议定义好，比如给REST接口统一的返回格式，那你就可以专门设定一个对象:</p>
<pre><code class="language-js">let resp = {
  code: null,
  msg: null,
  data: null,

  Ok: (msg,data)=&gt;{
    this.code = 200;
    this.msg = msg!=undefined? msg : 'success';
    this.data = data!=undefined? data : null;
  }
}

let respOk = {
  code: 200,
  msg: 'success',
  data: null
}

module.exports = {
  resp: resp,
  respOk: respOk
}
</code></pre>
<h2 id="控制层"><a class="header" href="#控制层">控制层</a></h2>
<p>所有功能模块的路由，服务等等都放到这里</p>
<p>控制层可以再根据特性分层，比如路由单独搞个routes层，业务处理单独搞个service层等等</p>
<h2 id="补充-1"><a class="header" href="#补充-1">补充</a></h2>
<p>同样的，实际开发中需要更多的目录，比如工具目录，资源目录等等，放你的图片，放你的工具函数，放你封装好的sql函数，放你的中间件等等</p>
<h2 id="下一节-基于业务特性的分布式架构"><a class="header" href="#下一节-基于业务特性的分布式架构">下一节-基于业务特性的分布式架构</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分布式结构"><a class="header" href="#分布式结构">分布式结构</a></h1>
<h1 id="基于业务特性的分布式结构"><a class="header" href="#基于业务特性的分布式结构">基于业务特性的分布式结构</a></h1>
<p>上节的mvc架构，把所有不同模块的同层文件都放在一个目录下</p>
<p>我们也可以将你的项目结构按照业务模块进行划分，每一个模块内可以再按mvc分层，或者不分，这样子把不同模块独立出来的就叫做分布式结构(dcs)</p>
<h2 id="结构"><a class="header" href="#结构">结构</a></h2>
<pre><code>│  package-lock.json
│  package.json
│  server.js
│
├─assets
│      logo.svg
│
├─goodModule
│  │  app.js
│  │
│  ├─midwares
│  ├─model
│  │      good.js
│  │
│  ├─routes
│  ├─service
│  └─sqls
├─midwares
├─node_modules
│  //...
│
├─orderModule
│  │  app.js
│  │
│  ├─midwares
│  ├─model
│  │      order.js
│  │
│  ├─routes
│  ├─service
│  └─sqls
├─userModule
│  │  app.js
│  │
│  ├─midwares
│  ├─model
│  ├─routes
│  ├─service
│  └─sqls
├─utils
└─views
</code></pre>
<p>server.js是整个应用的入口文件，user，good和order分别创建了三个express app，完成各自的业务，最终挂载到server.js中去</p>
<h2 id="下一节-微服务架构"><a class="header" href="#下一节-微服务架构">下一节-微服务架构</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微服务架构"><a class="header" href="#微服务架构">微服务架构</a></h1>
<h3 id="微服务"><a class="header" href="#微服务">微服务</a></h3>
<p>微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署，所有的服务最终可以被视作一个集群而进行统一管理</p>
<h3 id="优缺点"><a class="header" href="#优缺点">优缺点</a></h3>
<p>从微服务的理念着手，它的优缺点绝大部分能通过与单体应用相对比得出</p>
<h4 id="优点"><a class="header" href="#优点">优点</a></h4>
<p>微服务的优点，就是解决了单体应用的痛点</p>
<ul>
<li>★ 高可维护性与高可拓展性<br />
随着时间的推移，单体项目将不可避免的臃肿无比且交错杂乱，高耦合的屎山代码使得每一次维护与拓展都变得胆战心惊。而微服务将完整系统中的每一个模块<strong>抽离</strong>出来，使得<strong>业务更加清晰</strong>且<strong>耦合度降低</strong>，维护与拓展将会容易很多</li>
<li>★ 程序构建与迭代高效
原本庞大的单体项目修改了源码之后需要整个项目进行重新编译与运行，如果体量足够大，可是要不少时间。拆分为微服务后，只需要重新编译与运行有限的几个微服务即可，由于微服务的体量小很多并且可以并行构建，效率肉眼可见的高</li>
<li>★ 系统稳定与健壮性增强
一体的单体应用中如果某一环出了问题，可能导致整个系统瘫痪的重大事故，而独立且松耦合的微服务系统，完全可以将<strong>瘫痪的范围缩小</strong>到有限的部分微服务上，而不至于导致整个系统下架维护</li>
<li>★ 打破技术限制与瓶颈
毕竟微服务是独立开来的，因此每个微服务完全可以<strong>采取不同的语言与开发环境</strong>，以适应各自的特色业务需求，比如需要强劲算力的微服务可以采用Rust语言和更快的GPU硬件，需要图形计算的微服务可以使用Neo4j作为数据库等等</li>
</ul>
<h4 id="缺点"><a class="header" href="#缺点">缺点</a></h4>
<p>当然了，微服务也是一把双刃剑，在解决了单体服务的痛点的同时，由于分布式的架构不可避免的带了一些原本不存在的挑战</p>
<ul>
<li>运维与部署成本高
单体应用不出意外就一个应用程序和一个数据库，运维和部署是很容易的。虽然微服务的每个独立服务可以通过CI/CD实现自动化构建与部署，但考虑到各个微服务的特性与独立的数据，可能需要多台不同的服务器，配置过程也较为繁琐</li>
<li>分布式系统的复杂性
由于微服务架构遵从分布式，这将带来许多挑战与困难，比如系统容错、数据同步、分布式事务、网络延迟等等的问题</li>
<li>通信接口维护成本高
微服务之间通过内部的api交互，当其中一个api变动，其他依赖它的服务都需要做出相应的调整</li>
</ul>
<h3 id="设计原则"><a class="header" href="#设计原则">设计原则</a></h3>
<ul>
<li>单一职责原则
微服务各司其职，只关心完整系统中的一部分功能</li>
<li>服务自治原则
微服务<strong>高度独立</strong>，与其他服务保持<strong>松耦合状态</strong>，在开发、测试、部署的过程中应当能做到<strong>独立运行</strong>而不强制依赖其他服务</li>
<li>轻量级通信机制
微服务之间相互通信，应该通过某些比较便捷且支持跨语言跨平台的手段，比如 <strong>Rest Api</strong>，比如消息队列等</li>
<li>合理粒度原则
合理地划分微服务的粒度，不是说代码量少就等于适合做成微服务，更要业务复杂性的体量以及与其他服务之间的关联程度</li>
</ul>
<h3 id="技术选型"><a class="header" href="#技术选型">技术选型</a></h3>
<p>在微服务落地中，有着一些非常不错的开源框架可供选择</p>
<ul>
<li>SpringCloud 一款非常优秀且成熟的微服务开源框架</li>
<li>Dubbo 阿里开源的一款微服务框架</li>
<li>Spring Cloud Alibaba 阿里开源的基于SpringCloud的框架</li>
<li>Open Feign 出自Spring社区的Restful服务通信组件</li>
<li>Nacos 阿里开源的一款强大的服务注册中心</li>
<li>Seata 阿里和蚂蚁开源的分布式事务解决方案</li>
<li>Nginx 高性能http和反向代理服务器</li>
<li>Docker 实现微服务的容器化部署</li>
<li>...</li>
</ul>
<p>借助已有的优秀开源框架，将帮助我们更好的理解和实践微服务架构。</p>
<h2 id="下一章-evp-express-cli"><a class="header" href="#下一章-evp-express-cli">下一章-evp-express-cli</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evp-express-cli"><a class="header" href="#evp-express-cli">evp-express-cli</a></h1>
<p>evp-express-cli 是笔者结合自己的实践经验编写的一款 express 手脚架，以一种比较合适的流程构建的 express 架构。</p>
<hr />
<p>
  <a href="https://www.npmjs.com/package/evp-express-cli"><img alt="npmpackage" src="https://badge.fury.io/js/evp-express-cli.svg"></a>
  <a href="https://nodejs.org/en"><img alt="nodejs" src="https://img.shields.io/badge/NodeJS-16.17+-black.svg"></a>
  <a href="https://www.npmjs.com/package/express"><img alt="express" src="https://img.shields.io/badge/Express-4.x-%23007fff.svg"></a>
</p>
<p><a href="https://www.murphysec.com/console/report/1671461396074487808/1671461396351311872"><img src="https://www.murphysec.com/platform3/v31/badge/1671461396351311872.svg" alt="Security Status" /></a></p>
<h2 id="文档"><a class="header" href="#文档">文档</a></h2>
<ul>
<li><a href="chapter_2/evp-express-cli.html#%E5%AE%89%E8%A3%85">安装</a></li>
<li><a href="chapter_2/evp-express-cli.html#%E7%94%A8%E6%B3%95">用法</a>
<ul>
<li><a href="chapter_2/evp-express-cli.html#%E5%91%BD%E4%BB%A4">命令</a></li>
<li><a href="chapter_2/evp-express-cli.html#%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE">新建项目</a></li>
<li><a href="chapter_2/evp-express-cli.html#%E8%BF%90%E8%A1%8C">运行</a></li>
<li><a href="chapter_2/evp-express-cli.html#%E6%A8%A1%E6%9D%BF">模板</a>
<ul>
<li><a href="chapter_2/evp-express-cli.html#%E9%AA%8C%E8%AF%81">验证</a></li>
<li><a href="chapter_2/evp-express-cli.html#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li>
<li><a href="chapter_2/evp-express-cli.html#redis">Redis</a></li>
<li><a href="chapter_2/evp-express-cli.html#auth">Auth</a></li>
<li><a href="chapter_2/evp-express-cli.html#rabbitmq">RabbitMQ</a></li>
<li><a href="chapter_2/evp-express-cli.html#socketio">SocketIO</a></li>
<li><a href="chapter_2/evp-express-cli.html#nacos">Nacos</a></li>
</ul>
</li>
<li><a href="chapter_2/evp-express-cli.html#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">开发工具</a>
<ul>
<li><a href="chapter_2/evp-express-cli.html#babel">Babel</a></li>
<li><a href="chapter_2/evp-express-cli.html#eslint">Esint</a></li>
<li><a href="chapter_2/evp-express-cli.html#jest">Jest</a></li>
<li><a href="chapter_2/evp-express-cli.html#pkg">Pkg</a></li>
<li><a href="chapter_2/evp-express-cli.html#pm2">PM2</a></li>
</ul>
</li>
<li><a href="chapter_2/evp-express-cli.html#%E8%B5%84%E6%BA%90">资源</a></li>
<li><a href="chapter_2/evp-express-cli.html#%E9%85%8D%E7%BD%AE">配置</a></li>
<li><a href="chapter_2/evp-express-cli.html#%E6%97%A5%E5%BF%97">日志</a></li>
<li><a href="chapter_2/evp-express-cli.html#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></li>
</ul>
</li>
</ul>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>安装到局部目录</p>
<pre><code class="language-shell">npm i evp-express-cli -D
</code></pre>
<p>或者全局安装</p>
<pre><code class="language-shell">npm i evp-express-cli -g
</code></pre>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<p>这里是一些示例。</p>
<h3 id="命令"><a class="header" href="#命令">命令</a></h3>
<p><code>evp-express</code>: </p>
<ul>
<li><code>-v</code>, <code>--version</code>: 显示版本</li>
<li><code>-i</code>, <code>--info</code>: 显示详细信息</li>
<li><code>-h</code>, <code>--help</code>:  显示帮助信息</li>
<li><code>new &lt;projectName&gt;</code>:  以一个特定的名字新建项目</li>
<li><code>start</code>: 启动开发服务器</li>
<li><code>clean &lt;path&gt;</code>: 删除指定路径所有文件</li>
<li><code>add &lt;template&gt;</code>: 添加指定的模板或开发工具</li>
</ul>
<h3 id="新建项目"><a class="header" href="#新建项目">新建项目</a></h3>
<p>不提前安装手脚架，直接从 npm 仓库拉取:</p>
<pre><code class="language-shell">npx evp-express-cli new &lt;projectName&gt;
</code></pre>
<p>手脚架局部安装时:</p>
<pre><code class="language-shell">npx evp-express new &lt;projectName&gt;
</code></pre>
<p>手脚架全局安装时:</p>
<pre><code class="language-shell">evp-express new &lt;projectName&gt;
</code></pre>
<h3 id="运行"><a class="header" href="#运行">运行</a></h3>
<p>切换至项目根目录下，通过以下命令运行: 
手脚架局部安装时:</p>
<pre><code class="language-shell">npx evp-express start
</code></pre>
<p>手脚架全局安装时:</p>
<pre><code class="language-shell">evp-express start
</code></pre>
<p>或者直接通过 npm 脚本:</p>
<pre><code class="language-shell">npm run start
</code></pre>
<p>或者直接通过 node:</p>
<pre><code class="language-shell">node index
</code></pre>
<h3 id="模板"><a class="header" href="#模板">模板</a></h3>
<h4 id="验证"><a class="header" href="#验证">验证</a></h4>
<p>验证中间件位于 /midwares/valider.js</p>
<p>它导出了这些东西:</p>
<pre><code class="language-js">module.exports = {
  validator,
  ValidRace,
  ValidAll,
  ValidQueue,
  ValidQueueAll
}
</code></pre>
<ul>
<li>validator 是 &quot;express-validator&quot;。</li>
<li>ValidRace 是并发的验证检验链，并抛出最早检验出错误的那个。</li>
<li>ValidAll 是并发的验证检验链，并抛出全部错误。</li>
<li>ValidQueue 是串行的验证检验链，并抛出最早检验出错误的那个。</li>
<li>ValidQueueAll 是串行的验证检验链，并抛出全部错误。</li>
</ul>
<p>示例:</p>
<pre><code class="language-js">const { validator, ValidQueue } = require('../midwares/valider');

router.get('/',
  ValidQueue([
    validator.query('name').trim().notEmpty().withMessage(&quot;name cannot be empty&quot;),
    validator.query('age').trim()
      .notEmpty().withMessage(&quot;age cannot be empty&quot;).bail()
      .isInt().withMessage(&quot;age must be Int&quot;).bail().toInt()
  ]),
(req, res, next) =&gt; {
  res.send(`Hello ${req.query.name}, you are ${req.query.age} years old!`);
});
</code></pre>
<p>你将会得到如下结果:</p>
<pre><code class="language-json">{
  &quot;code&quot;:500,
  &quot;msg&quot;:&quot;name cannot be empty&quot;,
  &quot;data&quot;:null,
  &quot;symbol&quot;:-1,
  &quot;type&quot;:&quot;Bad Request&quot;
}
</code></pre>
<h4 id="数据库"><a class="header" href="#数据库">数据库</a></h4>
<p>数据库模板使用 <strong>mysql</strong> 作为默认数据源， <strong>mysql2</strong> 作为默认数据驱动 和 <strong>knex.js</strong>作为默认数据库客户端.</p>
<p>你可以引用 knex-sqlClient 通过 <code>const { sqlClient } = require('utils/knex');</code>.</p>
<p>你可以更换任意其它的数据库，驱动和客户端. 但我强烈 <strong>建议你不要</strong> 删除 <code>utils/knex</code> 因为这个框架使用它去初始化数据库。</p>
<p>更多的配置信息可以在config.yaml找到.</p>
<h4 id="redis"><a class="header" href="#redis">Redis</a></h4>
<p>Redis模板依赖于 <strong>redis.js</strong> 丙炔不附带身份认证, 如果你需要的话可以修改 <code>utils/redisProxy</code>.</p>
<p>你可以引用 redisProxy 通过 <code>const { instance } = require('utils/redisProxy');</code>. 你可以使用 <code>instance.client</code> 去获取redis客户端实例。</p>
<p>更多的配置信息可以在config.yaml找到.</p>
<h4 id="auth"><a class="header" href="#auth">Auth</a></h4>
<p>认证模板只是安装了 <strong>passport.js</strong> 你需要自行配置。</p>
<h4 id="rabbitmq"><a class="header" href="#rabbitmq">RabbitMQ</a></h4>
<p>RabbitMQ模板依赖于 <strong>ampqlb.js</strong> 并使用 &quot;guest:guest&quot; 作为默认用户.</p>
<p>你可以引用 异步的 rabbitmqProxy 通过 <code>const { instance } = require('utils/rabbitmqProxy');</code>. 你可以使用 <code>instance.conn</code> 去获取 rabbitmq连接实例.你可以使用 <code>instance.channel</code> 去获取rabbitmq的默认通道实例。</p>
<p><strong>注意它是一个promise</strong>, 当被在任何地方引用时，请使用异步语法糖去获取实例，或者通过同步流的方式。</p>
<pre><code class="language-javascript">const { instance } = require('../utils/rabbitmqProxy');

app.get('/', async(req, res)=&gt;{
const rbmqProxy = await instance;
  const { channel: rbmq } = rbmqProxy;
  rbmq.sendToQueue(&quot;queue&quot;, &quot;hello&quot;);
})
</code></pre>
<p><strong>Or like this:</strong></p>
<pre><code class="language-javascript">const RabbitmqProxy = require('../utils/rabbitmqProxy');

app.get('/', async(req, res)=&gt;{
  const rbmqProxy = await RabbitmqProxy.instance;
  const { channel: rbmq } = rbmqProxy;
  rbmq.sendToQueue(&quot;queue&quot;, &quot;hello&quot;);
})
</code></pre>
<p><strong>Or like this:</strong></p>
<pre><code class="language-javascript">const amqplib = require('amqplib');
const RabbitmqProxy = require('../utils/rabbitmqProxy');

//@type {amqplib.Channel}
let rbmq = null;
RabbitmqProxy.instance.then(rabbitmq=&gt;{
  rbmq = rabbitmq.channel;
})

app.get('/', async(req, res)=&gt;{
  rbmq.sendToQueue(&quot;queue&quot;, &quot;hello&quot;);
})
</code></pre>
<p>更多的配置信息可以在config.yaml找到.</p>
<h4 id="socketio"><a class="header" href="#socketio">SocketIO</a></h4>
<p>SocketIO模板依赖于 <strong>socket.io</strong> 并且挂载服务器于 express-http-server 上.</p>
<p>你可以引用 socketioProxy 通过 <code>const { instance } = require('utils/socketioProxy');</code>. 你可以使用 <code>instance.server</code> 去获取 SocketIO 服务器实例。</p>
<p>更多的配置信息可以在config.yaml找到.</p>
<h4 id="nacos"><a class="header" href="#nacos">Nacos</a></h4>
<p>Nacos模板依赖于 <strong>nacos.js</strong> 并且默认使用你项目的包名作为服务名。</p>
<p>你可以引用 nacosClient 通过 <code>const { instance } = require('utils/nacosProxy');</code>. 你可以使用 <code>instance.client</code> 去获取 Nacos 客户端实例。</p>
<p>更多的配置信息可以在config.yaml找到.</p>
<h3 id="开发工具"><a class="header" href="#开发工具">开发工具</a></h3>
<h4 id="babel"><a class="header" href="#babel">Babel</a></h4>
<p>Babel工具只是安装了基本的依赖和创建了一个配置文件。</p>
<p>你需要更多的自定义它。</p>
<h4 id="eslint"><a class="header" href="#eslint">Eslint</a></h4>
<p>Eslint工具只是安装了基本的依赖</p>
<p>你需要更多的自定义它。</p>
<h4 id="jest"><a class="header" href="#jest">Jest</a></h4>
<p>Jest工具只是安装了基本的依赖和创建了一个配置文件。此外, <code>package.json's scripts.test</code> 被替换为 &quot;jest&quot;,你可以使用Jest进行快速测试通过 &quot;npm test&quot;命令.</p>
<p>你需要更多的自定义它。</p>
<h4 id="pkg"><a class="header" href="#pkg">Pkg</a></h4>
<p>Pkg工具用于构建可执行的exe程序，输出目录为dist。</p>
<p><code>package.json's scripts.build</code> 被替换为 &quot;npx pkg . --out-path dist -t node16-win-x64&quot;. 你可以进行快速的构建通过&quot;npm build&quot;命令. 默认的编译目标是 node16-win-x64, 你可以在 package.json 中修改它并且你通常需要去Github上下载对应的目标node.</p>
<h4 id="pm2"><a class="header" href="#pm2">PM2</a></h4>
<p>PM2是一个由node驱动的进程管理器. 框架创建了一个基础的配置文件(ecosystem.consig.js)</p>
<p>你可以更多的自定义它。</p>
<h3 id="资源"><a class="header" href="#资源">资源</a></h3>
<p>框架将assets目录当作资源目录，请不要修改它！</p>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<p>绝大多数配置信息被写在 assets/config.yaml 中. 你可以引用config通过 <code>global.__config</code> 或者 <code>__config</code>.</p>
<h3 id="日志-1"><a class="header" href="#日志-1">日志</a></h3>
<p>日志工具位于 /utils/logger.js</p>
<h3 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h3>
<p>异常处理中间件位于 /midwares/exhandler.js</p>
<p>导出了两个中间件: 捕捉和日志.</p>
<pre><code class="language-js">module.exports = {
  excatcher: (err, req, res, next) =&gt; {
    if (err) {
      const {code,msg,symbol,data,back} = err.message;
      if (back != false &amp;&amp; code) {
        if (code) {
          if (code == 400) {
            res.json(Resp.fail(msg, symbol??-1, data??null));
          }
          if (code == 500) {
            res.json(Resp.bad(msg, symbol??0, data??null));
          }
        } else {
          res.json(Resp.bad(err.message));
        }
      }
      next(err);
    } else {
      next();
    }
  },

  exlogger: (err,req,res,next)=&gt;{
    if (logger.level.level &lt;= 10000) {
      logger.error(err);
      return;
    }
    logger.error(err.message);
  }
}
</code></pre>
<p>通常，在捕获全局异常后，默认的是坏响应，但有时候我们不想要坏响应。</p>
<pre><code class="language-javascript">throw new Error(JSON.stringify({code:400,msg:&quot;Invalid arguments.&quot;});
</code></pre>
<p>甚至我们可能不需要返回响应，我们可以把 back 设置为 &quot;false&quot;。</p>
<pre><code class="language-javascript">throw new Error(JSON.stringify({code:400,msg:&quot;Invalid arguments.&quot;,back:false});
</code></pre>
<p>框架只预置了 200 和 400 两个code，你可以自行拓展。</p>
<hr />
<p>感谢您的使用!😊🥰</p>
<h2 id="下一章-高级进阶"><a class="header" href="#下一章-高级进阶">下一章-高级进阶</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高级进阶"><a class="header" href="#高级进阶">高级进阶</a></h1>
<p>在本章中，将介绍一些比较细节化的项目技巧，尤其是贴合express.js的</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局变量与配置文件"><a class="header" href="#全局变量与配置文件">全局变量与配置文件</a></h1>
<p>通常我们会将一些项目的配置信息写在一个文件内，然后读入内存并使用。在 express 中使用全局变量有多种方案，我们一起看看有哪些常用的方案</p>
<h2 id="准备工作-7"><a class="header" href="#准备工作-7">准备工作</a></h2>
<p>拷贝第一节的HelloWorld项目</p>
<p>准备一个Resp.js模块：</p>
<pre><code class="language-js">module.exports = {
    Ok: (...args)=&gt;{
        return {
            code: 200,
            msg: args[0]?args[0]:&quot;Ok&quot;,
            data: args[1]?args[1]:null
        }
    }
}
</code></pre>
<h2 id="global"><a class="header" href="#global">global</a></h2>
<p>在<strong>global</strong>对象中挂载我们需要全局共享的量，比如我们想要挂载一个全局的config作为整个express应用的配置，就在项目的唯一入口文件（如: index.js, app.js等）的最顶上（优先于任何模块）设置一次：</p>
<pre><code class="language-js">// index.js
global.config = {
    appname: &quot;GlobalVar&quot;
}
/** 更简洁的写法，隐变量，首次被执行到后，会自动挂载到全局
config = {
    appname: &quot;GlobalVar&quot;
}
*/
//创建app应用...
</code></pre>
<p>这样我们就可以在其它任何地方调用config，比如新建一个router.js挂载到express应用上去</p>
<pre><code class="language-js">// router.js
const routes = require('express').Router();
routes.get('/global', (req, res, next)=&gt;{
    res.send(Resp.Ok(&quot;global中的全局变量&quot;, {&quot;appname&quot;:config.appname}));
});

module.exports = routes;

// index.js
app.use(routes);
</code></pre>
<p>如果我们有很多需要全局共享的配置，挤在index.js的上方多少有点不雅观，那我们可以把它们写在一个文件里，然后在index.js最顶上引入一下</p>
<pre><code class="language-js">// global.js
global.config = {
    appname: &quot;GlobalVar&quot;
}

// index.js
require('./global');
</code></pre>
<p>**注意：**由于global中的变量是可以直接以变量名<code>xxx</code>调用的，无需<code>global.xxx</code>，如果变量名设置的比较普通，就比如上面的<code>config</code>，甚至更简单的<code>a</code>之类的，很可能跟其它模块中定义的临时变量冲突，造成变量污染，因此在global上挂载变量时取名一定要特殊点，比如：之前的<code>config</code>替换为<code>__config</code></p>
<pre><code class="language-js">global.__config = {
    appname: &quot;GlobalVar&quot;
}
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>调用很便捷</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>可能变量污染</li>
<li>没有代码提示，不心安</li>
</ul>
<h2 id="module"><a class="header" href="#module">module</a></h2>
<p>自定义一个module，存放一些变量，在需要的地方进行引入<br />
比如：我们自建一个config.js</p>
<pre><code class="language-js">// config.js
module.exports = {
    appname: &quot;GlobalVar&quot;
}
</code></pre>
<p>在router.js中引入config.js</p>
<pre><code class="language-js">// router.js
const CONFIG = require('./config');

routes.get('/module', (req, res, next)=&gt;{
    res.send(Resp.Ok(&quot;config模块当作全局变量&quot;, {&quot;appname&quot;:CONFIG.appname}));
});
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>能有代码提示</li>
<li>无变量污染</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每次都要引入，比较麻烦</li>
</ul>
<h2 id="appset"><a class="header" href="#appset">app.set</a></h2>
<p>在 express 的应用设置表中设置应用内的全局变量：</p>
<pre><code class="language-js">// index.js
app.set(&quot;appname&quot;, &quot;GlobalVar&quot;);
</code></pre>
<p>在其它地方调用app，如挂载在app上的router：</p>
<pre><code class="language-js">// router.js
routes.get('/app', (req, res, next)=&gt;{
    res.send(Resp.Ok(&quot;app中的'全局'变量&quot;, {&quot;appname&quot;:req.app.get(&quot;appname&quot;)}));
});
</code></pre>
<p>在挂载在app下的子应用中，调用父app中的设置，当某字段在子应用中没有设置时，会继承父应用中的字段</p>
<pre><code class="language-js">//subapp.js
const app = require('express')();
const Resp = require('./Resp');
//当子应用没有设置时，会继承父应用中设置的字段
// app.set('appname', &quot;subapp&quot;);
app.all('/', (req, res, next) =&gt; {
    res.send(Resp.Ok(&quot;子应用获取父应用中的全局变量&quot;, {
        appname: req.app.get(&quot;appname&quot;)
    }));
})

module.exports = app;

//index.js
const subapp = require('./subapp');
app.use('/subapp',subapp);
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>能有代码提示</li>
</ul>
<h2 id="processenv"><a class="header" href="#processenv">process.env</a></h2>
<p>在进程的环境变量中挂载全局变量：</p>
<pre><code class="language-js">//index.js
process.env.appname = &quot;GlobalVar&quot;;
</code></pre>
<p>在其它地方调用<code>process.env.appname</code>：</p>
<pre><code class="language-js">// subapp2.js
const app = require('express')();
const Resp = require('./Resp');

app.all('/', (req, res, next) =&gt; {
    // console.log(app.settings.env);
    res.send(Resp.Ok(&quot;在process.env上挂载全局变量&quot;, {
        appname: process.env.appname
    }));
})

module.exports = app;

//index.js
const subapp2 = require('./subapp2');
app.use('/process.env',subapp2);
</code></pre>
<p><strong>缺点：</strong></p>
<ul>
<li>没有代码提示，不心安</li>
</ul>
<h2 id="json-1"><a class="header" href="#json-1">json</a></h2>
<p>以上的方案都是将配置信息写在js文件中的，对于一个正规的项目来说多少有点儿戏，毕竟写在js中的变量是很容易就能被改变的。绝大多数时候，配置信息是需要变化也不允许变化的，我们只需要静态的信息即可。在Js项目中，经常用json文件作为静态配置文件。</p>
<p>新建一个<strong>config.json</strong>文件：</p>
<pre><code class="language-json">{
	&quot;appname&quot;: &quot;GlobalVar&quot;
}
</code></pre>
<p>在我们的router中新加一条测试一下，不管你在哪里require，在首次被require之后，修改json文件内容将不会再产生影响</p>
<pre><code class="language-JS">routes.get('/json', (req, res, next)=&gt;{
    let configJson = require('./config.json');
    res.send(Resp.Ok(&quot;json静态配置文件&quot;, {&quot;appname&quot;:configJson.appname}));
});
</code></pre>
<p>json文件不支持注释，如果想要注释，要么曲线救国(加与被备注键相关的键值对)，要么使用<strong>Json5</strong>规范</p>
<pre><code class="language-shell">npm install json5
</code></pre>
<p>新建一个<strong>config.json5</strong>文件：</p>
<pre><code class="language-json5">{
    &quot;appname&quot;: &quot;GlobalVar&quot;  //应用名
}
</code></pre>
<p>接着在项目的入口文件中引入register，会挂载到全局：</p>
<pre><code class="language-js">require('json5/lib/register');
</code></pre>
<p>之后require就可以解析<code>json5</code>文件了：</p>
<pre><code class="language-js">routes.get('/json5', (req, res, next)=&gt;{
    let configJson5 = require('./config.json5');
    res.send(Resp.Ok(&quot;json5静态配置文件&quot;, {&quot;appname&quot;:configJson5.appname}));
});
</code></pre>
<h2 id="yaml"><a class="header" href="#yaml">yaml</a></h2>
<p>相比<code>.json</code>文件，<code>.yaml</code>(或<code>.yml</code>)文件是更加现在的配置文件，json文件有着严格的格式要求，yaml(yml)书写起来则更加自然<br />
新建一个<strong>config.yaml</strong>文件：</p>
<pre><code class="language-yaml"># 应用名
appname: GlobalVar  # 应用名
</code></pre>
<p>在nodeJs中读取yaml需要借助<strong>fs</strong>和<strong>js-yaml</strong>：</p>
<pre><code class="language-shell">npm install fs
npm install js-yaml
</code></pre>
<p>把fs挂载到全局即可(之前的global.js)，一般情况下也不会取fs这样的局部变量名，如果需要频繁的操作文件，挂载到全局后会方便很多：</p>
<pre><code class="language-js">global.fs = require('fs');
</code></pre>
<p>在router.js中引入<code>js-yaml</code>并新建一个测试路由：</p>
<pre><code class="language-js">const yaml = require('js-yaml');

routes.get('/yaml', (req, res, next)=&gt;{
    /*Object */
    let configYaml = yaml.load(fs.readFileSync('./config.yaml'));
    res.send(Resp.Ok(&quot;yaml动态配置文件&quot;, {&quot;appname&quot;:configYaml.appname}));
});
</code></pre>
<p>由于是通过fs读取yaml文件的，因此在改变yaml文件中的内容后，访问路由的结果也会变</p>
<hr />
<p>本文总共介绍了6种方案，在项目具体采用哪种并没有绝对的说法，因地制宜即可。</p>
<h2 id="下一节-错误分类和日志分级"><a class="header" href="#下一节-错误分类和日志分级">下一节-错误分类和日志分级</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异常分类和日志分级"><a class="header" href="#异常分类和日志分级">异常分类和日志分级</a></h1>
<p>第一章已经介绍过全局的异常处理了，但之前的做法过于简单，一股脑的捕获并返回。这一节我们将对异常进行细致的分类，并且日志也做标准化的分级。</p>
<h2 id="准备工作-8"><a class="header" href="#准备工作-8">准备工作</a></h2>
<p>一个基础的 evp-express 项目</p>
<h2 id="nodejs-error"><a class="header" href="#nodejs-error">NodeJS Error</a></h2>
<p>先了解一下 NodeJS 里面的异常：</p>
<blockquote>
<p>JavaScript 异常是由于无效操作或作为 throw 语句的目标而抛出的值。 虽然不要求这些值是 Error 的实例或从 Error 继承的类，但 Node.js 或 JavaScript 运行时抛出的所有异常都将是 Error 的实例。</p>
</blockquote>
<p>在 NodeJS 中，所有抛出（throw）的异常都可以被归为通用的 <strong>Error</strong>，此外还内置了更细分的 AssertionError, SystemError, SyntaxError 等。</p>
<p><strong>Error：</strong></p>
<ul>
<li><code>new Error(message[, options])</code></li>
<li><code>error.cause</code>：引起 error 的根本原因，可以在 new 时的options中加入</li>
<li><code>error.message</code>：错误的描述</li>
<li><code>error.stack</code>：错误栈，产生 error 的位置</li>
</ul>
<h2 id="异常分类"><a class="header" href="#异常分类">异常分类</a></h2>
<p>evp-express 的错误中间件已经把异常分类做好了，分成两部分 excather 和 exlogger，excatcher 捕获并处理异常，exlogger 则记录日志。我们先来看怎么对异常自定义分类。</p>
<h3 id="自定义分类"><a class="header" href="#自定义分类">自定义分类</a></h3>
<p>自定义分类的方法，其实很简单，无非是在抛出的异常上增加用以标识分类的属性即可。我没有选择这种方式，手动抛出时要略微多写几行代码，error.message 是一个描述字符串，我选择抛出自定义异常时，传递的message是一个json字符串，json里面再放置具体描述，分类信息以及其它等等的信息载体。</p>
<pre><code class="language-js">throw new Error(JSON.stringfy(
  code: 400,
  msg: &quot;自定义异常1&quot;,
  back: true
));
</code></pre>
<p>接下来看看异常处理器如何处理自定义异常和其它异常。</p>
<h3 id="excatcher"><a class="header" href="#excatcher">excatcher</a></h3>
<p>excatcher做了三件事，捕获异常，解析异常和根据策略调取异常处理器。</p>
<ul>
<li>解析异常：首先尝试将 err.message 作为 json 字符串解析，如果能解析，说明是我们自定义的异常，如果解析失败，说明是其它的异常，就当作普通的 Error 处理。</li>
<li>处理自定义异常：自定义异常的载体我总共设置了6个属性：code（分类码），msg（描述信息），symbol（业务码/异常码），data（数据），back（是否返回给前端具体描述）和 status（http状态码）。back置非，就返回通用的系统异常错误给前端；back置是，则根据 code（分类码）从异常处理策略中取出对应的处理器处理结果，如果找不到对应的处理器或者 code 没传，就还是返回统一的系统异常给前端。处理完异常之后，把异常再传递给 exlogger 中间件，去记录异常的日志。</li>
<li>异常处理策略：在处理不同的异常上，使用了策略模式，增强代码的可维护性。</li>
</ul>
<pre><code class="language-js">excatcher: (err, req, res, next) =&gt; {
  if (err) {
    try {
      const payload = JSON.parse(err.message);
      const {code,msg,symbol,data,back,status} = payload;
      if (back != false) {
        const handler = exhandleStrategy.get(code);
        if ( handler ) { handler(res,msg,symbol,data,status); }
        else { res.json(Resp.bad(&quot;System Exception&quot;)); }
      } else {
        res.json(Resp.bad(&quot;System Exception&quot;));
      }
    } catch (_) { // cannot be parsed to JSON object =&gt; common error
      res.json(Resp.bad(&quot;System Exception&quot;));
    }
    next(err);
  } else {
    next();
  }
},
</code></pre>
<p><strong>exhandleStrategy：</strong></p>
<pre><code class="language-js">const exhandleStrategy = new Map();

exhandleStrategy.set(400, (res, ...args)=&gt;{
  const [msg,symbol,data,status] = args;
  if (status) {
    res.status(status).json(Resp.fail(msg, symbol??-1, data??null));
  } else {
    res.json(Resp.fail(msg, symbol??-1, data??null));
  }
});

exhandleStrategy.set(500, (res, ...args)=&gt;{
  const [msg,symbol,data,status] = args;
  if (status) {
    res.status(status).json(Resp.bad(msg));
  } else {
    res.json(Resp.bad(msg));
  }
})
</code></pre>
<p>接下来我们看看 exlogger</p>
<h2 id="exlogger"><a class="header" href="#exlogger">exlogger</a></h2>
<p>exlogger 进行了一个判断，如果当前日志级别 &lt;= 10000，即 <strong>DEBUG</strong>，就记录完整的异常信息，否则只记录异常的描述信息。</p>
<pre><code class="language-js">exlogger: (err,req,res,next)=&gt;{
  if (logger.level.level &lt;= 10000) {
    logger.error(err);
    return;
  }
  logger.error(err.message);
}
</code></pre>
<p>logger是什么呢？这是 log4js 的日志器，让我们来看看<code>utils/logger.js</code></p>
<h2 id="log4js标准化日志"><a class="header" href="#log4js标准化日志">log4js标准化日志</a></h2>
<p>我们使用 <strong>log4js.js</strong> 作为日志框架，log4js.configure 配置了 log4js 的基本配置，日志格式，日志方式（输出、文件等）、日志级别等，日志级别从 evp-express 的项目配置信息中读取而得。</p>
<pre><code class="language-js">const config = require('../config').get();
const log4js = require('log4js');

let logger = log4js.getLogger(&quot;&quot;);
    
log4js.configure({
  appenders: {
    out: {
      type: &quot;stdout&quot;,
      layout: {
          &quot;type&quot;: &quot;pattern&quot;,
          &quot;pattern&quot;: &quot;[%d{yyyy-MM-dd hh:mm:ss}] %p %m&quot;
      }
    }
  },
  categories: {
    default: {
      appenders: [&quot;out&quot;],
      level: config.log4js.level
    }
  }
})

module.exports = logger;
</code></pre>
<p>日志级别总共有 <strong>&quot;ALL&quot;</strong>，<strong>&quot;TRACE&quot;</strong>, <strong>&quot;DEBUG&quot;</strong>, <strong>&quot;INFO&quot;</strong>, <strong>&quot;WARN&quot;</strong>, <strong>&quot;ERROR&quot;</strong>, <strong>&quot;FATAL&quot;</strong>（致命）, <strong>&quot;MARK&quot;</strong>, <strong>&quot;OFF&quot;</strong>（关闭） 这几级（大小写均支持），重要性逐级递增，在当前设置的 level 之下的日志将不会被记录，如日志级别设置为 <strong>&quot;INFO&quot;</strong>，则 <strong>logger.all</strong>, <strong>logger.trace</strong>, <strong>logger.debug</strong> 将不会进行日志记录。</p>
<p>这些文字的级别对应以下数字，依次为 <code>5e-324</code>, <code>5000</code>, <code>10000</code>, <code>20000</code>, <code>30000</code>, <code>40000</code>, <code>50000</code>, <code>9007199254740992</code>, <code>1.7976931348623157e+308</code></p>
<p>日志器当前的级别可由 <code>logger.level</code> 或者 <code>logger.level.levelStr</code> 获取，当前级别对应的数字可由 <code>logger.level.level</code> 获取，不过还是更建议自定义一个数组或者Map，把所有的级别文字按序放入，然后需要的时候根据索引来判断级别的高低。</p>
<h2 id="下一节-数据库初始化"><a class="header" href="#下一节-数据库初始化">下一节-数据库初始化</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库初始化"><a class="header" href="#数据库初始化">数据库初始化</a></h1>
<p>        在软件开发阶段和测试阶段，为了方便调试，我们通常会进行一系列的数据库初始化操作，比如重置数据表，插入记录等等，或者在部署阶段进行数据初始化的操作</p>
<p>        根据前面章节介绍过的 <code>knex.js</code> 和 <code>sequelize.js</code>，我们可以利用它们提供的方法进行DDL，本节就数据库表重置的初始化行为做一点探讨，表结果为<code>User{id: num, name: string, age: num}</code>，数据库采用sqlite</p>
<h2 id="knex-ddl"><a class="header" href="#knex-ddl">Knex DDL</a></h2>
<p>以下是利用 <code>knex.schema</code> 的一个简单示例:<br />
<strong>knex.js</strong></p>
<pre><code class="language-js">const knex = require('knex');
const fs = require('fs');

const sqlClient = knex({
    client: 'sqlite3',
    connection: {
        filename: `${__root}/db/data.db`,
        acquireConnectionTimeout: 1000
    },
    useNullAsDefault: true
});

module.exports = sqlClient;
</code></pre>
<p><strong>init.js</strong></p>
<pre><code class="language-js">global.__root = __dirname;

const knex = require('./knex.js');

const drop = knex.schema.dropTableIfExists('user');
const create = knex.schema.createTable('user', (user)=&gt;{
    user.increments('id').notNullable().primary();
    user.text('name').notNullable();
    user.integer('age').notNullable()
});
const promises = [drop,create];
Promise.all(promises)
.then(res=&gt;{
    console.log('Database inits successfully!')
}).catch(err=&gt;{
    console.error(err);
})
</code></pre>
<h2 id="sequelize-ddl"><a class="header" href="#sequelize-ddl">Sequelize DDL</a></h2>
<p>以下是利用 <code>Sequelize.Model</code> 的一个简单示例:<br />
<strong>sequelize.js</strong></p>
<pre><code class="language-js">const { Sequelize,DataTypes,Model } = require('sequelize');
const fs = require('fs');

const sqlClient = new Sequelize({
    dialect: 'sqlite',
    storage: `${__root}/db/data.db`
})

const User = sqlClient.define('User', {
    id: {
        primaryKey: true,
        type: DataTypes.INTEGER,
        allowNull: false,
        autoIncrement: true
    },
    name: {
        type: DataTypes.STRING,
        allowNull: false
    },
    age: {
        type: DataTypes.INTEGER,
        allowNull: false
    }
}, {
    tableName: 'user',
    timestamps: false,
});

module.exports = {
    sqlz: sqlClient,
    User
}
</code></pre>
<p><strong>init.js</strong></p>
<pre><code class="language-js">global.__root = __dirname;

const { User } = require('./sequelize');

// User.drop();User.sync();
User.sync({ force: true })  //这个相当于前两个的结合体
    .then(res=&gt;{
        console.log('Database inits successfully!');
    }).catch(err=&gt;{
    console.error(err);
})
</code></pre>
<h2 id="sql文件"><a class="header" href="#sql文件">SQL文件</a></h2>
<p>        Springboot作为Web后端最流行的框架之一，想必各位都接触过或者听说过，在Springboot中，可以在配置文件中设置sql脚本的路径，在项目启动时执行sql脚本来完成初始化。
        这是一种非常好的方法，因为有时候我们项目场景下的数据库表结构与关系可能非常复杂，而且不同语言，不同框架的实现有些区别，用代码去完成初始化操作将是一件非常麻烦的事，既然SQL是关系型数据库通用的语言，那我们就可以通过SQL脚本来定义数据库表的结构和关系，可以手写SQL脚本，也可以借助如Navicat之类的工具设计表然后转储sql脚本，然后交给我们的程序去执行，或者手动执行。</p>
<p>Node的sql框架千千万，我在几个主流框架中似乎都没看到有提供执行sql文件的特性，其实没那么复杂，不从构造完美的框架角度，仅以为项目服务的角度考虑来说是这样的，接下来我们就来简单实现一下通过sql脚本去初始化数据库。</p>
<p>有两条路：</p>
<ol>
<li>运行环境先安装sqlite3客户端，node读取sql脚本内容，node通过<code>exec</code>去指定目录下，打开sqlite3命令行连接sqlite数据库，同时把sql内容传递过去，在sqlite3中执行sql脚本完成数据库初始化操作</li>
<li>Node安装sqlite3依赖，通过sql框架连接sqlite数据库，node读取sql脚本内容，对内容进行规范化处理只剩下纯净的sql语句后，交给sql框架以sql语句的形式去运行</li>
</ol>
<p>Springboot采用的就是第2种方法，那我们也在Node中实现一下吧<br />
实现准备好sql脚本 <strong>schemal.sql</strong>：</p>
<pre><code class="language-sql">-- 先删除user表
DROP TABLE IF EXISTS `user`;
-- 定义表结构，并创建user表
CREATE TABLE `user` (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,  --自增主键
    name TEXT NOT NULL,
    age INTEGER NOT NULL
);

</code></pre>
<h3 id="knex"><a class="header" href="#knex">Knex</a></h3>
<p>先用Knex作为sql框架做个示范。获取到项目根目录路径后，建立数据库连接：
<strong>knex.js</strong></p>
<pre><code class="language-js">const knex = require('knex');
const fs = require('fs');

const sqlClient = knex({
    client: 'sqlite3',
    connection: {
        filename: `${__root}/db/data.db`,
        acquireConnectionTimeout: 1000
    },
    useNullAsDefault: true
});

module.exports = sqlClient;
</code></pre>
<p>接下来，为客户端实现执行sql文件的方法：</p>
<ol>
<li>定义<code>runSql</code>方法的传参和返回<br />
我这里传入sql文件的路径，返回sql语句执行的promise链</li>
<li>内部实现，首先通过<code>fs</code>模块读取sql脚本内容并转为字符串</li>
<li>把内容中的注释去掉</li>
<li>去掉内容首尾的空格</li>
<li>去掉<code>\r</code></li>
<li>去掉<code>\n</code>（我为了打印sql语段时更加美观，省去了这一步，不影响执行结果）</li>
<li>把内容按照<code>;</code>号分割成一个个独立的sql语句字串</li>
<li>过滤掉空字串(由每2个sql语句间的空格形成)</li>
</ol>
<pre><code class="language-js">sqlClient.runSql = (path)=&gt;{
    const script = fs.readFileSync(path).toString();
    console.log(&quot;Going to run a sql file:&quot;);
    console.log(script);
    /**
     * 拆成一句句sql来执行是因为，knex执行一串语句时，会把它们都算进一个事务内
     * 利用正则忽略注释
     * 去首尾空格
     * 按冒号分句
     * 校验字串是否为sql语句
     * @type {string[]}
     */
    const sqls = script.replace(/\/\*[\s\S]*?\*\/|(--|\#)[^\r\n]*/gm, '').trim().replaceAll('\r','').split(';').filter(str=&gt;{
        return str.trim() ? true : false;
    });
    console.log(&quot;sqls&quot;);
    console.log(sqls);
    console.log(&quot;start run:&quot;);
    const promises = sqls.map(sql=&gt;{
        sql += ';';  // knex会自动补上冒号，加不加无所谓其实
        console.log(&quot;Going to run a sql:&quot;);
        console.log(sql);
        return sqlClient.raw(sql);
    })
    return promises;
}
</code></pre>
<p>到这里，我们就得到了纯净的一条条sql语句，接下来把sql语句丢给<code>knex</code>即可：
<strong>init.js</strong></p>
<pre><code class="language-js">global.__root = __dirname;

const knex = require('./knex.js')

const promises = knex.runSql(`${__root}/db/schema.sql`);
Promise.all(promises)
    .then(res=&gt;{
        console.log(&quot;Database inits successfully!&quot;)
    }).catch(err=&gt;{
    console.error(err);
})
</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code class="language-shell">D:\Workstation\gitee-localRepo\express-demo\DatabaseInit&gt;node index.js
Going to run a sql file:
-- 先删除user表
DROP TABLE IF EXISTS `user`;
-- 定义表结构，并创建user表
CREATE TABLE `user` (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,  --自增主键
    name TEXT NOT NULL,
    age INTEGER NOT NULL
);

sqls
[
  'DROP TABLE IF EXISTS `user`',
  '\n' +
    '\n' +
    'CREATE TABLE `user` (\n' +
    '    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,  \n' +
    '    name TEXT NOT NULL,\n' +
    '    age INTEGER NOT NULL\n' +
    ')'
]
start run:
Going to run a sql:
DROP TABLE IF EXISTS `user`;
Going to run a sql:


CREATE TABLE `user` (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    age INTEGER NOT NULL
);
Server is ready on http://:::8080
Database inits successfully!
</code></pre>
<p>很好，我们可以很清晰的看到sql的执行过程</p>
<h3 id="sequelize"><a class="header" href="#sequelize">Sequelize</a></h3>
<p>        如果你把<code>knex</code>这套照搬过去，把<code>knex.raw</code>换成<code>sequelize.query</code>，你也许会尴尬的发现，不太对劲，它先创建了user表，接着又把它给删了，还大言不惭地打印了成功信息（我的环境下是这样，不清楚别人会不会，但既然发生了就说明存在一定的问题）。尝试反复执行knex示例和seuelize示例，前者永远正确，后者永远错误，而且sequelize似乎更慢一点，产生这样的区别，可能是它们执行sql语句的实现机制不太一样，花费精力去看它源码没有必要，既然在这个场景下我们这两个步骤有着明确的先后顺序，那我们就通过async/await让它们完全的顺序执行即可：</p>
<pre><code class="language-js">sqlClient.runSql = async (path)=&gt; {
    const script = fs.readFileSync(path).toString();
    console.log(&quot;Going to run a sql file:&quot;);
    console.log(script);
    /**
     * 拆成一句句sql来执行是因为，knex执行一串语句时，会把它们都算进一个事务内
     * 忽略注释
     * 去首尾空格
     * 按冒号分句
     * 校验字串是否为sql语句
     * @type {string[]}
     */
    const sqls = script.replace(/\/\*[\s\S]*?\*\/|(--|\#)[^\r\n]*/gm, '').trim().replaceAll('\r','').split(';').filter(str=&gt;{
        return str.trim() ? true : false;
    });
    console.log(&quot;sqls&quot;);
    console.log(sqls);
    console.log(&quot;start run:&quot;);
    for (let sql of sqls) {
        const res = await sqlClient.query(`${sql};`);
    }
}
</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code class="language-shell">D:\Workstation\gitee-localRepo\express-demo\DatabaseInit&gt;node index.js
Going to run a sql file:
-- 先删除user表
DROP TABLE IF EXISTS `user`;
-- 定义表结构，并创建user表
CREATE TABLE `user` (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,  --自增主键
    name TEXT NOT NULL,
    age INTEGER NOT NULL
);

sqls
[
  'DROP TABLE IF EXISTS `user`',
  '\n' +
    '\n' +
    'CREATE TABLE `user` (\n' +
    '    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,  \n' +
    '    name TEXT NOT NULL,\n' +
    '    age INTEGER NOT NULL\n' +
    ')'
]
start run:
Server is ready on http://:::8080
Executing (default): DROP TABLE IF EXISTS `user`;
Executing (default): CREATE TABLE `user` (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    age INTEGER NOT NULL
);
Database inits successfully!
</code></pre>
<p>Ok！现在Sequelize也按照我们的意愿完成了重置user表的初始化工作</p>
<hr />
<p>如果初始化过程中涉及严格的先后顺序，务必做好同步流甚至回滚机制。此外，在实际项目中，为了项目的代码规范性，应当将数据库路径，初始化脚本路径都写在配置文件中，而不是像本节为了方便直接写在需要调用的js文件中。</p>
<h2 id="下一节-页面渲染"><a class="header" href="#下一节-页面渲染">下一节-页面渲染</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="页面渲染"><a class="header" href="#页面渲染">页面渲染</a></h1>
<p>常见的页面分为两种，一种是静态页面，比如用 Vue、React 等写好的静态页面，另一种是动态模板页面，如 Thymeleaf，JSP 等。</p>
<p>本节将简要介绍如何在 express 中渲染静态页面，以及适用于 express 的模板引擎 <strong>pug</strong> 。</p>
<h2 id="配置开放资源"><a class="header" href="#配置开放资源">配置开放资源</a></h2>
<p>写前端的和搞部署的同学应该都清除，页面渲染的用到的 css, js, fonts, images 等都是静态资源，部署的时候需要在服务器端放行并配置一个正确的路径。</p>
<p>Express 内置了一个 static 中间件来托管静态资源：<code>express.static(root, [options])</code></p>
<p>大致用法如下：</p>
<pre><code class="language-js">app.use(URL, express.static(PATH));
</code></pre>
<p>URL是外界访问静态资源的前缀路径，PATH则是资源资源目录的位置，可以是相对路径也可以是绝对路径。</p>
<h2 id="渲染静态页面"><a class="header" href="#渲染静态页面">渲染静态页面</a></h2>
<p>为了方便演示，我用 evp-express-cli 快速创建了一个 express 后端，并使用 Svelte 快速构建了一个简单的页面，而且已经构建好了，构建产物就在svelte/public目录。</p>
<p>为了方便和模板页面区分，我决定把静态目录设为public，并让我们的静态页面展示在 <code>/static</code> 路由下</p>
<ol>
<li>拷贝静态页面到我们准备开放的public下面</li>
<li>配置静态页面获取资源的路径
原本的css,js等等路径都是在<code>/</code>下的，我们调整到<code>/static/</code>下面去</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset='utf-8'&gt;
	&lt;meta name='viewport' content='width=device-width,initial-scale=1'&gt;

	&lt;title&gt;Svelte app&lt;/title&gt;

	&lt;link rel='icon' type='image/png' href='/static/favicon.png'&gt;
	&lt;link rel='stylesheet' href='/static/global.css'&gt;
	&lt;link rel='stylesheet' href='/static/build/bundle.css'&gt;

	&lt;script defer src='/static/build/bundle.js'&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="3">
<li>在 express 中设置静态资源路径，src\app.js</li>
</ol>
<pre><code class="language-js">app.use('/static', express.static(path.join(__dirname, '../public')));
</code></pre>
<ol start="4">
<li>此时运行后端，访问 static 路由即可正常显示我们的静态 svelte 页面</li>
</ol>
<p>其它的前端框架 Vue、React 等都是类似的，就不介绍了。</p>
<h2 id="模板引擎-pug"><a class="header" href="#模板引擎-pug">模板引擎 pug</a></h2>
<p>可以用的模板引擎有很多，express 官方推荐了 pug，那我们就用 pug吧</p>
<p>还是在刚才那个项目，先安装 pug 依赖：</p>
<pre><code class="language-shell">npm install pug
</code></pre>
<p>这次，我打算让 pug 页面渲染在 <code>/views/</code> 路由下，在根目录创建一个 views 目录</p>
<ol>
<li>在 app.js 中设置页面引擎为 pug</li>
</ol>
<pre><code class="language-js">app.set('view engine', 'pug');
</code></pre>
<ol start="2">
<li>在 <code>/views</code> 路由上渲染pug页面</li>
</ol>
<pre><code class="language-js">app.get('/views', (req,res)=&gt; {
  res.render('index', { title: 'express-pug-demo', message: 'Welcome to express pug!'});
})
</code></pre>
<p>后面的是我们给 pug 模板传递的参数，既然是动态页面了，自然要体验一下数据交互
3. 在 views 目录下创建index.pug 和 css目录
4. 在 index.pug 中写页面，传进来的参数相当于全局变量，可以直接引用；我们还自定义了一个常量，放到 a 标签上，并引入了 css/index.css 作为页面样式</p>
<pre><code class="language-pug">- const express_demo = 'https://jun-laner.gitee.io/express-demo'

doctype html
html 
  head 
    title= title
    style
      include css/index.css
  body
    div(class=&quot;container&quot;)
      h1= message
      a(href= express_demo, target= '_blank') Go to express-demo
</code></pre>
<ol start="5">
<li>css目录下创建 index.css 并写入样式</li>
</ol>
<pre><code class="language-css">.container {
  text-align: center;
  padding-bottom: 28px;
}
</code></pre>
<p>此时重启服务器，并访问 views 即可正常渲染 pug 页面</p>
<h2 id="pug-用法简介"><a class="header" href="#pug-用法简介">pug 用法简介</a></h2>
<p>接下来，我们简要介绍一下 pug 的语法（可以直接拉取本节的源码并运行，pug的用法都写在了示范的pug页面中）</p>
<h3 id="标签"><a class="header" href="#标签">标签</a></h3>
<p>在 html 中的标签在 pug 中不能加书名号了，并且会自闭和，无须手动闭合，如：
html:</p>
<pre><code class="language-html">&lt;p&gt;
	hello, world!
&lt;/p&gt;
</code></pre>
<p>pug:</p>
<pre><code class="language-pug">p hello, world!
</code></pre>
<p>需要注意的是，html中因为标签是闭合的，所以标签上下、标签之间可以不严谨的对齐，但是 pug 标签必须对齐，排列在它应该排列的列范围内，缩进了才代表这个标签囊括在上一级标签下。</p>
<h3 id="文档类型"><a class="header" href="#文档类型">文档类型</a></h3>
<p>Doctype，通常我们指定为 html 即可，其实就是 html 文件的头</p>
<pre><code class="language-pug">doctype html
html 
//...
</code></pre>
<h3 id="定义变量"><a class="header" href="#定义变量">定义变量</a></h3>
<p>在 pug 中我们可以写 js 脚本，定义变量，然后嵌入到标签中去渲染</p>
<pre><code class="language-pug">- const hello_msg=&quot;Welcome to express pug!

//...
  span #{hello_msg}
</code></pre>
<p>把变量赋给标签内容，可以像上面那种模板嵌入，也可以直接赋予</p>
<pre><code class="language-pug">span= hello_msg
</code></pre>
<h3 id="代码块"><a class="header" href="#代码块">代码块</a></h3>
<p>如果你的 js 代码很长，不方便写在一行，比如定义一个数组</p>
<p>错误示范，这样子是错误的，这是单行脚本的写法</p>
<pre><code class="language-pug">- const list = [
    &quot;a&quot;,
    &quot;b&quot;,
  ]
</code></pre>
<p>正确示范，空出一行即可：</p>
<pre><code class="language-pug">- 
  const list = [
    &quot;a&quot;,
    &quot;b&quot;,
  ]
</code></pre>
<h3 id="标签属性"><a class="header" href="#标签属性">标签属性</a></h3>
<p>通常我们需要给标签赋予一些属性，比如元素的类名、a 标签的地址、图片的地址等等</p>
<pre><code class="language-pug">a(href= express_demo, target= &quot;_blank&quot;) Go to express-demo'
</code></pre>
<p>多个属性用逗号分隔开，变量直接赋给属性，硬编码的属性则以字符串传入</p>
<h3 id="列表渲染"><a class="header" href="#列表渲染">列表渲染</a></h3>
<p>通常我们会需要渲染列表，vue 中有 <code>v-for</code>，React用 map 迭代列表，而 pug 可以用 <code>each in</code> 直接迭代列表</p>
<pre><code>- const apps = [{ name: &quot;qq&quot; },{ name: &quot;wechat&quot; },{ name: &quot;ins&quot; }]

  each app in list
    p #{app.name}
</code></pre>
<p>注意缩进，迭代的元素要缩进到 each 下级</p>
<h3 id="if-分支"><a class="header" href="#if-分支">If 分支</a></h3>
<p>如果遇到需要条件渲染的地方，可以这样写</p>
<pre><code class="language-pug">if hello_msg
  span hello_msg exists!
</code></pre>
<h3 id="case-分支"><a class="header" href="#case-分支">Case 分支</a></h3>
<p>如果有条件有多个值，可以用 case 来替换 if</p>
<pre><code class="language-pug">- const day = 1;

case day
  when 1
    span Monday
  default
    span Unknown
</code></pre>
<h3 id="引入外部文件"><a class="header" href="#引入外部文件">引入外部文件</a></h3>
<p>学过 JSP 的应该记得 JSP 里面就有 include，pug 的include 可以引入一个 pug，引入其它文件则会被当作文本</p>
<p>我们可以用 include 来导入外部CSS：</p>
<pre><code class="language-pug">html 
  head 
    title= title
    style
      include css/index.css
</code></pre>
<p>如果你想用 link 的方式导入CSS，也可以，但 express 后端必须把对应目录设置为静态资源</p>
<pre><code class="language-pug">html 
  head 
    title= title
    link(rel='stylesheet', href='css/index.css') //- 如果要href引入，必须在express中设置为静态资源
</code></pre>
<p>设置 views 为资源目录：</p>
<pre><code class="language-js">app.use('/views', express.static(path.join(__dirname, '../views')));
</code></pre>
<h3 id="样式"><a class="header" href="#样式">样式</a></h3>
<p>上面已经介绍从外部引入样式办法，这里再补充一下在 pug 中如何直接写样式：</p>
<pre><code class="language-pug">style.
 h1 {
 	color: green;
 }
</code></pre>
<p>style标签后面的那个 <code>.</code> 不要忘记，剩下的样式就按常规的CSS写法即可</p>
<h3 id="过滤器"><a class="header" href="#过滤器">过滤器</a></h3>
<p>过滤器可以用于渲染特定的片段，需要借助插件实现，当然也可以自定义</p>
<p>以渲染 markdown 为例，先安装 markdown 依赖</p>
<pre><code class="language-shell">npm install jstransformer-markdown-it
</code></pre>
<p>然后划定一块区域，放置我们的markdown</p>
<pre><code class="language-pug">div(class=&quot;md&quot;)
  :markdown-it(linkify langPrefix='highlight-js')
  # Markdown
  use markdown in pug file
  ## example
  this is example
  # Thanks For Reading this Article
</code></pre>
<hr />
<p>页面渲染就介绍到这里，重要的静态资源配置，模板页面通常其实用不到，如果需要，更详细的用法可以关注 pug 官方手册</p>
<h2 id="下一节-express-validator"><a class="header" href="#下一节-express-validator">下一节-express-validator</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="express-validator"><a class="header" href="#express-validator">express-validator</a></h1>
<p>express.js 集成 express-validator进行数据校验</p>
<p>在最初的时候，对于请求的数据校验，我们是自定义一个中间件，然后在里面通过最原生的方式检验。在本节，我们将尝试用一种更优雅的方式进行数据校验。</p>
<h2 id="准备工作-9"><a class="header" href="#准备工作-9">准备工作</a></h2>
<p>创建一个基础的 express 项目（本文基于evp-express-cli），并支持全局同步和异步错误错误处理。</p>
<p><strong>安装express-validator，并引入:</strong></p>
<pre><code class="language-console">npm i express-validator
</code></pre>
<pre><code class="language-js">const validator = require('express-validator');
</code></pre>
<h2 id="验证链"><a class="header" href="#验证链">验证链</a></h2>
<p>validator:</p>
<ul>
<li>body()</li>
<li>cookie()</li>
<li>header()</li>
<li>param()</li>
<li>query()</li>
</ul>
<p>以<code>validator.query</code>为例，我们可以检查query参数中的某一项</p>
<pre><code class="language-js">router.get('/greet', 
	validator.query('person').trim().notEmpty().escape().withMessage(&quot;person不能为空&quot;),
(req, res, next) =&gt; {
  const valires = validator.validationResult(req);
  if (!valires.isEmpty()) {
    const err = new Error(valires.array()[0].msg);
    throw err;
  }
  logger.info(`Hello ${req.query.person}!`);
  res.send(`Hello ${req.query.person}!`);
});
</code></pre>
<p>validationResult()用法获取校验结果，valires是校验结果，主要结构如下：</p>
<pre><code class="language-ts">{
  //...
	errors: []
}
</code></pre>
<p>errors需要通过valires.array()来得到，当然序列反序列化也行
每一项error结构如下：</p>
<pre><code class="language-ts">{
	&quot;type&quot;: string,
	&quot;msg&quot;: string,
	&quot;path&quot;: string, //如上面检查的person
	&quot;location&quot;: string //如query,body..
}
</code></pre>
<p>如果需要检验多个参数，就放进数组即可：</p>
<pre><code class="language-js">[
  validator.query('person').trim().notEmpty().escape().withMessage(&quot;person不能为空&quot;),
  validator.query('address').trim().notEmpty().escape().withMessage(&quot;address不能为空&quot;)
]
</code></pre>
<h2 id="封装剥离"><a class="header" href="#封装剥离">封装剥离</a></h2>
<p>之前的写法，是把错误处理和定义都直接写在路由上，臃肿且代码侵入性较强，我们可以进一步封装：</p>
<p><strong>Checker:</strong><br />
这个示例采取了检验并发竞赛的机制，你也可以使用其它的并发或者同步机制:</p>
<pre><code class="language-js">/**
 * Validator Race checker
 * @param {validator.ValidationChain[]} validChain 
 * @returns 
 */
const ValidRace = (validChain)=&gt;{
  return async (req, res, next) =&gt; {
    await Promise.race(validChain.map(validate =&gt; validate.run(req)))
    const valires = validator.validationResult(req);
    if (!valires.isEmpty()) {
      console.log(valires.array());
      const err = new Error(valires.array()[0].msg);
      throw err;
    }
    next();
  }
}
</code></pre>
<p>然后在路由上使用即可:</p>
<pre><code class="language-js">router.get('/greet2',
  ValidRace([
    validator.query('age').trim()
      .notEmpty().withMessage(&quot;age不能为空&quot;).bail()
      .isInt().withMessage(&quot;age必须是正整数&quot;).bail().toInt()
  ]),
(req, res, next) =&gt; {
  logger.info(`Hello ${req.query.person}!`);
  res.send(`Hello ${req.query.person}!`);
});
</code></pre>
<p>bail()的用处是，如果前面出错就终止检验链，不加的话，age空了还会往后面检验是不是整数。</p>
<p>当然你也可以赋给一个变量，然后再引进来:</p>
<pre><code class="language-js">const CheckGreet2 = ValidRace([
  validator.query('age').trim()
    .notEmpty().withMessage(&quot;age不能为空&quot;).bail()
    .isInt().withMessage(&quot;age必须是正整数&quot;).bail().toInt()
]);
router.get('/greet2', CheckGreet2, (req, res, next) =&gt; {
  logger.info(`Hello ${req.query.person}!`);
  res.send(`Hello ${req.query.person}!`);
});
</code></pre>
<hr />
<p>express-validator的用法远远不止于此，详见官方文档<a href="https://express-validator.github.io/docs">https://express-validator.github.io/docs</a></p>
<hr />
<h2 id="下一节-使用zod检验"><a class="header" href="#下一节-使用zod检验">下一节-使用zod检验</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用zod检验"><a class="header" href="#使用zod检验">使用zod检验</a></h1>
<p>上一节我们介绍了 express-validator，本节我们介绍一个更通用的检验工具 <strong>Zod</strong></p>
<h2 id="whats-zodjs"><a class="header" href="#whats-zodjs">What's Zod.js?</a></h2>
<p>写前端的同学可能知道Zod，我们在提交表单前需要对数据初步检查，Zod是一个很棒的工具。前端可以偷懒，但后端不能偷懒，Zod也可以用到我们的 express 后端中来，封装一个 Zod 中间件即可</p>
<h2 id="准备工作-10"><a class="header" href="#准备工作-10">准备工作</a></h2>
<p>用 evp-express-cli 创建一个最简洁的新项目。</p>
<h2 id="了解zod工作流程"><a class="header" href="#了解zod工作流程">了解Zod工作流程</a></h2>
<ol>
<li>定义待检验的数据格式</li>
</ol>
<pre><code class="language-js">const { z } = requie(&quot;zod&quot;);

const schema = z.object({
  username: z.string().nonempty(&quot;username cannot be empty&quot;)
})
</code></pre>
<p>这个 schema 就是 Zod 检验一个对象或者变量的<strong>检验器</strong>，如果检验目标只是一个值，<code>z.string()</code>之类的即可
2. 检验器验证传入
把待检查的数据传递给检验器，有4种：<code>schema.parse(data)</code>, <code>schema.parseSync(data)</code>, <code>schema.safeParse(data)</code>, <code>schema.safeParseSync(data)</code>，parse会直接抛出错误信息，而safeParse返回一个对象，包含了验证是否成功和错误信息，结构如是：<code>{success: boolean, message: ZodError}</code>
3. 错误处理
对于检验器发现的错误你需要自行处理</p>
<h2 id="安装zod"><a class="header" href="#安装zod">安装Zod</a></h2>
<pre><code class="language-shell">npm install zod
</code></pre>
<h2 id="封装中间件"><a class="header" href="#封装中间件">封装中间件</a></h2>
<p>在 midwares 目录下创建 zod.js：<br />
导出了一个 ZodValid函数：该函数传入一个对象，包含了 headers, params, query 和 body 四个可选属性，分别对应请求可以传入数据的四个部分，如果需要检验，就传入定义好的检验器给需要检验的部分；ZodValid会返回一个 request handler，在处理器里面根据传入的检验器分别去进行检验，这个<strong>处理器才是最后的中间件</strong>，ZodValid其实是一个<strong>中间件工厂</strong>。我在这里取出了第一个错误，并将错误的 message 抛出，evp-express 默认直接捕捉并返回错误信息，我这样写是为了让读者对错误信息能看的更清楚，非特定场景下，不一定要返回这样细致的错误信息，<strong>可以抛出统一错误信息</strong>。</p>
<pre><code class="language-js">const { z } = require(&quot;zod&quot;);

/**
 * @typedef {{
 * code: string;
 * expected: string;
 * received: any;
 * path: string[];
 * message: string;
 * }} MyZodError
 */

/**
 * @param {z.ZodError} errors 
 * @reutrns
 */
function selFirstError(errors) {
  /**
   * @type {MyZodError[]}
   */
  const errs = JSON.parse(errors);
  return errs[0];
}

module.exports = {
  /**
   * 
   * @param {{
   * headers: z.ZodObject|undefined;
   * params: z.ZodObject|undefined;
   * query: z.ZodObject|undefined;
   * body: z.ZodObject|undefined;
   * }} param0 
   * @returns
   */
  ZodValid: ({headers, params, query, body})=&gt;{
    /**
     * @type {import(&quot;express&quot;).RequestHandler}
     */
    const handler = (req,res,next)=&gt;{
      if (headers) {
        const result = headers.safeParse(req.headers);
        if (!result.success) {
          throw new Error(selFirstError(result.error).message)
        }
      }
      if (params) {
        const result = params.safeParse(req.params);
        if (!result.success) {
          throw new Error(selFirstError(result.error).message)
        }
      }
      if (query) {
        const result = query.safeParse(req.query);
        if (!result.success) {
          throw new Error(selFirstError(result.error).message)
        }
      }
      if (body) {
        console.log(req.body);
        const result = body.safeParse(req.body);
        if (!result.success) {
          throw new Error(selFirstError(result.error).message)
        }
      }
      next();
    }
    return handler;
  }
}
</code></pre>
<h2 id="使用中间件"><a class="header" href="#使用中间件">使用中间件</a></h2>
<p>改写 router/index.js：定义2个路由，一个 GET 一个 POST，GET接口检验 query 参数种的 name 字段，POST接口检验请求体数据中的 name, pass 和 email，由于请求发送的数据格式使用了 Json，所以我们的ZodValid要放在转换请求体格式的Json中间件之后。</p>
<pre><code class="language-js">const { Router } = require('express');
const logger = require('../utils/logger');
const Resp = require('../model/resp');
const { ZodValid } = require('../midwares/zod');
const { z } = require('zod');
const { Json } = require('../midwares/bodyParser');

const router = Router();

router.get('/', ZodValid({
  query: z.object({ name: z.string().nonempty(&quot;name cannot be empty&quot;) })
}), async (req, res, next) =&gt; {
  const name = req.query.name;
  logger.info(`Hello World! ${name}`);
  res.json(Resp.ok(`Hello World! ${name}`, 1, null));
});


router.post('/', Json, ZodValid({
  body: z.object({ 
    name: z.string().nonempty(&quot;name cannot be empty&quot;).min(8, &quot;name at least 8 length&quot;),
    pass: z.string().nonempty(&quot;password cannot be empty&quot;).min(8, &quot;password at least 8 lenght&quot;),
    email: z.string().email(&quot;email is invalid&quot;) })
}), async (req, res, next) =&gt; {
  const name = req.body.name;
  logger.info(`Hello World! ${name}`);
  res.json(Resp.ok(`Hello World! ${name}`, 1, null));
});

module.exports = router;
</code></pre>
<h2 id="测试-1"><a class="header" href="#测试-1">测试</a></h2>
<p>调整请求数据，分别访问这两个接口，你将得到类似这样的结果：</p>
<pre><code class="language-json">{
  &quot;code&quot;: 500,
  &quot;msg&quot;: &quot;name cannot be empty&quot;,
  &quot;data&quot;: null,
  &quot;symbol&quot;: 0,
  &quot;type&quot;: &quot;Bad Request&quot;
}
</code></pre>
<pre><code class="language-json">{
    &quot;code&quot;: 500,
    &quot;msg&quot;: &quot;email is invalid&quot;,
    &quot;data&quot;: null,
    &quot;symbol&quot;: 0,
    &quot;type&quot;: &quot;Bad Request&quot;
}
</code></pre>
<hr />
<p>本文仅演示了 Zod.js 最基础的用法，还有<code>z.optional</code>可选，<code>z.nullish</code>可空，<code>z.refine</code>自定义逻辑等api，更详细更高阶的用法可以查看 <strong>Zod官方手册</strong>：<a href="https://zod.dev/README_ZH">https://zod.dev/README_ZH</a></p>
<h2 id="下一节-集成redis"><a class="header" href="#下一节-集成redis">下一节-集成Redis</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集成redis"><a class="header" href="#集成redis">集成Redis</a></h1>
<p>本节我们介绍在 express.js 中集成 redis.</p>
<p>Redis是一个高性能的key-value内存数据库，支持事务、队列、持久化等特性，常用于高并发性能场景。</p>
<h2 id="准备工作-11"><a class="header" href="#准备工作-11">准备工作</a></h2>
<ul>
<li>创建一个 express.js 项目（本文基于evp-express-cli）</li>
<li>在开发环境下安装redis</li>
<li><strong>安装redis.js:</strong></li>
</ul>
<pre><code class="language-console">npm i redis
</code></pre>
<h2 id="创建代理"><a class="header" href="#创建代理">创建代理</a></h2>
<p>正常的项目都是分层的，为了避免循环依赖，本文采用代理类构造单例的方式来创建redis连接。</p>
<p><strong>redisProxy.js:</strong><br />
在构造器内创建redis连接，并监听个别事件，最后把连接赋给client成员变量。再定义一个静态的获取实例方法，调用时实例若为空，就构建实例:</p>
<pre><code class="language-js">const Redis = require('redis');
const logger = require('./logger');

class RedisProxy {
  /**
  * @type {RedisProxy}
  */
  _instance = null;
  constructor() {
    const client = Redis.createClient({
      url: `redis://127.0.0.1:6379`,
    });
  
    client.on('connect', () =&gt; {
      logger.info('Redis connected!');
    });
    
    client.on('error', err =&gt; {
      logger.error('Redis Client Error!', err);
      process.exit(1);
    });

    client.connect();
    this.client = client
  }

  static instance() {
    if(!this._instance) {
      this._instance = new RedisProxy();
    }
    return this._instance;
  }
}
</code></pre>
<p>然后把redis导出来:</p>
<pre><code class="language-js">async function init() {
  return RedisProxy.instance();
}

module.exports = {
  init,
  instance: RedisProxy.instance(),
};
</code></pre>
<p>然后在任意其它地方调用 redisProxy.instance 即可获取单例，在从单例中获取client即可操作redis.</p>
<pre><code class="language-js">const RedisProxy = require('../utils/redisProxy');
const redisProxy = RedisProxy.instance;
const redis = redisProxy.client;

redis.set(&quot;name&quot;, &quot;evpantchouli&quot;);  //设置键
console.log(await redis.get(&quot;name&quot;); //取键
</code></pre>
<p>你可以自己手动配置一遍，也可以使用evp-express-cli作为手脚架创建项目并选择redis模板。</p>
<p>关于redis.js的详细用法请见官方文档: <a href="http://npmjs.com/package/redis">http://npmjs.com/package/redis</a></p>
<h2 id="下一节-集成rabbitmq"><a class="header" href="#下一节-集成rabbitmq">下一节-集成RabbitMQ</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集成rabbitmq"><a class="header" href="#集成rabbitmq">集成RabbitMQ</a></h1>
<p>本节我们介绍在 express.js 中集成 rabbitmq.</p>
<p>RabbitMQ 是一个消息队列中间件，常用于请求削峰，事务的队列处理，事件订阅机制的实现等。</p>
<h2 id="准备工作-12"><a class="header" href="#准备工作-12">准备工作</a></h2>
<ul>
<li>创建一个 express.js 项目（本文基于evp-express-cli）</li>
<li>在开发环境下安装rabbitmq</li>
<li><strong>安装amqplib.js:</strong></li>
</ul>
<pre><code class="language-console">npm i amqplib
</code></pre>
<h2 id="创建代理-1"><a class="header" href="#创建代理-1">创建代理</a></h2>
<p>正常的项目都是分层的，为了避免循环依赖，本文采用代理类构造单例的方式来创建ampqlib连接。</p>
<p><strong>redisProxy.js:</strong><br />
在构造器内创建redis连接，并监听个别事件，最后把连接赋给client成员变量。再定义一个静态的获取实例方法，调用时实例若为空，就构建实例:</p>
<pre><code class="language-js">const amqplib = require('amqplib');
const logger = require('./logger');

class RabbitmqProxy {
  /**@type {RabbitmqProxy}*/
  _instance = null;
  /**@type {amqplib.Connection}*/
  conn;
  /**@type {amqplib.Channel}*/
  channel;

  static async instance() {
    if (!this._instance) {
      let ins = new RabbitmqProxy();
      const conn = await amqplib.connect({
        username: `guest`,
        password: `guest`,
        hostname: `127.0.0.1`,
        port: `5672`,
      });
      logger.info(&quot;Connected to RabbitMQ!&quot;);
      ins.conn = conn;
      const channel = await ins.conn.createChannel();
      //确认队列
      channel.assertQueue(&quot;hellos&quot;);
      //订阅队列
      channel.consume(&quot;hellos&quot;, async (message) =&gt; {
      	console.log(&quot;hello, two!&quot;);
      	channel.ack(message); //报告处理完毕
      });
      ins.channel = channel;
      this._instance = ins;
    }
    return this._instance;
  }
}
</code></pre>
<p>amqplib创建rabbitmq连接是异步的，所以获取实例的静态方法也是异步的，如果你想转为同步函数，只能通过进程阻塞的方式实现。上面给我们的rabbitmq客户端订阅了一个hellos队列。</p>
<p>然后把rabbitmq导出来:</p>
<pre><code class="language-js">async function init() {
  return RedisProxy.instance();
}

module.exports = {
  init,
  instance: RedisProxy.instance(),
};
</code></pre>
<p>然后在任意其它地方调用 await rabbitmqProxy.instance 即可获取单例，在从单例中获取conn和channel即可操作rabbitmq.</p>
<pre><code class="language-js">const rabbitmqProxy = require('../utils/rabbitmqProxy');

app.post('/', async(req,res,next)=&gt;{
	const rbmqproxy = await rabbitmqProxy.instance;
	const channel = rbmqproxy.channel;
	//发送消息到&quot;hellos&quot;队列
    channel.sendToQueue(&quot;hellos&quot;, &quot;hello!&quot;);
    res.send();
})
</code></pre>
<p>你可以自己手动配置一遍，也可以使用evp-express-cli作为手脚架创建项目并选择rabbitmq模板。</p>
<p>关于amqplib.js的详细用法请见官方文档: <a href="http://npmjs.com/package/amqplib">http://npmjs.com/package/amqplib</a></p>
<h2 id="下一节-集成websocket"><a class="header" href="#下一节-集成websocket">下一节-集成Websocket</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集成websocket"><a class="header" href="#集成websocket">集成websocket</a></h1>
<p>本节我们介绍在如何在 express 中集成 websocket。</p>
<p>WebSocket 服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p>
<h2 id="准备工作-13"><a class="header" href="#准备工作-13">准备工作</a></h2>
<ul>
<li>创建一个 express.js 项目（本文基于evp-express-cli）</li>
<li><strong>安装ws.js:</strong>（本教程使用更通用的ws.js，有兴趣的同学可以去了解express-ws.js）</li>
</ul>
<pre><code class="language-console">npm i ws
</code></pre>
<h2 id="创建代理-2"><a class="header" href="#创建代理-2">创建代理</a></h2>
<p>正常的项目都是分层的，为了避免循环依赖，本文采用代理类构造单例的方式来创建websocket服务器。</p>
<p><strong>wsProxy.js:</strong><br />
在构造器内创建websocket服务器，并监听个别事件，最后把服务器赋给server成员变量。再定义一个静态的获取实例方法，调用时实例若为空，就构建实例:</p>
<pre><code class="language-js">const {WebSocketServer} = require('ws');

class WebsocketProxy {
  /**@type {WebsocketProxy} */
  static INSTANCE;
  server;
  constructor() {
    const _server = new WebSocketServer({
      server: require('./server')
    })

    this.server = _server;
    
    _server.on(&quot;listening&quot;, () =&gt; {
      console.log(`websocket server is listening.`);
      
    })

    _server.on(&quot;connection&quot;, (ws) =&gt; {
      console.log(`websocket client connection`);
      ws.send(`Hello, I'm WebSocket server.`);
      ws.on(&quot;message&quot;, (message) =&gt; {
        ws.send(`${message}`);
      })
    })
  }

  static instance() {
    if(!WebsocketProxy.INSTANCE) {
      WebsocketProxy.INSTANCE = new WebsocketProxy();
    }
    return WebsocketProxy.INSTANCE;
  }
}

function init() {
  return WebsocketProxy.instance();
}

module.exports = {
  init
};
</code></pre>
<p>最后把服务器导出来:</p>
<pre><code class="language-js">async function init() {
  return RedisProxy.instance();
}

module.exports = {
  init,
  instance: RedisProxy.instance(),
};
</code></pre>
<p>然后在任意其它地方调用 wsProxy.instance 即可获取单例，在从单例中获取server即可主动操作websocket.</p>
<pre><code class="language-js">const WsProxy = require('../utils/wsProxy');
const wsProxy = WsProxy.instance;
const wsServer = wsProxy.server;
</code></pre>
<p>你可以自己手动配置一遍，也可以使用evp-express-cli作为手脚架创建项目并选择websocket模板。</p>
<p>关于 ws.js 的详细用法请见官方文档: <a href="https://www.npmjs.com/package/ws">https://www.npmjs.com/package/ws</a></p>
<h2 id="下一节-集成socketio"><a class="header" href="#下一节-集成socketio">下一节-集成SocketIO</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集成socketio"><a class="header" href="#集成socketio">集成SocketIO</a></h1>
<p>本节我们介绍在如何在 express 中集成 Socket.IO</p>
<p>Socket.IO 算是 WebSocket 的一个超集，进行了一些封装和拓展。</p>
<h2 id="准备工作-14"><a class="header" href="#准备工作-14">准备工作</a></h2>
<ul>
<li>创建一个 express.js 项目（本文基于evp-express-cli）</li>
<li><strong>安装socket.io.js:</strong></li>
</ul>
<pre><code class="language-console">npm i socket.io
</code></pre>
<h2 id="创建代理-3"><a class="header" href="#创建代理-3">创建代理</a></h2>
<p>正常的项目都是分层的，为了避免循环依赖，本文采用代理类构造单例的方式来创建websocket服务器。</p>
<p><strong>wsProxy.js:</strong><br />
在构造器内创建socket.io服务器，并监听个别事件，最后把服务器赋给server成员变量。再定义一个静态的获取实例方法，调用时实例若为空，就构建实例:</p>
<pre><code class="language-js">const { Server } = require('socket.io');
const server = require('./server');
const logger = require('./logger');

class SocketIoProxy {
  /**
   * @type {Server}
   */
  _instance = null;
  constructor() {
    this.server = new Server(server);
    logger.info('SocketIo server created!');
    this.server.on('connection', (socket) =&gt; {
      socket.on('message', (data) =&gt; {
        logger.info(`client: ${JSON.stringify(data)}`);
        socket.emit('message', data);
      });
    });
  }

  static instance(){
    if(!this._instance){
      this._instance = new SocketIoProxy();
    }
    return this._instance;
  }
}

async function init() {
  return SocketIoProxy.instance();
}

module.exports = {
  init,
  instance: SocketIoProxy.instance()
}

</code></pre>
<p>最后把服务器导出来:</p>
<pre><code class="language-js">async function init() {
  return RedisProxy.instance();
}

module.exports = {
  init,
  instance: RedisProxy.instance(),
};
</code></pre>
<p>然后在任意其它地方调用 socketioProxy.instance 即可获取单例，在从单例中获取server即可主动操作socketio.</p>
<pre><code class="language-js">const SocketioProxy = require('../utils/socketioProxy');
const socketioProxy = SocketioProxy.instance;
const socketioServer = socketioProxy.server;
</code></pre>
<p>你可以自己手动配置一遍，也可以使用evp-express-cli作为手脚架创建项目并选择socketio模板。</p>
<p>关于 socket.io 的详细用法请见官方文档: <a href="https://socket.io/zh-CN/">https://socket.io/zh-CN/</a></p>
<h2 id="下一节-全面鉴权"><a class="header" href="#下一节-全面鉴权">下一节-全面鉴权</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全面鉴权"><a class="header" href="#全面鉴权">全面鉴权</a></h1>
<h2 id="下一节-软件测试"><a class="header" href="#下一节-软件测试">下一节-软件测试</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件测试"><a class="header" href="#软件测试">软件测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件构建"><a class="header" href="#软件构建">软件构建</a></h1>
<p>运行node项目，一般都是直接运行源码，不过这样子部署的时候不太方便，需要拷贝整个文件夹，如果是需要交付给客户的，并且客户不需要源码，客户不懂编程知识的话，你丢给他一堆源码让该怎么让他运行呢？Java可以打包成 jar/war, C/C++可以打包为 exe，Node也迫切需要一种可靠的构建技术。前端的朋友们可能都熟悉webpack,rolliup或者是Vite，不过它们都只是将项目合并为单个js文件，运行仍旧依赖外部的js-runtime，在本节，我们将介绍一个构建Node项目为可执行程序的工具 —— <strong>pkg</strong></p>
<h2 id="准备工作-15"><a class="header" href="#准备工作-15">准备工作</a></h2>
<p>创建如下项目目录：</p>
<pre><code class="language-TEXT">│  package.json
│  readme.md
│
├─assets
│      config.yaml
│
├─db
│      data.db
├─src
│      index.js
│
├─dist
│
└─node_modules
</code></pre>
<p>assets目录放的是静态资源，比如配置，图片，脚本什么的，我这里放一个yaml配置文件:</p>
<pre><code class="language-yaml">app:
  name: pkg-demo
  version: 0.0.1
server:
  host: 127.0.0.1
  port: 8080
</code></pre>
<p>db目录则放置我们的sqlite数据库文件<br />
以下是index.js的内容：<br />
做了3件事情，连接到sqlite数据库，提供返回config.yaml内容的接口和下载数据库文件的接口</p>
<pre><code class="language-js">const express = require('express');
const evchart = require('js-text-chart').evchart;
const app = express();
const path = require('path');
const yaml = require('js-yaml');
const fs = require('fs');
const config = yaml.load(fs.readFileSync('../assets/config.yaml'));

const dbpath = '../db/data.db';
const knex = require('knex');
const sqlite = knex({
    client: 'sqlite3',
    connection: {
      filename: dbpath,
      acquireConnectionTimeout: 1000
    },
});

app.all(&quot;*&quot;, function (req, res, next) {
    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;);
    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);
    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);
    next();
});

app.get('/', function (req, res) {
    res.send('Hello World!');
});

app.get('/config', function (req, res) {
    res.json(config);
});

app.get('/db', function (req, res) {
    res.download(dbpath);
});

const server = app.listen(config.server.port, config.server.host, () =&gt; {
    let host = server.address().address;
    let port = server.address().port;

    let str = config.app.name;
    let mode = [ &quot;close&quot;, &quot;far&quot;, undefined ];
    let chart = evchart.convert(str, mode[0]);
    console.log(chart);

    console.log(&quot;Server is ready on http://%s:%s&quot;, host, port);
})
</code></pre>
<p>此时我们访问这些接口都是可以正常用的：</p>
<pre><code class="language-console">C:\Users\GrapeX&gt;curl -X GET http://127.0.0.1:8080
Hello World!
C:\Users\GrapeX&gt;curl -X GET http://127.0.0.1:8080/config
{&quot;app&quot;:{&quot;name&quot;:&quot;pkg-demo&quot;,&quot;version&quot;:&quot;0.0.1&quot;},&quot;server&quot;:{&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:8080}}
</code></pre>
<p>接下来，我们就来实现把这个小项目构建为一个可以直接运行的exe程序，并且assets内置其中，db则还是在外边，方便我们管理数据库</p>
<h2 id="安装并配置pkg"><a class="header" href="#安装并配置pkg">安装并配置pkg</a></h2>
<p>安装pkg: <code>npm i pkg -dev</code></p>
<p>大致说一下pkg是怎么进行构建的：首先指定项目的入口js文件，然后pkg会根据代码中的依赖关系，顺藤摸瓜的把所有相关的js文件都找到，然后根据指定的node版本和编译平台环境(win,linux,macos)开始编译你写的js文件和项目安装的依赖模块，最终构建exe程序</p>
<p>pkg构建命令的结构：<code>pkg 入口文件 [options]</code></p>
<p>可以通过 <code>pkg --help</code> 查看命令选项：</p>
<pre><code class="language-console"> Options:

    -h, --help           output usage information
                            输出使用帮助信息
    -v, --version        output pkg version
                            输出 pkg 版本信息
    -t, --targets        comma-separated list of targets (see examples)
                            以逗号分隔的目标列表（参考示例）
    -c, --config         package.json or any json file with top-level config  
                            package.json 或者任何 json 文件顶层配置
    --options            bake v8 options into executable to run with them on
                            将 v8 选项打包到可执行文件中，以便它们一起运行
    -o, --output         output file name or template for several files
                            输出文件名或者多个文件的输出模板，默认为npm-package-name
    --out-path           path to save output one or more executables
                            保存输出可执行文件的路径
    -d, --debug          show more information during packaging process [off]
                            在打包过程中展示更多信息，默认关闭
    -b, --build          don't download prebuilt base binaries, build them
                            不下载预构建的基础二进制文件，而是构建它们
    --public             speed up and disclose the sources of top-level project
                            加速和公开顶级项目的源代码
    --public-packages    force specified packages to be considered public
                            强制指定包被认定为公开的
    --no-bytecode        skip bytecode generation and include source files as plain js
                            跳过字节码生成阶段，直接打包源文件为普通 js
    --no-native-build    skip native addons build
                            跳过原生插件构建
    --no-dict            comma-separated list of packages names to ignore dictionaries. Use --no-dict * to disable all dictionaries
                            以逗号分隔的包名列表忽略字典，使用 --no-dict * 禁用所有字典
    -C, --compress       [default=None] compression algorithm = Brotli or GZip
                            压缩算法 Brotli 或者 GZip. 默认关闭
</code></pre>
<p>最核心的几个选项是：</p>
<ul>
<li><code>-t</code>：必须要指明编译的依据，否则将会是默认的，比如<code>v16.16.0-linux-x64</code></li>
<li><code>--out-path</code>：通常我们都会将构建产物生成在指定的目录下</li>
<li><code>-o</code>：不填将默认为package.json中的name或入口文件名，往往我们可能希望是其它的名字</li>
</ul>
<p>要注意的是 -o 和 --out-path 不能同时设置，只能设置其中一个</p>
<h2 id="打包"><a class="header" href="#打包">打包</a></h2>
<p>对我们的项目进行基础的打包，指定入口为index.js，node版本为16，平台为64位Windows，输出路径在dist目录：</p>
<pre><code class="language-console">pkg index.js node16-win-x64 --out-path=dist/
</code></pre>
<p>或者在 package.json中添加 bin 选项：</p>
<pre><code class="language-json">{
	&quot;bin&quot;: &quot;index.js&quot;
}
</code></pre>
<p>然后使用<code>.</code>替代，pkg此时会去读取package.json中的bin：</p>
<pre><code class="language-console">pkg index.js node16-win-x64 --out-path=dist/
</code></pre>
<p>运行这条命令，你会看到pkg在拉取(fetch) node16-win-x64，不出意外的话，你半天都拉不下下来，因为它们的服务器在境外<br />
我们可以到 <a href="https://github.com">Github</a>: <a href="https://github.com/vercel/pkg-fetch/releases">https://github.com/vercel/pkg-fetch/releases</a> 上去手动下载对应的fetch包，注意版本要和你使用的 pkg 版本契合，我当前的 pkg 版本是3.4，所以我选取了 v3.4 中的 <code>node-v16.16.0-win-x64</code>，下载到本地后，进入 <code>C:\Users\{你用户}\.pkg-cache\你版本\</code>目录，拷贝下载好的文件到这里，并把<code>node</code>改成<code>fetched</code>，这样pkg下构建时就会使用事先下载好的node源了</p>
<p>构建好了，我们双击运行<code>index.exe</code>一下，很好，直接闪退，我们打命令<code>index.exe &gt; log.txt</code> 看看：</p>
<pre><code class="language-console">node:internal/fs/utils:345
    throw err;
    ^

Error: ENOENT: no such file or directory, open './assets/config.yaml'
    at Object.openSync (node:fs:585:3)
    at Object.openSync (pkg/prelude/bootstrap.js:793:32)
    at Object.readFileSync (node:fs:453:35)
    at Object.readFileSync (pkg/prelude/bootstrap.js:1079:36)
    at Object.&lt;anonymous&gt; (C:\snapshot\pkg\index.js)
    at Module._compile (pkg/prelude/bootstrap.js:1926:22)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.runMain (pkg/prelude/bootstrap.js:1979:12) {
  errno: -4058,
  syscall: 'open',
  code: 'ENOENT',
  path: './assets/config.yaml'
}
</code></pre>
<p>报错是找不到对应的文件或目录，它找不到我们的config,yaml，此时我们把assets目录复制到dist下，可以正常运行，相同的，db也要复制过来，才能正常下载data.db文件。但这并不是我们想要的，因为我们想要的是配置文件内置在exe程序中，因为往往会包含一些敏感信息。</p>
<h3 id="配置内置资源目录"><a class="header" href="#配置内置资源目录">配置内置资源目录</a></h3>
<p>当我们需要将静态资源，比如配置文件(.yaml,.json等)或者其它的非.js文件，需要事先设置资源，pkg才会把指定的资源打包进exe中<br />
配置方法是在 package.json 中配置 pkg:assets 选项：</p>
<pre><code class="language-json">  &quot;pkg&quot;: {
    &quot;assets&quot;: [
      &quot;assets**/*&quot;
    ]
  },
</code></pre>
<p>assets接收一个数组，每个元素是你指定的资源路径，可以使用通配，上面这个就是把assets下所有文件都指定为资源文件<br />
官方文档给了这么个示例：</p>
<pre><code class="language-json">  &quot;pkg&quot;: {
    &quot;scripts&quot;: &quot;build/**/*.js&quot;,
    &quot;assets&quot;: &quot;views/**/*&quot;,
    &quot;targets&quot;: [ &quot;node14-linux-arm64&quot; ],
    &quot;outputPath&quot;: &quot;dist&quot;
  }
</code></pre>
<p>scripts是指那些额外编译后的js，比如你用了大量高级esm语法的代码，被你用babel编译成的普通js，比如你用了v8的然后被编译好的js等等</p>
<p>配置好后再运行，此时还是不行，哪一步出问题了？原因在于我们的路径是这么写的，这种形式会以读取外部文件的方式去寻找：</p>
<pre><code class="language-js">fs.readFileSync('../assets/config.yaml');
</code></pre>
<p>而pkg构建的exe是一个快照程序，运行时将处于系统快照内，你可以看到index.js实际运行于C:\snapshot\pkg\index.js，所以对于项目内的资源路径，必须基于快照，快照路径可以用<code>__dirname</code>获取</p>
<pre><code class="language-js">const config = yaml.load(fs.readFileSync(`${__dirname}/assets/config.yaml`));
</code></pre>
<p>如果采取使用path模块规范化路径，甚至可以不配置package.json，因为pkg检测到<code>path</code>+<code>__dirname</code>时会自动把对应路径当成资源对待：<br />
path.join</p>
<pre><code class="language-js">    fs.readFileSync(
        path.join(
            __dirname,
            '../assets/config.yaml')
        )
</code></pre>
<p>path.resolve也行</p>
<pre><code class="language-js">    fs.readFileSync(
        path.resolve(
            __dirname,
            '../assets/config.yaml')
        )
</code></pre>
<p>到这里，exe完美的如期运行！</p>
<h3 id="正确的读取外部路径"><a class="header" href="#正确的读取外部路径">正确的读取外部路径</a></h3>
<p>但是呢，我们的代码依旧存在小小的瑕疵，就是我们的数据库路径：</p>
<pre><code class="language-js">const dbpath = '../db/data.db';
</code></pre>
<p>开发的时候是在根目录下，但部署的时候？打包完后，外部的文件路径可都是相对于exe来说的，也就是说db要放到部署目录的上级目录了，这不符合常理。所以在配置外部文件路径时，我们应当基于根目录去写。怎么获取根目录？index.js中读取<code>__dirname</code>？在pkg中行不通的，因为<code>__dirname</code>已经成为项目内的虚拟路径了</p>
<p>正确的做法是 <code>process.cwd()</code>，这个命令可以直接获取到项目根目录路径(入口文件路径)：</p>
<pre><code class="language-js">const dbpath = `${process.cwd()}/db/data.db`;
</code></pre>
<p>或者用path规范化路径：</p>
<pre><code class="language-js">const dbpath = path.join(process.cwd(), './db/data.db');
</code></pre>
<h2 id="压缩"><a class="header" href="#压缩">压缩</a></h2>
<p>在构建的时候还可以指定<code>--compress</code>参数，来减小构建产物的体积，如：</p>
<pre><code class="language-js">pkg . -t node16-win-x64 --compress GZip --out-path=dist/
</code></pre>
<p>本节的示例项目exe由原先的46MB缩小到了40MB，压缩效果还行，不过毕竟压缩了，多多总会对程序的性能造成一点影响，如果你的项目有较高的性能需求，请慎重考虑是否压缩</p>
<h2 id="其它"><a class="header" href="#其它">其它</a></h2>
<p>关于<code>--no-bytecode</code>参数，开启的话，构建的时候pkg不会将js转为二进制，而是直接以js打包进exe内，体积会小一点，不过js源码的运行效率自然会比二进制程序要逊色一点。</p>
<h3 id="es6"><a class="header" href="#es6">es6+</a></h3>
<p>此外，如果你使用了一些es6+的模块，如axios，pkg构建时会报错，<code>--no-bytecode</code>参数可以逃避构建时的报错，但这是治标不治本，运行照样跑不通。</p>
<p>我的建议是，使用这些依赖预编译好的普通js版本(axios的package.json似乎写的有点问题，可以手动把代码拷出来用)，如果没有你就手动用babel编译，或者直接使用它们的老的普通js的版本，如 axios 0.27.2 及以前的。</p>
<h3 id="以axios为例"><a class="header" href="#以axios为例">以Axios为例</a></h3>
<p>现在新增一个<code>/toConfig</code>接口，该接口用axios请求之前的<code>/config</code>接口并返回响应结果：</p>
<pre><code class="language-js">const axios = require('axios').default; //pkg打包失败

app.get('/toConfig', function (req, res) {
    axios.get(`http://${config.server.host}:${config.server.port}/config`)
    .then(function (resp) {
        res.json(resp.data);
    })
});
</code></pre>
<p>直接用 pkg 构建会出错，因为 pkg 基于 CommonJs 模块，而新版的 axios 默认导出的是 ESModule</p>
<ul>
<li><strong>方案1</strong>：拷贝axios.cjs</li>
</ul>
<p>拷贝<code>node_modules\axios\dist\node\axios.cjs</code>放到自己的源码下并引用：</p>
<pre><code class="language-js">const axios = require(&quot;./axios.cjs&quot;).default; // 方案1
</code></pre>
<p>此时，把原先的axios依赖删了都行，pkg构建的时候还不会WARN</p>
<ul>
<li><strong>方案2</strong>：把axios.cjs作为资源脚本</li>
</ul>
<pre><code class="language-js">const axioscjs = path.join(__dirname,&quot;../node_modules/axios/dist/node/axios.cjs&quot;);
const axios = require(axioscjs).default;  // 方案2
</code></pre>
<p>pkg构建的虽然会WARN，但能正常运行即可</p>
<ul>
<li><strong>方案3</strong>：使用低版本的 axios</li>
</ul>
<pre><code class="language-console">npm uninstall axios &amp;&amp; npm i axios@0.27.2
</code></pre>
<p>版本低了，比较旧，可能存在不少潜在的问题，不太推荐使用</p>
<h2 id="下一节-docker部署"><a class="header" href="#下一节-docker部署">下一节-Docker部署</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker部署"><a class="header" href="#docker部署">Docker部署</a></h1>
<h2 id="下一节-pm2进程管理"><a class="header" href="#下一节-pm2进程管理">下一节-pm2进程管理</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pm2进程管理"><a class="header" href="#pm2进程管理">pm2进程管理</a></h1>
<h2 id="下一章节-最佳实践"><a class="header" href="#下一章节-最佳实践">下一章节-最佳实践</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码规范"><a class="header" href="#代码规范">代码规范</a></h1>
<h2 id="下一节-高性能"><a class="header" href="#下一节-高性能">下一节-高性能</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高性能"><a class="header" href="#高性能">高性能</a></h1>
<h2 id="下一节-安全性"><a class="header" href="#下一节-安全性">下一节-安全性</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全性"><a class="header" href="#安全性">安全性</a></h1>
<h2 id="下一节-健康检查"><a class="header" href="#下一节-健康检查">下一节-健康检查</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="健康检查"><a class="header" href="#健康检查">健康检查</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="后记"><a class="header" href="#后记">后记</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
