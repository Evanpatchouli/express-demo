<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>跟着例子学Express.js</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">模块化学习</li><li class="chapter-item expanded "><a href="chapter_1/intro.html"><strong aria-hidden="true">1.</strong> 本章简介</a></li><li class="chapter-item expanded "><a href="chapter_1/section_1.html"><strong aria-hidden="true">2.</strong> HelloWorld</a></li><li class="chapter-item expanded "><a href="chapter_1/section_2.html"><strong aria-hidden="true">3.</strong> 请求类型</a></li><li class="chapter-item expanded "><a href="chapter_1/section_3.html"><strong aria-hidden="true">4.</strong> 处理请求数据</a></li><li class="chapter-item expanded "><a href="chapter_1/section_4.html"><strong aria-hidden="true">5.</strong> Sql增删改查</a></li><li class="chapter-item expanded "><a href="chapter_1/section_5.html"><strong aria-hidden="true">6.</strong> Sql-ORM增删改查</a></li><li class="chapter-item expanded "><a href="chapter_1/section_6.html"><strong aria-hidden="true">7.</strong> 路由控制</a></li><li class="chapter-item expanded "><a href="chapter_1/section_7.html"><strong aria-hidden="true">8.</strong> JWT基础鉴权</a></li><li class="chapter-item expanded "><a href="chapter_1/section_8.html"><strong aria-hidden="true">9.</strong> 全局错误处理</a></li><li class="chapter-item expanded affix "><li class="part-title">架构整合</li><li class="chapter-item expanded "><a href="chapter_2/intro.html"><strong aria-hidden="true">10.</strong> 本章简介</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">跟着例子学Express.js</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="跟着例子学expressjs"><a class="header" href="#跟着例子学expressjs">跟着例子学express.js</a></h1>
<p>本书将结合理论和实践来学习express.js后端开发</p>
<p>本书将按照后端不同的模块进行介绍，并逐步构建一个规范完整的express.js后端体系</p>
<p>请配合示例源码阅读本书，动手是最好的老师</p>
<p>如有纰漏和错误，欢迎更正，谢谢！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块化学习"><a class="header" href="#模块化学习">模块化学习</a></h1>
<p>我们将把express分为不同的知识模块进行独立学习，通常来说，建议按从前到后的顺序依次学习</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>本节我们将创建并运行我们的第一个express.js项目，并使用最简单的请求响应</p>
<h2 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h2>
<ul>
<li>本书系统环境为 <strong>windows10 64Bit</strong></li>
<li>请事先在你的开发环境中安装 <strong>Node.js</strong>，本书使用的是 <strong>node v16.17.1</strong></li>
<li>推荐使用 <strong>VsCode</strong> 作为开发工具，有良好的代码提示功能</li>
<li>事先安装一个api调试工具，如 <strong>postman</strong>, <strong>apipost</strong>等</li>
</ul>
<h2 id="创建项目"><a class="header" href="#创建项目">创建项目</a></h2>
<ol>
<li>创建一个文件夹作为项目根目录</li>
<li>下载express依赖<br />
在根目录下执行<code>npm install express</code></li>
<li>下载js-text-chart依赖<br />
在根目录下执行<code>npm install js-text-chart</code>，这是一个用于输出字符画的js库，本书在每一个示例中都使用了该库充当starter</li>
<li>在根目录下新建一个入口文件，如<strong>index.js</strong></li>
<li>在入口文件中引入依赖</li>
</ol>
<pre><code class="language-js">const express = require('express');
const evchart = require('js-text-chart').evchart;
</code></pre>
<h2 id="创建服务器"><a class="header" href="#创建服务器">创建服务器</a></h2>
<ol>
<li>先创建一个express实例</li>
</ol>
<pre><code class="language-js">const app = express();
</code></pre>
<ol start="2">
<li>创建服务器</li>
</ol>
<p>让我们刚刚创建的app实例挂载到指定的端口，如8080</p>
<pre><code class="language-js">const server = app.listen(8080);
</code></pre>
<ol start="3">
<li>添加服务器运行后的回调函数</li>
</ol>
<p>是指在服务器成功运行后的一系列操作，常用于输出信息和初始化等，我在这里打印该项目的基本信息<br />
我使用的是内联箭头函数 &quot;()=&gt;{//...}&quot;，也可以替换为普通的&quot;function {//...}&quot;</p>
<pre><code class="language-js">const server = app.listen(8080, () =&gt; {
    let host = server.address().address;
    let port = server.address().port;

    let str = &quot;EXPRESS-DEMO&quot;;
    let mode = [ &quot;close&quot;, &quot;far&quot;, undefined ];
    let chart = evchart.convert(str, mode[0]);
    console.log(chart);

    console.log(&quot;Server is ready on http://%s:%s&quot;, host, port);
})
</code></pre>
<ol start="4">
<li>跨域策略</li>
</ol>
<p>默认情况下可能不允许不同域名下进行交互，我们对请求进行一些基本的设置，允许跨域和所有的请求方式请求头格式化，并设置请求头内容为json格式</p>
<pre><code class="language-js">app.all(&quot;*&quot;, function (req, res, next) {
    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;);
    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);
    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);
    next();
});
</code></pre>
<h2 id="第一个接口"><a class="header" href="#第一个接口">第一个接口</a></h2>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<p>前后端交互是在后端暴露的接口进行的，而不同的接口对于后端端口上不同的url路径。前端使用不同的方式（GET,POST...）请求指定的路径，当后端有定义监听某种方式下的某种路径接口时，获取请求携带的数据，对请求进行处理，并返回结果给前端 </p>
<h3 id="实践"><a class="header" href="#实践">实践</a></h3>
<p>接下来，我们将添加一个以服务器的根路径（GET）作为返回欢迎信息的接口</p>
<pre><code class="language-js">app.get('/', function (req, res) {
    res.send('Hello World!');
});
</code></pre>
<p>以上代码，app实例<strong>监听</strong> <strong>localhost:8080/</strong> 路径的<strong>GET</strong>请求，传入2个参数，第一个是请求，第二个是响应<br />
当接收到以GET方式访问该接口的请求时，通过在回调函数中执行<code>res.send</code>返回 Hello World!</p>
<h3 id="测试接口"><a class="header" href="#测试接口">测试接口</a></h3>
<p>使用接口测试工具，以GET的形式访问localhost:8080/试试吧！你将会得到一句 Hello World!</p>
<h2 id="第二个接口"><a class="header" href="#第二个接口">第二个接口</a></h2>
<p>第一个接口，我们只是单纯的访问了接口，没有传输任何数据，接下来我们将创建一个以传统的路径请求参数（如: url?id=1）携带数据的接口</p>
<h3 id="实践-1"><a class="header" href="#实践-1">实践</a></h3>
<p>定义一个GET形式，路径为 /get 的接口，传入2个参数请求和响应，我们在回调函数中通过<code>req.query</code>来获取路径上的所有请求参数，并将这些参数作为接口的返回值</p>
<pre><code class="language-js">app.get('/get', function (req, res) {
    let requestParams = req.query;
    res.send(requestParams);
});
</code></pre>
<h3 id="测试接口-1"><a class="header" href="#测试接口-1">测试接口</a></h3>
<p>使用接口测试工具，以GET的形式访问 localhost:8080/get?id=1&amp;name=evanp 试试吧！你将会得到这两个参数!</p>
<h2 id="下一章-请求类型"><a class="header" href="#下一章-请求类型">下一章-请求类型</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="请求类型"><a class="header" href="#请求类型">请求类型</a></h1>
<p>本节将介绍常见的http请求方式，并站在后端的角度初步感受它们的不同点</p>
<h2 id="各类http请求"><a class="header" href="#各类http请求">各类Http请求</a></h2>
<ul>
<li><strong>GET</strong><br />
意图是<strong>获取</strong>，不会对服务器上的数据产生影响，将要携带的数据放在<strong>URL</strong>上，通常不带请求体，带了也不一定兼容</li>
<li><strong>POST</strong><br />
意图是<strong>提交</strong>，通常用于修改和新增服务器上的数据，偏向<strong>新增</strong>，路径定位较模糊，要携带的数据通常放在<strong>请求体</strong>内</li>
<li><strong>PUT</strong><br />
类似POST，偏向<strong>更新</strong>，路径定位更明确，要携带的数据通常放在<strong>请求体</strong>内<br />
★ <strong>幂等性</strong>：连续PUT请求后，效果应当只有一次，而POST则会创建多个新资源，不过在REST风格下以及在后台有严格的检验情况下其实这些区别可以忽略<br />
★ <strong>缓存机制</strong>：由于PUT的幂等性，不存在缓存，而POST是缓存的，比如你在表单里用POST，不设置提交后清除，刷新页面它会将之前的数据再提交一遍</li>
<li><strong>DELETE</strong><br />
意图是删除，从服务器上删除某些数据</li>
<li><strong>HEAD</strong><br />
类似GET，但争对它的响应没有body，只有响应头，常用于判断资源是否存在、链接有效性等</li>
<li><strong>OPTIONS</strong><br />
意图是询问当前URL允许的请求方法等，常用于跨域请求前的预检和获取服务器的安全控制信息等</li>
<li><strong>TRACE</strong><br />
路径追踪，回显请求，常用于测试阶段</li>
<li><strong>PATCH</strong><br />
PUT的超类，指定资源的局部更新</li>
<li><strong>COPY</strong><br />
请求将页面拷贝到另一个URL，常用于Web资源的备份</li>
<li><strong>MOVE</strong><br />
请求将页面移动到另一个URL，常用于Web资源的搬迁</li>
<li><strong>LINK</strong><br />
请求与服务器建立链接</li>
<li><strong>UNLINK</strong><br />
断开与服务器的链接</li>
</ul>
<p>其中 GET, POST 最为广泛使用，同时可以使用PUT和DELETE让我们的接口的目的更具有指向性<br />
本书绝大部分接口都将采用类REST风格，即普遍的返回码200，数据格式为json</p>
<h2 id="express处理不同的请求"><a class="header" href="#express处理不同的请求">express处理不同的请求</a></h2>
<p>由于实际受不同的开发规范和业务环境影响，在这里只以GET和POST举例</p>
<h3 id="get请求"><a class="header" href="#get请求">get请求</a></h3>
<pre><code class="language-js">//省略了express项目的创建
class Item {
    constructor(name, value) {
      this.name = name;
      this.value = value;
    }
}

//get接口
app.get('/request', function (req, res) {
    let result = [];
    result.push(new Item(&quot;baseUrl&quot;,req.baseUrl));
    result.push(new Item(&quot;fresh&quot;,req.fresh));   //请求是否存活
    result.push(new Item(&quot;hostname&quot;,req.hostname)); //请求源域名
    result.push(new Item(&quot;ip&quot;,req.ip)); //请求源IP
    result.push(new Item(&quot;originalUrl&quot;,req.originalUrl));
    result.push(new Item(&quot;params&quot;,req.path));   //路径参数: /x/y/z/
    result.push(new Item(&quot;protocol&quot;,req.protocol)); //请求协议
    result.push(new Item(&quot;query&quot;,req.query));   //查询参数
    result.push(new Item(&quot;route&quot;,req.route));   //请求路由
    result.push(new Item(&quot;is:Content-Type&quot;,req.is('application/json')));

    res.send(result);
});
</code></pre>
<p>以上代码，定义了GET接口，并返回了关于请求的大部分信息</p>
<h3 id="测试接口-2"><a class="header" href="#测试接口-2">测试接口</a></h3>
<p>使用api调试工具，尝试用不同的携带数据方法以get形式访问该接口，比较不同的返回结果</p>
<h3 id="post请求"><a class="header" href="#post请求">post请求</a></h3>
<p>监听相同路径的post请求，开启json解析，一会我们调试时请求体采用最常用的json格式</p>
<pre><code class="language-js">//启用json解析
app.use(express.json({type: 'application/json'}));

app.post('/post', function (req, res) {
    let result = [];
    result.push(new Item(&quot;baseUrl&quot;,req.baseUrl));
    result.push(new Item(&quot;fresh&quot;,req.fresh));
    result.push(new Item(&quot;hostname&quot;,req.hostname));
    result.push(new Item(&quot;ip&quot;,req.ip));
    result.push(new Item(&quot;originalUrl&quot;,req.originalUrl));
    result.push(new Item(&quot;params&quot;,req.path));
    result.push(new Item(&quot;protocol&quot;,req.protocol));
    result.push(new Item(&quot;query&quot;,req.query));
    result.push(new Item(&quot;body&quot;,req.body));
    result.push(new Item(&quot;route&quot;,req.route));
    result.push(new Item(&quot;is:Content-Type&quot;,req.is('application/json')));

    res.send(result);
});
</code></pre>
<h3 id="测试接口-3"><a class="header" href="#测试接口-3">测试接口</a></h3>
<p>使用api调试工具，尝试用不同的携带数据方法以post形式访问该接口，比较不同的返回结果</p>
<h2 id="下一章-处理请求数据"><a class="header" href="#下一章-处理请求数据">下一章-处理请求数据</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="处理请求数据"><a class="header" href="#处理请求数据">处理请求数据</a></h1>
<p>本节将具体介绍express后端处理请求源携带数据的一些方法和技巧</p>
<h2 id="动态路径"><a class="header" href="#动态路径">动态路径</a></h2>
<p>很多时候我们需要处理一些类似但有操作差别或不同对象的业务，我们可以监听一段基本路径，将其中某一个段或者某几段路径作为变量，在接口中根据不同的路径变量执行不同的业务操作，这是一种REST风格比较鲜明的动态接口设计策略</p>
<h3 id="实践-2"><a class="header" href="#实践-2">实践</a></h3>
<p>由于post也可以url传参，本节所有实例均采用post请求 </p>
<h4 id="第一个接口-1"><a class="header" href="#第一个接口-1">第一个接口</a></h4>
<p>这个接口以 /request/data/ 作为基路由，之后的kind变化的，在接口内部根据kind的值进行分支化处理。我指定了kind的3个值：PathVarible, RequestParam 和 body.<br />
所有的路径参数则可以由<code>req.params</code>（大概是个json对象）来获取，我要指定获取kind的值，就req.params.kind，而静态路径变量的值就等于它名字.</p>
<pre><code class="language-js">//忽略了express项目的创建和基本配置
class Item {
    constructor(name, value) {
      this.name = name;
      this.value = value;
    }
}
//启用json解析请求体
app.use(express.json({type: 'application/json'}));
app.post('/request/data/:kind', function (req, res) {
    let result = [];
    if (req.params.kind == 'PathVarible') {
        result.push(new Item(&quot;lesson&quot;,&quot;路径变量&quot;));
        result.push(new Item(&quot;info&quot;,&quot;在express中叫做params，路径上每个被双单斜杠'/'隔开的一个个词语就是路径参数，当你需要在同一个接口内动态响应不同的情景时，可以让某一处或多出的路径参数前面加上一个冒号，长得比较像vue中的动态绑定，动态路径在REST风格上被广泛运行，比如操作某个用户: 'user/:id =&gt; 'user/1&quot;))
    } else if (req.params.kind == 'RequestParam') {
        result.push(new Item(&quot;lesson&quot;,&quot;请求参数&quot;));
        result.push(new Item(&quot;info&quot;,&quot;在express中叫做query，和路径变量相比，前者更像是前端主动携带参数去访问特定的资源，而后者更像是后端要求必须携带的数据，前端被迫携带，反应在路径上形式一般是: '/stu?class=2&amp;sid=1&amp;name='evanp',在基本路径之后添上一个问号，然后在后面加上请求的参数，不同参数之间用'&amp;'符号隔开&quot;))
    } else if (req.params.kind == 'body') {
        result.push(new Item(&quot;lesson&quot;,&quot;请求体&quot;));
        result.push(new Item(&quot;info&quot;,&quot;路径变量和请求参数的数据都是透明的，这非常不注重隐私，因此更多时候前端应该将携带的数据放在请求体内进行传输。请求体的形式有很多，最常用的是表单和JSON，请在路径后新增一个路径变量，form-urlencode, multi-form-data或json导向不同的接口进行查看&quot;));
    } else {
        result.push(new Item(&quot;error&quot;,&quot;这个参数不认识&quot;));
    }
    res.send(result);
});
</code></pre>
<h4 id="接口测试"><a class="header" href="#接口测试">接口测试</a></h4>
<p>请使用接口调试工具，带上路径查询参数(query)，然后修改不同的kind为不同的值，去POST访问 localhost:8080/request/data/kind，看看它们的返回结果，注意kind前不要加冒号了，冒号是用来让express知道这段路径是可变的</p>
<h4 id="第二个接口-1"><a class="header" href="#第二个接口-1">第二个接口</a></h4>
<p>当第一个接口的某一个分支还可以有后续的操作时，可以再开一个接口以它作为基路由，往后新增动态路径，比如我现在要让body可以再导向不同的分支，就再开一个 /request/data/body/:kind 接口</p>
<pre><code class="language-js">app.post('/request/data/body/:kind', function (req, res) {
    let result = [];
    if (req.params.kind == 'json') {
        result.push(new Item(&quot;lesson&quot;,&quot;json请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
        result.push(new Item(&quot;info&quot;,&quot;express想解析json形式的body，必须先开启express.json: 'app.use(express.json)'，之后就可以用req.body来接收请求体了&quot;));
        result.push(new Item(&quot;trick&quot;,&quot;进阶技巧，读取请求体时可以用match模式匹配成自己想要的格式或命名，常用于实体注入及转化等&quot;));
    } else if (req.params.kind == 'form-urlencode') {
        result.push(new Item(&quot;lesson&quot;,&quot;form-urlencode请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
    } else if (req.params.kind == 'multi-form-data') {
        result.push(new Item(&quot;lesson&quot;,&quot;multi-form-data请求体&quot;));
        result.push(new Item(&quot;body&quot;,req.body));
    } else {
        result.push(new Item(&quot;error&quot;,&quot;这个参数不认识&quot;));
    }
    res.send(result);
});
</code></pre>
<h4 id="接口测试-1"><a class="header" href="#接口测试-1">接口测试</a></h4>
<p>请使用接口调试工具，带上JSON请求体，去POST访问 localhost:8080/request/data/body/kind，修改不同的kind，看看它们的返回结果</p>
<h2 id="获取路径参数"><a class="header" href="#获取路径参数">获取路径参数</a></h2>
<h3 id="基础"><a class="header" href="#基础">基础</a></h3>
<p>路径参数是指 '/url?id=1&amp;name=evanp' 这种url中的id和name，是明文的不具有隐私性<br />
可以通过 <code>req.query</code>获取</p>
<pre><code class="language-js">app.post('/request/data/query/info',checkQuery, (req, res)=&gt; {
    res.send(req.query);
});
</code></pre>
<p>尝试用接口调试工具访问 localhost:8080/request/data/query/info，并携带上任意的query参数</p>
<h3 id="query预检"><a class="header" href="#query预检">Query预检</a></h3>
<p>在实际场景中，每个接口会指定需要哪些名字的query参数，假设上面的接口需要id和name，则需要保证前端确实给接口传递了这两个query参数，express没有像springboot那样在入参的时候就可以规定检验，我们必须亲自对传过来的query进行检验。而这部分检验的操作不建议包含在我们接口的主体回调函数内，而应作为一个<strong>中间件</strong>，在回调之前就完成检验:</p>
<p>定义一个检查query的函数，判断是否有id和name，是的话继续，不是的话直接返回错误信息</p>
<pre><code class="language-js">function checkQuery(req,res) {
    if (req.query.id == undefined ||
        req.query.id == null ||
        req.query.name == undefined ||
        req.query.name == null){
        res.send({&quot;msg&quot;: &quot;query不齐全&quot;});
    }
}
</code></pre>
<p>在接口入参时引入该中间件函数</p>
<pre><code class="language-js">app.post('/request/data/query/info',checkQuery, (req, res)=&gt; {
    res.send(req.query);
});
</code></pre>
<p>尝试用接口调试工具访问 localhost:8080/request/data/query/info，并比较不携带id,name和携带了id,name的返回结果</p>
<h2 id="获取请求体"><a class="header" href="#获取请求体">获取请求体</a></h2>
<h3 id="json请求体"><a class="header" href="#json请求体">JSON请求体</a></h3>
<p>引入以下代码一次即可</p>
<pre><code class="language-js">app.use(express.json({type: 'application/json'}));
</code></pre>
<h3 id="表单x-www-form-urlencoded"><a class="header" href="#表单x-www-form-urlencoded">表单（x-www-form-urlencoded）</a></h3>
<p><strong>x-www-form-urlencode</strong>将表单数据编码为URL形式的字符串</p>
<p>引入以下代码一次即可</p>
<pre><code class="language-js">app.use(express.urlencoded({extended: true}));
</code></pre>
<p>关于extended参数，是指将（URL编码字符串形式的）表单数据解析为简单对象还是深度嵌套对象.<br />
什么意思呢？就比如当extended=false时，表单里是这么传数据的: 
其中，有两个相同的键名: 比如传了2个x
解析后该字段的指将是所有它们的值的数组集合：<code>x=1&amp;x=2</code> -&gt; <code>{'x': ['1','2']}</code>，即便2个x都为1，也是数组: <code>{'x': ['1','1']}</code><br />
其中，又有的键名是以对象属性格式传递的，比如下图的user[uname]:
<img src="https://evan-oss-bucket1.oss-cn-hangzhou.aliyuncs.com/express-demo/x-form.png" alt="表单传嵌套对象" />
假如我们在api调试工具访问之前那个body/form-urlencode接口，同时以表单方式传输了这两种情况的数据，将得到这样的返回结果: </p>
<pre><code class="language-json">[
    {
        &quot;name&quot;: &quot;lesson&quot;,
        &quot;value&quot;: &quot;form-urlencode请求体&quot;
    },
    {
        &quot;name&quot;: &quot;body&quot;,
        &quot;value&quot;: {
            &quot;user[uname]&quot;: &quot;evanp&quot;,
            &quot;user[passwd]&quot;: &quot;iloveu&quot;,
            &quot;x&quot;: [
                &quot;1&quot;,
                &quot;2&quot;
            ]
        }
    }
]
</code></pre>
<p>当extended=true时，则是:</p>
<pre><code class="language-json">[
    {
        &quot;name&quot;: &quot;lesson&quot;,
        &quot;value&quot;: &quot;form-urlencode请求体&quot;
    },
    {
        &quot;name&quot;: &quot;body&quot;,
        &quot;value&quot;: {
            &quot;user&quot;: {
                &quot;uname&quot;: &quot;evanp&quot;,
                &quot;passwd&quot;: &quot;iloveu&quot;
            },
            &quot;x&quot;: [
                &quot;1&quot;,
                &quot;2&quot;
            ]
        }
    }
]
</code></pre>
<p>通过对比我们可以发现，<code>extended=false</code>时express比较憨，不会智能解析user到一个对象上去；智能解析的用处，我想大概是省的我们手动一条条注入属性到对象上去了</p>
<h4 id="表单验证"><a class="header" href="#表单验证">表单验证</a></h4>
<p>对于请求参数我们有验证的需求，同样的，表单验证自然也会有，甚至可能需求性更高，因为需要考虑到安全问题<br />
如果没有什么特殊要求，可以自己写一个中间件函数来检查表单，如果有比较高级的需求，可以借助线程的js库，如<strong>express-validator</strong>等</p>
<h2 id="表单multi-form-data"><a class="header" href="#表单multi-form-data">表单（multi-form-data）</a></h2>
<p>这个是可以一边传字符串，还可以传文件的表单，其实就是基础表单的一个升级版</p>
<p>需要事先安装<strong>multer</strong>依赖: <code>npm install multer</code><br />
引入依赖中间件: </p>
<pre><code class="language-js">const multer = require('multer');
const uploads = multer();
</code></pre>
<p>在需要接收文件的接口引入该中间件uploads:</p>
<pre><code class="language-js">app.post('/request/data/body/:kind', uploads.any(), function (req, res) 
</code></pre>
<p>在主体回调函数中通过<code>req.files</code>可以获取到所有的文件:</p>
<pre><code class="language-js">console.log(req.files); //写在multi-form-data分支下，方便区分
</code></pre>
<h3 id="测试接口-4"><a class="header" href="#测试接口-4">测试接口</a></h3>
<p>使用api调试工具的复合表单携带文件发送请求到 body/multi-form-data 接口，查看我们的控制台:</p>
<pre><code class="language-bash">[
  {
    fieldname: 'file',
    originalname: 'C.jpeg',
    encoding: '7bit',
    mimetype: 'image/jpeg',
    buffer: &lt;Buffer ff d8 ff e0 00 10 4a 46 49 46 00 01 01 01 00 48 00 48 00 00 ff db 00 43 00 0a 07 08 09 08 06 0a 09 08 09 0c 0b 0a 0c 0f 1a 11 0f 0e 0e 0f 1f 16 18 13 ... 9752 more bytes&gt;,
    size: 9802
  }
]
</code></pre>
<p>是的，我刚刚传了一张名为 C.jpeg 的图片到服务器</p>
<h2 id="下一章-sql增删改查"><a class="header" href="#下一章-sql增删改查">下一章-Sql增删改查</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql增删改查"><a class="header" href="#sql增删改查">Sql增删改查</a></h1>
<h2 id="下一章-sql-orm增删改查"><a class="header" href="#下一章-sql-orm增删改查">下一章-Sql-ORM增删改查</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-orm增删改查"><a class="header" href="#sql-orm增删改查">Sql-ORM增删改查</a></h1>
<h2 id="下一章-路由控制"><a class="header" href="#下一章-路由控制">下一章-路由控制</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="路由控制"><a class="header" href="#路由控制">路由控制</a></h1>
<h2 id="下一章-jwt基础鉴权"><a class="header" href="#下一章-jwt基础鉴权">下一章-JWT基础鉴权</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jwt基础鉴权"><a class="header" href="#jwt基础鉴权">JWT基础鉴权</a></h1>
<h2 id="下一章-全局错误处理"><a class="header" href="#下一章-全局错误处理">下一章-全局错误处理</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局错误处理"><a class="header" href="#全局错误处理">全局错误处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="架构整合"><a class="header" href="#架构整合">架构整合</a></h1>
<p>在第一章中，我们按功能分块学习了express后端中不同方面的技术，所有的代码基本都写在了一个文件中，在实际开发中这是不符合规范的，我们需要有一个合理的目录结构，在本章中，将结合常见的前后端架构思想，express.js特性以及借鉴其他语言的优秀框架的架构，每节介绍一种架构方式</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
